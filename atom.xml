<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code</title>
  
  <subtitle>码总</subtitle>
  <link href="/liudong-code.github.io/atom.xml" rel="self"/>
  
  <link href="https://liudong-code.github.io/"/>
  <updated>2020-03-04T05:52:32.381Z</updated>
  <id>https://liudong-code.github.io/</id>
  
  <author>
    <name>Liu Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java8的新特性</title>
    <link href="https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-03-04T04:33:02.000Z</published>
    <updated>2020-03-04T05:52:32.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a><strong>一、接口的默认方法</strong></h2><p> Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);   <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);      <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p> 首先看看在老版本的Java中是如何排列字符串的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： </p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a><strong>四、方法与构造函数引用</strong></h2><p> 前一节中的代码还可以通过静态方法引用来表示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p> Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure><p> 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String firstName;  </span><br><span class="line">  String lastName; </span><br><span class="line"></span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person(String firstName, String lastName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来我们指定一个用来创建Person对象的对象工厂接口： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure><p> 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 </p><h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a><strong>五、Lambda 作用域</strong></h2><p> 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 </p><h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a><strong>六、访问局部变量</strong></h2><p> 我们可以直接在lambda表达式中访问外层的局部变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> 在lambda表达式中试图修改num同样是不允许的。 </p><h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p> 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">   <span class="keyword">int</span> outerNum; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">      outerNum = <span class="number">23</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">      outerStaticNum = <span class="number">72</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p> 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure><p> JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 </p><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p> Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);       <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p> Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); </span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);   <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure><h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();  <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p> Consumer 接口表示执行在单个参数上的操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);       <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2); <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure><h3 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a>Optional 接口</h3><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();      <span class="comment">// true</span></span><br><span class="line">optional.get();         <span class="comment">// "bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);  <span class="comment">// "bam"</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));   <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure><p> Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： </p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a><strong>Filter 过滤</strong></h3><p> 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"></span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure><h3 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h3><p> 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .sorted()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure><p> 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p> 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p> Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>)); </span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a><strong>Count 计数</strong></h3><p> 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">    .count(); </span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce 规约"></a>Reduce 规约</h3><p> 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line"></span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure><h3 id="并行Streams"><a href="#并行Streams" class="headerlink" title="并行Streams"></a>并行Streams</h3><p> 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 </p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">  UUID uuid = UUID.randomUUID();</span><br><span class="line">  values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们计算一下排序这个Stream要耗时多久， </p><p> 串行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 串行耗时: 899 ms </p><p> 并行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 </p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><p> 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure><p> 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 </p><p> 下面的例子展示了map上的其他有用的函数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p> 接下来展示如何在Map里删除一个键值全都匹配的项： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// val33 </span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p> 另外一个有用的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>); <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9 </span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><p> Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 </p><h2 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a><strong>九、Date API</strong></h2><p> java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： </p><h3 id="Clock-时钟"><a href="#Clock-时钟" class="headerlink" title="Clock 时钟"></a><strong>Clock 时钟</strong></h3><p> Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = clock.millis(); </span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);  <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p> 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// prints all available timezone ids </span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime 本地时间"></a>LocalTime 本地时间</h3><p> LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line"></span><br><span class="line"> LocalTime now2 = LocalTime.now(zone2); </span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);    <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);   <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p> LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(late);    <span class="comment">// 23:59:59 </span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">  DateTimeFormatter</span><br><span class="line">    .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">    .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);  <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate 本地日期"></a><strong>LocalDate 本地日期</strong></h3><p> LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);  <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line"></span><br><span class="line">   DateTimeFormatter</span><br><span class="line">    .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">    .withLocale(Locale.GERMAN); </span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);  <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure><p>LocalDateTime 本地日期时间</p><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。</p><p>LocalDateTime提供了一些能访问具体字段的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);   <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);     <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);  <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure><p> 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">  .atZone(ZoneId.systemDefault())</span><br><span class="line">    .toInstant(); </span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);   <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure><p> 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =  DateTimeFormatter.ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>); </span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);   <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure><p> 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a> </p><h2 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a><strong>十、Annotation 注解</strong></h2><p> 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">  Hint[] value();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p><p> 例 1: 使用包装类当容器来存多个注解（老方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 例 2：使用多重注解（新方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hint);          <span class="comment">// null </span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hints</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotationsByType</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints2.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p> 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p> 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、接口的默认方法&quot;&gt;&lt;a href=&quot;#一、接口的默认方法&quot; class=&quot;headerlink&quot; title=&quot;一、接口的默认方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、接口的默认方法&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; Java 8允许我们给接口添加一个非抽象的方法实
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>动态代理与cglib实现的区别</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-04T03:54:58.000Z</published>
    <updated>2020-03-04T04:06:13.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ol><li>Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷；</li><li>Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上；</li><li>Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来。</li><li>InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul><li>JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。</li><li>JDK动态代理的基础是反射机制（method.invoke(对象，参数)）Proxy.newProxyInstance()</li></ul><h3 id="jdk动态代理代码"><a href="#jdk动态代理代码" class="headerlink" title="jdk动态代理代码"></a><strong>jdk动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line">      <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.得到目标对象的类加载器</span></span><br><span class="line">        ClassLoader classLoader = target.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 2.得到目标对象的实现接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 3.第三个参数需要一个实现invocationHandler接口的对象</span></span><br><span class="line">        Object newProxyInstance = Proxy.newProxyInstance(classLoader, interfaces, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数:代理对象.一般不使用;第二个参数:需要增强的方法;第三个参数:方法中的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        JDKProxyFactory proxy = <span class="keyword">new</span> JDKProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​        原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意</strong>:</h3><p>​        jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。 </p><h3 id="cglib动态代理代码"><a href="#cglib动态代理代码" class="headerlink" title="cglib动态代理代码"></a><strong>cglib动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123; </span><br><span class="line">      <span class="comment">//得到目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法传递目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.传递目标对象的class</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调操作</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数一:代理对象;参数二:需要增强的方法;参数三:需要增强方法的参数;参数四:需要增强的方法的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = methodProxy.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        CglibProxyFactory proxy = <span class="keyword">new</span> CglibProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-04T02:29:37.000Z</published>
    <updated>2020-03-04T03:51:24.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、单例模式："><a href="#1、单例模式：" class="headerlink" title="1、单例模式："></a>1、单例模式：</h1><p>在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式</p><h1 id="2、单例模式的设计原则："><a href="#2、单例模式的设计原则：" class="headerlink" title="2、单例模式的设计原则："></a>2、单例模式的设计原则：</h1><p>1、构造方法私有化<br>2、在类中创建好该类对象<br>3、在类中，给外界提供获取该对象的公有方式 </p><h2 id="2-1饿汉式"><a href="#2-1饿汉式" class="headerlink" title="2.1饿汉式"></a>2.1饿汉式</h2><p>在加载类的同时，就要初始化静态成员变量，所以就同时将该类对象创建出来了<br>饿汉式：一有机会，马上就吃，不去等待。（一旦加载类型，马上创建对象） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例设计模式之饿汉式</span></span><br><span class="line"><span class="comment">//能多早创建对象就多早创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_SingtonleHunger</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SingtonHunger sh1 = SingtonHunger.getInstance();</span><br><span class="line">SingtonHunger sh2 = SingtonHunger.getInstance();</span><br><span class="line">System.out.println(sh1==sh2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonHunger</span></span>&#123;</span><br><span class="line"><span class="comment">//1.先私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonHunger</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2.私有创建对象的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonHunger sh = <span class="keyword">new</span> SingtonHunger();</span><br><span class="line"><span class="comment">//3.通过创建对外界可见的方法来调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonHunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。 </p><h2 id="2-2懒汉式"><a href="#2-2懒汉式" class="headerlink" title="2.2懒汉式"></a>2.2懒汉式</h2><p>在加载类的时候，不同时创建该类对象，等到需要获取这个对象时，才去创建这个对象<br>懒汉式：不着急、能不创建的时候，就不创建，能拖就拖 </p><p>注意事项：<br>1、只有在sl == null的时候，才会创建对象<br>2、sl的判断和sl的赋值，不希望分离开，否则在多线程环境下，会出现多个对象的状态，所以sl的判断和sl的赋值，需要放到一个同步代码块中。<br>3、同步代码块的效率非常低，不是每次获取对象的时候，都需要判断锁对象，只有在sl为null的时候， 才应该判断锁对象，因此在外层需要嵌套一个if判断，判断sl是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式之懒汉式</span></span><br><span class="line"><span class="comment">//能多晚创建对象就多晚创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_SingletonLazy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SingtonLazy sl1 = SingtonLazy.getInstance();</span><br><span class="line">SingtonLazy sl2 = SingtonLazy.getInstance();</span><br><span class="line">System.out.println(sl1==sl2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonLazy</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.私有创建对象的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonLazy sl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供对外公开的方法创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//最外层判断是否为空用来提高效率</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SingtonLazy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">//加上同步锁提高线程安全</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line">sl = <span class="keyword">new</span> SingtonLazy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种懒汉式</p><p>public class SingletonDemo2 {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法同步，调用效率低</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">        instance=<span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种如果是多线程的，会有JVM 指令重排的机制，破坏其单例类，所以双重锁判断机制好一些</p><h2 id="2-3静态内部类实现"><a href="#2-3静态内部类实现" class="headerlink" title="2.3静态内部类实现"></a>2.3静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo3 instance=<span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4枚举类"><a href="#2-4枚举类" class="headerlink" title="2.4枚举类"></a>2.4枚举类</h2><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo4 &#123;</span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、单例模式：&quot;&gt;&lt;a href=&quot;#1、单例模式：&quot; class=&quot;headerlink&quot; title=&quot;1、单例模式：&quot;&gt;&lt;/a&gt;1、单例模式：&lt;/h1&gt;&lt;p&gt;在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式&lt;/p&gt;
&lt;h1 id=&quot;2、单
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-03-04T02:01:02.000Z</published>
    <updated>2020-03-04T02:20:23.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。<br> 比如说对象 A 和对象 B，二者都是 ClassC 的对象，具有成员变量 a 和 b，现在对对象 A 进行拷贝赋值给 B，也就是 B.a = A.a; B.b = A.b;</p><p>这时再去改变 B 的属性 a 或者 b 时，可能会遇到问题：假设 a 是基础数据类型，b 是引用类型。<br> 当改变 B.a 的值时，没有问题；<br> 当改变 B.b 的值时，同时也会改变 A.b 的值，因为其实上面的例子中只是把 A.b 赋值给了 B.b，因为是 b 引用类型的，所以它们是指向同一个地址的。这可能就会给我们使用埋下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。</span><br></pre></td></tr></table></figure><h1 id="拷贝分类"><a href="#拷贝分类" class="headerlink" title="拷贝分类"></a>拷贝分类</h1><p>上面的问题，其实就是因为对拷贝的不熟悉导致的。</p><p>根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种：</p><ul><li>浅拷贝 (<code>Shallow Copy</code>)</li><li>深拷贝 (<code>Deep Copy</code>)</li></ul><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="1-浅拷贝介绍"><a href="#1-浅拷贝介绍" class="headerlink" title="1. 浅拷贝介绍"></a>1. 浅拷贝介绍</h2><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h2 id="2-浅拷贝特点"><a href="#2-浅拷贝特点" class="headerlink" title="2. 浅拷贝特点"></a>2. 浅拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。<br> (2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy.png" alt></p><h2 id="3-浅拷贝的实现"><a href="#3-浅拷贝的实现" class="headerlink" title="3. 浅拷贝的实现"></a>3. 浅拷贝的实现</h2><p>实现对象拷贝的类，需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br></pre></td></tr></table></figure><p>输出的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:lishi],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject[Subject:<span class="number">1163157884</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="1-深拷贝介绍"><a href="#1-深拷贝介绍" class="headerlink" title="1. 深拷贝介绍"></a>1. 深拷贝介绍</h2><p>通过上面的例子可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 <code>studentB</code> 的 <code>subject</code>，但是 <code>studentA</code> 的 <code>subject</code> 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></pre></td></tr></table></figure><h2 id="2-深拷贝特点"><a href="#2-深拷贝特点" class="headerlink" title="2. 深拷贝特点"></a>2. 深拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。<br> (2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。<br> (3) 对于有多层对象的，每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。<br> (4) 深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy2.png" alt></p><h2 id="3-深拷贝的实现"><a href="#3-深拷贝的实现" class="headerlink" title="3. 深拷贝的实现"></a>3. 深拷贝的实现</h2><p>对于 <code>Student</code> 的引用类型的成员变量 <code>Subject</code> ，需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>Student</code> 的 <code>clone()</code> 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.subject = (Subject) subject.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一样的使用方式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:yuwen],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject:[Subject:<span class="number">356573597</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p> 由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。&lt;br&gt; 比如说对象 A 和对象 B，二者都是 ClassC 的
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java内存溢出</title>
    <link href="https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2020-03-02T02:16:07.000Z</published>
    <updated>2020-03-02T02:56:53.160Z</updated>
    
    <content type="html"><![CDATA[<p>–本文源自于《深入理解Java虚拟机》</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>​        Java堆用于储存对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象到达最大堆的容量之后，就会产生内存溢出异常。</p><p>java.lang.OutOfMem0ryError:Java  heap space</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Vm Args:-Xms20m XMx20m -XX:+HeapDumpOnOUtOFMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">aList.add(<span class="string">"asdasdasdas"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">System.out.println(aList.size());</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决手段："><a href="#解决手段：" class="headerlink" title="解决手段："></a>解决手段：</h3><p>​        先通过内存映像分析工具（如：Eclipse Memory Analyzer）堆Dump出来的堆转储快照进行分析，重点确认内存中的对象是否是必要的，也就是药神分清楚到底是出现了内存泄漏还是内存溢出。</p><p>​        如果是内存泄漏，可以进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾回收器无法自动回收他们的。掌握了泄漏对象的类型信息，及GCRoots引用链的信息，就可以比较准确的定位出泄漏代码的 位置。</p><p>​        如果不是泄漏，就是在内存中对象还活着，应当检查虚拟机的堆参数（-Xmx与Xms）</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>​        Java虚拟机规范中描述了两种异常</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(i++);</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JvmTest j = <span class="keyword">new</span> JvmTest();</span><br><span class="line">j.a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>–待补</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>–待补</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;–本文源自于《深入理解Java虚拟机》&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://liudong-code.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>throw和throws的区别</title>
    <link href="https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-29T11:12:48.000Z</published>
    <updated>2020-02-29T11:18:05.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>抛出异常有三种形式</strong></p><ul><li>throw</li><li>throws</li><li>系统自动抛异常</li></ul><p><strong>一、系统自动抛异常</strong></p><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常：（举个栗子）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>; </span><br><span class="line">    System.out.println(<span class="number">5</span>/b);   <span class="comment">// 此处系统会自动抛出ArithmeticException异常</span></span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、throw</strong></p><p>throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>运行时，系统会抛出如下异常：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NumberFormatException at......</span><br></pre></td></tr></table></figure><p><strong>三、throws</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当某个方法可能会抛出某种异常时用于<span class="keyword">throws</span> 声明可能抛出的异常，然后交给上层调用它的方法程序处理</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">testThrows</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123; </span><br><span class="line">String s = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(Double.parseDouble(s)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">function(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; </span><br><span class="line">System.err.println(<span class="string">"非数据类型不能强制类型转换。"</span>); </span><br><span class="line"><span class="comment">//e.printStackTrace(); </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 四、throw与throws的比较</p><p>throws出现在方法函数头；而throw出现在函数体。<br>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p><p>五、编程习惯：</p><p>在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；<br>用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();<br>如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；<br>如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理</p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;抛出异常有三种形式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;throw&lt;/li&gt;
&lt;li&gt;throws&lt;/li&gt;
&lt;li&gt;系统自动抛异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一、系统自动抛异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当程序语句出现一些逻
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java中的异常链</title>
    <link href="https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/"/>
    <id>https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/</id>
    <published>2020-02-29T11:07:08.000Z</published>
    <updated>2020-02-29T11:11:28.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   ChainTest ct=<span class="keyword">new</span> ChainTest();<span class="comment">//创建chainTest实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     ct.test2();    </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span><span class="keyword">throws</span> DrunkException</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> DrunkException(<span class="string">"喝车别开酒"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     test1();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (DrunkException e)&#123;</span><br><span class="line"></span><br><span class="line">       RuntimeException newExc=<span class="keyword">new</span> RuntimeException(<span class="string">"司机一滴酒亲人两行泪"</span>)；<span class="comment">//含参构造器  </span></span><br><span class="line"></span><br><span class="line">       newExc.initCause(e);<span class="comment">//调用newExc的init方法，把捕获的DrunkException传进去</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> newExc;<span class="comment">//抛出新异常</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 &lt;
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java的异常体系</title>
    <link href="https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2020-02-29T10:54:18.000Z</published>
    <updated>2020-02-29T11:20:57.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java中异常的体系结构图解："><a href="#java中异常的体系结构图解：" class="headerlink" title="java中异常的体系结构图解："></a>java中异常的体系结构图解：</h3><p><img src="/liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/yichang.png" alt></p><p>​        java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。 </p><h3 id="java异常体系结构"><a href="#java异常体系结构" class="headerlink" title="java异常体系结构"></a><strong>java异常体系结构</strong></h3><p>​        Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p><p>1、Error与Exception<br>         Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<br>         Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<br>2、运行时异常和非运行时异常<br>         运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>         非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a><strong>异常的捕获和处理</strong></h3><h4 id="try、catch、finally"><a href="#try、catch、finally" class="headerlink" title="try、catch、finally"></a>try、catch、finally</h4><p>  第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。<br>  第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。<br>  第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。<br>   第四：先Catch子类异常再Catch父类异常。 </p><h4 id="throw、throws关键字"><a href="#throw、throws关键字" class="headerlink" title="throw、throws关键字"></a>throw、throws关键字</h4><pre><code>throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方</code></pre><p>法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取</p><p>的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span>&#123;  </span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"方法test中的Exception"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java中异常的体系结构图解：&quot;&gt;&lt;a href=&quot;#java中异常的体系结构图解：&quot; class=&quot;headerlink&quot; title=&quot;java中异常的体系结构图解：&quot;&gt;&lt;/a&gt;java中异常的体系结构图解：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/liudong
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何格式化日期</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/</id>
    <published>2020-02-29T10:42:07.000Z</published>
    <updated>2020-02-29T11:24:29.516Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String date = localDate.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(<span class="string">"date:"</span>+date)；</span><br></pre></td></tr></table></figure><p> 补充:java的时间日期API一直以来都是被诟病的东西,为了解决这一问题,java8中引入了新的时间日期API,其中包括LocalDate,LocalTime,LocalDate,LocalDateTime,Clock,Instant等类,这些的类的设计都使用了不变模式,因此是线程安全的设计.</p><p>原文链接：<a href="https://blog.csdn.net/riju4713/article/details/88220120" target="_blank" rel="noopener">https://blog.csdn.net/riju4713/article/details/88220120</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/</id>
    <published>2020-02-29T10:35:58.000Z</published>
    <updated>2020-02-29T10:38:33.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可以被继承，代码如下"><a href="#可以被继承，代码如下" class="headerlink" title="可以被继承，代码如下"></a>可以被继承，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span></span>&#123;</span><br><span class="line"><span class="comment">//空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line">oneFn</span><br><span class="line">One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br><span class="line">one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br></pre></td></tr></table></figure><h3 id="不能被重写，代码如下"><a href="#不能被重写，代码如下" class="headerlink" title="不能被重写，代码如下"></a>不能被重写，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被重写？以及原因？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"two"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"TwoFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line"><span class="comment">//oneFn</span></span><br><span class="line"><span class="comment">//One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br><span class="line"><span class="comment">//one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。</p><p>注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可以被继承，代码如下&quot;&gt;&lt;a href=&quot;#可以被继承，代码如下&quot; class=&quot;headerlink&quot; title=&quot;可以被继承，代码如下&quot;&gt;&lt;/a&gt;可以被继承，代码如下&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>string转换成integer的方式及原理</title>
    <link href="https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-29T10:04:02.000Z</published>
    <updated>2020-02-29T10:23:45.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string转换成integer的方式及原理"><a href="#string转换成integer的方式及原理" class="headerlink" title="string转换成integer的方式及原理"></a>string转换成integer的方式及原理</h1><h4 id="1-Integer-parseInt（String-str）方法"><a href="#1-Integer-parseInt（String-str）方法" class="headerlink" title="1. Integer.parseInt（String str）方法"></a>1. Integer.parseInt（String str）方法</h4><p>​      源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Integer-parseInt（String-s-int-radix）方法"><a href="#2-Integer-parseInt（String-s-int-radix）方法" class="headerlink" title="2. Integer.parseInt（String s, int radix）方法"></a>2. Integer.parseInt（String s, int radix）方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException</span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">         * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">         * the valueOf method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//基数是否小于最小基数</span></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否是负数</span></span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="comment">//最大值限制</span></span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> multmin;</span><br><span class="line">        <span class="keyword">int</span> digit;</span><br><span class="line"><span class="comment">//判断字符长度是否大于0，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//第一个字符是否是符号</span></span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//根据ascii码表看出加号(43)和负号(45)对应的</span></span><br><span class="line">            <span class="comment">//十进制数小于‘0’(48)的</span></span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">                 <span class="comment">//是负号</span></span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    <span class="comment">//负号属性设置为true</span></span><br><span class="line">                    negative = <span class="keyword">true</span>;</span><br><span class="line">                    limit = Integer.MIN_VALUE;</span><br><span class="line">                    <span class="comment">//不是负号也不是加号则抛出异常</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"><span class="comment">//如果有符号（加号或者减号）且字符串长度为1，则抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            multmin = limit / radix;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                <span class="comment">//此方法为确定数字的的十进制值</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="comment">//小于0，则为非数值字符串</span></span><br><span class="line">                <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//result第一次为0，第一次肯定为true</span></span><br><span class="line">                <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//result乘以基数（10）为得到位置</span></span><br><span class="line">                <span class="comment">//例如第一次的result为-1，第二次乘以10后为-10</span></span><br><span class="line">                <span class="comment">//下面再-=digit（例如：1）则得到-11</span></span><br><span class="line">                <span class="comment">//以此类推</span></span><br><span class="line">                result *= radix;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次result为0 -=digit则为负值的该digit</span></span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//根据上面得到的是否负数，返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-Character-digit-char-ch-int-radix-方法"><a href="#3-Character-digit-char-ch-int-radix-方法" class="headerlink" title="3.Character.digit(char ch, int radix)方法"></a>3.Character.digit(char ch, int radix)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digit</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基数必须再最大和最小基数之间</span></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; MIN_RADIX || radix &gt; MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (codePoint &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            <span class="comment">// Optimized for ASCII</span></span><br><span class="line">            <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//字符在0-9字符之间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                result = codePoint - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符在a-z之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                result = <span class="number">10</span> + (codePoint - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符在A-Z之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">                result = <span class="number">10</span> + (codePoint - <span class="string">'A'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过判断result和基数大小，输出对应值</span></span><br><span class="line">            <span class="comment">//通过我们parseInt对应的基数值为10，</span></span><br><span class="line">            <span class="comment">//所以，只能在第一个判断（字符在0-9字符之间）</span></span><br><span class="line">            <span class="comment">//中得到result值 否则后续程序会抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> result &lt; radix ? result : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digitImpl(codePoint, radix);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：integer.parseInt(string str)方法调用Integer内部的 parseInt(string str,10)方法,默认基数为10，parseInt内部首先 判断字符串是否包含符号（-或者+），则对相应的negative和limit进行 赋值，然后再循环字符串，对单个char进行数值计算Character.digit(char ch, int radix) 在这个方法中，函数肯定进入到0-9字符的判断（相对于string转换到int）， 否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;string转换成integer的方式及原理&quot;&gt;&lt;a href=&quot;#string转换成integer的方式及原理&quot; class=&quot;headerlink&quot; title=&quot;string转换成integer的方式及原理&quot;&gt;&lt;/a&gt;string转换成integer的方式及
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>序列化的方式</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-29T03:23:06.000Z</published>
    <updated>2020-02-29T09:53:38.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>序列化：将对象转化成一个字节序列，便于储存。</p><p>反序列化：将字节化的字节序列还原。</p><p> 优点：可以实现对象的”持久性”， 所谓持久性就是指对象的生命周期不取决于程序。 </p><h2 id="序列化的几种方式"><a href="#序列化的几种方式" class="headerlink" title="序列化的几种方式"></a>序列化的几种方式</h2><h3 id="Java原生的序列化"><a href="#Java原生的序列化" class="headerlink" title="Java原生的序列化"></a>Java原生的序列化</h3><pre><code>**序列化需要：**   所需类：ObjectInputStream和ObjectOutputStream   方法： readObject()和writeObject(); </code></pre><h4 id="隐式序列化"><a href="#隐式序列化" class="headerlink" title="隐式序列化"></a>隐式序列化</h4><p>​        实现Serializabie接口，通过实现Serializable接口，这种是隐式序列化(不需要手动)，这种是最简单的序列化方式，会自动序列化所有非static和 transient关键字修饰的成员变量。  </p><p>​        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpConfig</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> virualAge = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String ipAdress =<span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IpConfig</span><span class="params">(String name, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">"\n"</span></span><br><span class="line">                +<span class="string">"age: "</span> + age + <span class="string">"\n"</span></span><br><span class="line">                +<span class="string">"virualAge: "</span> + virualAge + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"ipAdress: "</span> + ipAdress;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建可序列化对象</span></span><br><span class="line">        System.out.println(<span class="string">"原来的对象："</span>);</span><br><span class="line">        IpConfig ipConfig = <span class="keyword">new</span> IpConfig(<span class="string">"Ming"</span>, <span class="number">16</span>);</span><br><span class="line">        System.out.println(ipConfig);</span><br><span class="line">        <span class="comment">//创建序列化输出流</span></span><br><span class="line">        ByteArrayOutputStream  outputStream=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream  objectOutputStream=<span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将序列化对象存入缓冲区</span></span><br><span class="line">        objectOutputStream.writeObject(ipConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改值</span></span><br><span class="line">        ipConfig.SetAge(<span class="number">11</span>);</span><br><span class="line">        IpConfig.virualAge=<span class="number">5555</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓冲区取回被序列化的对象</span></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray()));</span><br><span class="line">        IpConfig newIpconfig = (IpConfig) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"序列化后取出的对象："</span>);</span><br><span class="line">        System.out.println(newIpconfig);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">原来的对象：</span><br><span class="line">name: Ming</span><br><span class="line">age: <span class="number">16</span></span><br><span class="line">virualAge: <span class="number">123</span></span><br><span class="line">address: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">序列化后取出的对象：</span><br><span class="line">name: Ming</span><br><span class="line">age: <span class="number">16</span></span><br><span class="line">virualAge: <span class="number">5555</span></span><br><span class="line">address: <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>​        发现ipAddress(被transient)和virualAge(被static)也没有被序列化，中途修改virualAge的值是为了以防读者误会virualAge被序列化了。因为序列化可以保存对象的状态，但是virualAge的值被改变了，说明没有被序列化。static成员不属于对象实例，可能被别的对象修改没办法序列化,序列化是序列对象。对于address被反序列化后由于没有对应的引用，所以为null。而且Serializable不会调用构造方法。</p><h4 id="显式序列化"><a href="#显式序列化" class="headerlink" title="显式序列化"></a>显式序列化</h4><p>​        实现Externalizable接口</p><p>​        Externalizable接口继承自Serializable, 我们在实现该接口时，必须实现writeExternal()和readExternal()方法，而且只能通过手动进行序列化，并且两个方法是自动调用的，因此，这个序列化过程是可控的，可以自己选择哪些部分序列化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Blip</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Blip</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Blip (String x, int a)"</span>);</span><br><span class="line">s = x;</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Blip.writeExternal"</span>);</span><br><span class="line">out.writeObject(s);</span><br><span class="line">out.writeInt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Blip.readExternal"</span>);</span><br><span class="line">s = (String)in.readObject();</span><br><span class="line">i = in.readInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Constructing objects"</span>);</span><br><span class="line">Blip b = <span class="keyword">new</span> Blip(<span class="string">"A Stirng"</span>, <span class="number">47</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F://Demo//file1.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"保存对象"</span>);</span><br><span class="line">o.writeObject(b);</span><br><span class="line">o.close();</span><br><span class="line"><span class="comment">//获得对象</span></span><br><span class="line">System.out.println(<span class="string">"获取对象"</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span>          FileInputStream(<span class="string">"F://Demo//file1.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"Recovering b"</span>);</span><br><span class="line">b = (Blip)in.readObject();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">打印结果为：</span><br><span class="line">Constructing objects</span><br><span class="line">Blip (String x, <span class="keyword">int</span> a)</span><br><span class="line">A Stirng47</span><br><span class="line">保存对象</span><br><span class="line">Blip.writeExternal</span><br><span class="line">获取对象</span><br><span class="line">Recovering b</span><br><span class="line">Blip.readExternal</span><br><span class="line">A Stirng47</span><br><span class="line">当注释掉writeExternal和readExternal方法后打印结果为:</span><br><span class="line">Constructing objects</span><br><span class="line">Blip (String x, <span class="keyword">int</span> a)</span><br><span class="line">A Stirng47</span><br><span class="line">保存对象</span><br><span class="line">Blip.writeExternal</span><br><span class="line">获取对象</span><br><span class="line">Recovering b</span><br><span class="line">Blip.readExternal</span><br><span class="line">null0</span><br></pre></td></tr></table></figure><pre><code>说明：Externalizable类会调用public的构造函数先初始化对象，在调用所保存的内容将对象还原。假如构造方法不是public则会出现运行时错误。 </code></pre><h4 id="显式-隐式的实现"><a href="#显式-隐式的实现" class="headerlink" title="显式+隐式的实现"></a>显式+隐式的实现</h4><p>​        如果想将方式一和方式二的优点都用到的话，可以采用方式三， 先实现Serializable接口，并且添加writeObject()和readObject()方法。注意这里是添加，不是重写或者覆盖。但是添加的这两个方法必须有相应的格式。</p><p>1，方法必须要被private修饰                                —–&gt;才能被调用<br>2，第一行调用默认的defaultRead/WriteObject(); —–&gt;隐式序列化非static和transient<br>3，调用read/writeObject()将获得的值赋给相应的值  —&gt;显式序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">public</span> String name ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"默认构造器。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerDemo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">age = stream.readInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"年龄"</span> + age + <span class="string">"  "</span> + name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">SerDemo stu = <span class="keyword">new</span> SerDemo(<span class="string">"Ming"</span>);</span><br><span class="line">ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">out.writeObject(stu);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">SerDemo stu1 = (SerDemo) in.readObject();</span><br><span class="line">System.out.println(stu1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line">年龄<span class="number">23</span>  Ming</span><br><span class="line">注释掉stream.writeInt(age)和age= stream.readInt()后：</span><br><span class="line">年龄<span class="number">0</span>  Ming</span><br><span class="line">方式三结合了显式和隐式序列化，Ming被正常序列化，由于age被trancient修饰，所以需要显式序列化。</span><br></pre></td></tr></table></figure><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>​        Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerialize</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] writeValueAsBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            writeValueAsBytes = mapper.writeValueAsBytes(u);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"json serialize: "</span> + (System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + writeValueAsBytes.length);</span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = mapper.readValue(writeValueAsBytes, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"json deserialize: "</span> + (System.currentTimeMillis() - t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json serialize: <span class="number">55</span>ms; 总大小：<span class="number">341</span></span><br><span class="line">json deserialize: <span class="number">35</span>ms; User: User [userId=<span class="keyword">null</span>, userName=张三, passWord=<span class="number">123456</span>, userInfo=张三是一个很牛逼的人, friends=[User [userId=<span class="keyword">null</span>, userName=李四, passWord=<span class="number">123456</span>, userInfo=李四是一个很牛逼的人, friends=<span class="keyword">null</span>], User [userId=<span class="keyword">null</span>, userName=王五, passWord=<span class="number">123456</span>, userInfo=王五是一个很牛逼的人, friends=<span class="keyword">null</span>]]]</span><br></pre></td></tr></table></figure><h3 id="FastJson序列化"><a href="#FastJson序列化" class="headerlink" title="FastJson序列化"></a>FastJson序列化</h3><p>​        fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本<br>支持Android。使用时候需引入FastJson第三方jar包。FastJson序列化代码示例如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FastJsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化  </span></span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        String text = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            text = JSON.toJSONString(u); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"fastJson serialize: "</span> +(System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + text.getBytes().length);</span><br><span class="line">        <span class="comment">//反序列化  </span></span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = JSON.parseObject(text, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"fastJson serialize: "</span> + (System.currentTimeMillis() -t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProtoBuff序列化"><a href="#ProtoBuff序列化" class="headerlink" title="ProtoBuff序列化"></a>ProtoBuff序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</span><br><span class="line"></span><br><span class="line">优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。</span><br><span class="line"></span><br><span class="line">缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。</span><br><span class="line"></span><br><span class="line">其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。</span><br></pre></td></tr></table></figure><p>参考地址： <a href="https://github.com/google/protobuf。" target="_blank" rel="noopener">https://github.com/google/protobuf。</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.FieldType;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.annotation.Protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7890663945232864573L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.INT32, required = <span class="keyword">false</span>, order = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">private</span> String userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.OBJECT, required = <span class="keyword">false</span>, order = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;User&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName + <span class="string">", passWord="</span> + passWord + <span class="string">", userInfo="</span> + userInfo</span><br><span class="line">                + <span class="string">", friends="</span> + friends + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> jprotobuf序列化代码示例如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.Codec;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.ProtobufProxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBuffSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProtoBuffSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u2.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u2.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u2.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_encode = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            bytes = studentClassCodec.encode(u2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf序列化耗时："</span> + (System.currentTimeMillis() - stime_jpb_encode) + <span class="string">"ms; 总大小："</span> + bytes.length);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        User user = studentClassCodec.decode(bytes);</span><br><span class="line">        Long etime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf反序列化耗时："</span>+ (etime_jpb_decode-stime_jpb_decode) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jprotobuf序列化耗时：<span class="number">9</span>ms; 总大小：<span class="number">148</span></span><br><span class="line">jprotobuf反序列化耗时：<span class="number">0</span>ms; User: User [userId=null, userName=张三, passWord=<span class="number">123456</span>, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=<span class="number">123456</span>, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=<span class="number">123456</span>, userInfo=王五是一个很牛逼的人, friends=null]]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;序列化：将对象转化成一个字节序列，便于储存。&lt;/p&gt;
&lt;p&gt;反序列化：将字节化的字节序列还原。&lt;/p&gt;
&lt;p&gt; 优点：可以实现对象的”持久性
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用技术以及epoll实现原理</title>
    <link href="https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-28T10:57:13.000Z</published>
    <updated>2020-02-28T11:36:18.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么Redis中要使用I-O多路复用呢？"><a href="#为什么Redis中要使用I-O多路复用呢？" class="headerlink" title="为什么Redis中要使用I/O多路复用呢？"></a>为什么Redis中要使用I/O多路复用呢？</h3><p>​        redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。</p><p>​        redis 采用网络IO多路复用技来保证在多连接的时候， 系统的高吞吐量。</p><p>​        Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的.</p><p>​        select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。<br>​        redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><h3 id="epoll实现机制"><a href="#epoll实现机制" class="headerlink" title="epoll实现机制"></a>epoll实现机制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设想一下如下场景：</span><br><span class="line">有<span class="number">100</span>万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的</span><br><span class="line">(事实上大部分场景都是这种情况)。如何实现这样的高并发？</span><br></pre></td></tr></table></figure><p>​        select/poll是，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p><p>​        如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p><h4 id="总结：select和poll的缺点如下："><a href="#总结：select和poll的缺点如下：" class="headerlink" title="总结：select和poll的缺点如下："></a>总结：select和poll的缺点如下：</h4><ol><li>每次调用select/poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select/poll都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>针对select支持的文件描述符数量太小了，默认是1024</li><li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li><li>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</li></ol><p>​        epoll的设计和实现与select完全不同。epoll是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。</p><p>​        epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先select/poll调用分成了3个部分：</p><p>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p><p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p><p>3）调用epoll_wait收集发生的事件的连接</p><p>​        如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><h4 id="总结：epoll的优点"><a href="#总结：epoll的优点" class="headerlink" title="总结：epoll的优点"></a>总结：epoll的优点</h4><ol><li>epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, <strong>一般来说这个数目和系统内存关系很大</strong> ，具体数目可以 cat /proc/sys/fs/file-max 察看。</li><li>效率提升， epoll 最大的优点就在于它<strong>只管你“活跃”的连接</strong> ，而跟连接总数无关，因此在实际的网络环境中， epoll 的效率就会远远高于 select 和 poll 。</li><li>内存拷贝， epoll 在这点上使用了“共享内存”，这个内存拷贝也省略了</li></ol><h3 id="redis-epoll底层实现"><a href="#redis-epoll底层实现" class="headerlink" title="redis epoll底层实现"></a>redis epoll底层实现</h3><p>​        当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关</p><p><strong>eventpoll结构体如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll｛</span><br><span class="line">.....</span><br><span class="line"><span class="comment">/*红黑树节点的根，存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">struct rb_root  rbt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*双链表中储存着将要通过epoll_wait返回给用户满足条件的事件*/</span></span><br><span class="line">struct list_head  rdlist;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>​        每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事<br>件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><p>​        而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>​        在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filedfd</span> <span class="title">ffd</span>;</span><span class="comment">//句柄事件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> ;</span><span class="comment">// 指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>;</span><span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户</p><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ol><li>不用重复传递。我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</li><li>在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。<br>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</li><li>极其高效的原因：<br>这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里<br>建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</li></ol><h4 id="这个准备就绪list链表是怎么维护的呢？"><a href="#这个准备就绪list链表是怎么维护的呢？" class="headerlink" title="这个准备就绪list链表是怎么维护的呢？"></a>这个准备就绪list链表是怎么维护的呢？</h4><p>​        当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个<br>socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。（注：好好理解这句话！）</p><p>​        从上面这句可以看出，epoll的基础就是回调呀！</p><p>​        如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p><p>​        最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。关于LT，ET，有一端描述，LT和ET都是电子里面的术语，ET是边缘触发，LT是水平触发，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。</p><p>​        LT, ET这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，<br>epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么Redis中要使用I-O多路复用呢？&quot;&gt;&lt;a href=&quot;#为什么Redis中要使用I-O多路复用呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么Redis中要使用I/O多路复用呢？&quot;&gt;&lt;/a&gt;为什么Redis中要使用I/O多路复用呢？&lt;/
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="Redis相关" scheme="https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>常见的IO模型</title>
    <link href="https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-28T09:35:29.000Z</published>
    <updated>2020-02-29T11:22:38.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高性能IO模型，常见的有四种："><a href="#高性能IO模型，常见的有四种：" class="headerlink" title="高性能IO模型，常见的有四种："></a>高性能IO模型，常见的有四种：</h3><p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p><p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p><p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p><p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</p><h3 id="IO模型举例理解1"><a href="#IO模型举例理解1" class="headerlink" title="IO模型举例理解1"></a>IO模型举例理解1</h3><ol><li><p>阻塞IO, 给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不<br> 会做其他事情, 属于备胎做法.</p></li><li><p>非阻塞IO, 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会<br> 做其他事情, 属于专一做法.</p></li><li><p>IO多路复用, 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便<br>看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么? 3.1 select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子 </p></li></ol><p>3.2 poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神</p><p>3.3 epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于同步等待状态</p><ol start="4"><li>接下来是异步IO的情况 你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了,女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口. 此时属于逆袭做法</li></ol><h3 id="IO模型举例理解2"><a href="#IO模型举例理解2" class="headerlink" title="IO模型举例理解2"></a>IO模型举例理解2</h3><p>1.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。</p><p>2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。</p><p>3.I/O复用模型</p><ul><li>select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次</li><li>epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</li></ul><p>4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</p><p>5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话</p><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>​        同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E4%B8%80%E8%88%ACIO.png" alt></p><ol><li>等待数据就绪（读就绪、写就绪）；</li><li>将数据从内核中拷贝到JVM进程中；</li><li>处理数据。</li></ol><p>​        <strong>整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够</strong></p><h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt></p><p>​        由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程<br>需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(socket, <span class="built_in">buffer</span>) != SUCCESS);</span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>​        IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt></p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png" alt></p><p>​         用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。 </p><p>​        从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p>​        但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p>​        用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>用户线程使用IO多路复用模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserEventHandler::handle_event() &#123;</span><br><span class="line">    <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">        process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">Reactor.register(<span class="keyword">new</span> UserEventHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的<br>EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reactor::handle_events() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">sockets = select();</span><br><span class="line"><span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">get_event_handler(socket).handle_event();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器<br>handle_event函数即可。<br>​        IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>​        “真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p><strong>异步IO模型使用了Proactor设计模式实现了这一机制。</strong></p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E5%BC%82%E6%AD%A5IO.png" alt></p><p>异步IO模型中，</p><ul><li>用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，</li><li>然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。</li><li>最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</li></ul><p>用户线程使用异步IO模型的伪代码描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UserCompletionHandler::handle_event</span><span class="params">(<span class="built_in">buffer</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">aio_read(socket, <span class="keyword">new</span> UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;高性能IO模型，常见的有四种：&quot;&gt;&lt;a href=&quot;#高性能IO模型，常见的有四种：&quot; class=&quot;headerlink&quot; title=&quot;高性能IO模型，常见的有四种：&quot;&gt;&lt;/a&gt;高性能IO模型，常见的有四种：&lt;/h3&gt;&lt;p&gt;（1）同步阻塞IO（Blocking
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>IO设计模式之Reactor和Proactor</title>
    <link href="https://liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/"/>
    <id>https://liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/</id>
    <published>2020-02-28T08:49:31.000Z</published>
    <updated>2020-02-28T09:45:04.562Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反应器Reactor"><a href="#反应器Reactor" class="headerlink" title="反应器Reactor"></a>反应器Reactor</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​    <strong>反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的</strong></p><p><strong>事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求，</strong></p><p><strong>然后派发这些请求至相关的工作线程进行处理。</strong></p><h3 id="Reactor模式主要包含下面几部分内容："><a href="#Reactor模式主要包含下面几部分内容：" class="headerlink" title="Reactor模式主要包含下面几部分内容："></a>Reactor模式主要包含下面几部分内容：</h3><ul><li>初始事件分发器(Initialization Dispatcher)：用于管理Event Handler，定义注册、移除EventHandler等。它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中handle_event(方法</li><li>同步（多路）事件分离器(Synchronous Event Demultiplexer)：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知初始事件分发器去调取特定的事件处理器。</li><li>系统处理程序(Handles)：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指SocketHandle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到SynchronousEvent Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。</li><li>事件处理器(Event Handler)： 定义事件处理方法，以供Initialization Dispatcher回调使用。</li></ul><h3 id="为什么使用Reactor模式"><a href="#为什么使用Reactor模式" class="headerlink" title="为什么使用Reactor模式"></a>为什么使用Reactor模式</h3><p>​        <strong>并发系统常使用reactor模式代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量</strong>。 例如：在高并发的情况下，既可以使用多处理处理方式，也可以使用Reactor处理方式。</p><h4 id="多线程的处理："><a href="#多线程的处理：" class="headerlink" title="多线程的处理："></a>多线程的处理：</h4><p>​        为每个单独到来的请求，专门启动一条线程，这样的话造成系统的开销很大，并且在单核的机上，多线程并不能提高系统的性能，除非在有一些阻塞的情况发生。否则线程切换的开销会使处理的速度变慢。</p><h4 id="Reactor模式的处理："><a href="#Reactor模式的处理：" class="headerlink" title="Reactor模式的处理："></a>Reactor模式的处理：</h4><p>​        服务器端启动一条单线程，用于轮询IO操作是否就绪，当有就绪的才进行相应的读写操作，这样的话就减少了服务器产生大量的线程，也不会出现线程之间的切换产生的性能消耗。(目前JAVA的NIO就采用的此种模式，这里引申出一个问题：在多核情况下NIO的扩展问题)</p><p>​        <strong>以上两种处理方式都是基于同步的，多线程的处理是我们传统模式下对高并发的处理方式，Reactor模式的处理是现今面对高并发和高性能一种主流的处理方式。</strong></p><h3 id="Reactor模式结构"><a href="#Reactor模式结构" class="headerlink" title="Reactor模式结构"></a>Reactor模式结构</h3><p><img src="/liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/Reactor.png" alt></p><h4 id="Reactor包含如下角色："><a href="#Reactor包含如下角色：" class="headerlink" title="Reactor包含如下角色："></a>Reactor包含如下角色：</h4><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</li><li>Event Handler：事件处理接口</li><li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li><li>Reactor：反应器，定义一个接口，实现以下功能： 1）供应用程序注册和删除关注的事件句柄； 2）运行事件循环； 3）有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li><li>Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法</li></ul><p><img src="/liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/Reactor2.png" alt></p><ol><li>应用启动，将关注的事件handle注册到Reactor中；</li><li>调用Reactor，进入无限事件循环，等待注册的事件到来；</li><li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</li></ol><h2 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h2><p>​        <strong>运用于异步I/O操作，Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.</strong><br>​        <strong>Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。</strong></p><h3 id="Proactor模式结构"><a href="#Proactor模式结构" class="headerlink" title="Proactor模式结构"></a>Proactor模式结构</h3><p><img src="/liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/Proactor.png" alt></p><h3 id="Proactor主动器模式包含如下角色"><a href="#Proactor主动器模式包含如下角色" class="headerlink" title="Proactor主动器模式包含如下角色"></a>Proactor主动器模式包含如下角色</h3><ul><li>Handle 句柄；用来标识socket连接或是打开文件；</li><li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li><li>Asynchronous Operation：异步操作</li><li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用</li><li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的<br>后续处理逻辑；</li><li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li><li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</li></ul><h3 id="业务流程及时序图"><a href="#业务流程及时序图" class="headerlink" title="业务流程及时序图"></a>业务流程及时序图</h3><p><img src="/liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/Proactor2.png" alt></p><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li><li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li><li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li><li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</li></ol><h2 id="对比两者的区别"><a href="#对比两者的区别" class="headerlink" title="对比两者的区别"></a>对比两者的区别</h2><h3 id="主动和被动"><a href="#主动和被动" class="headerlink" title="主动和被动"></a>主动和被动</h3><p>以主动写为例：</p><ul><li><p>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑；</p></li><li><p>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</p><p>可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；<br>Proactor直接调用异步读写操作，调用完后立刻返回； </p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应；</p><p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Reactor实现相对简单，对于耗时短的处理场景处理高效；<br>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；<br>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；<br>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来，</p><p>Proactor性能更高，能够处理耗时长的并发场景；</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理；</p><p>Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现；</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；<br>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p><p>开源产品如Redis、ACE，事件模型都使用的Reactor模式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;反应器Reactor&quot;&gt;&lt;a href=&quot;#反应器Reactor&quot; class=&quot;headerlink&quot; title=&quot;反应器Reactor&quot;&gt;&lt;/a&gt;反应器Reactor&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>同步IO、异步IO、阻塞IO、非阻塞IO</title>
    <link href="https://liudong-code.github.io/2020/02/28/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/"/>
    <id>https://liudong-code.github.io/2020/02/28/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/</id>
    <published>2020-02-28T08:43:03.000Z</published>
    <updated>2020-02-28T08:47:20.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h3><p>同步和异步是针对应用程序和内核的交互而言的，</p><ul><li>同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，</li><li>异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。</li></ul><p>指的是用户空间和内核空间数据交互的方式</p><p>​        同步：用户空间要的数据，必须等到内核空间给它才做其他事情</p><p>​        异步：用户空间要的数据，不需要等到内核空间给它，才做其他事情。内核空间会异步通知用户进程，并把</p><p>数据直接给到用户空间</p><h3 id="阻塞IO和非阻塞IO"><a href="#阻塞IO和非阻塞IO" class="headerlink" title="阻塞IO和非阻塞IO"></a>阻塞IO和非阻塞IO</h3><ul><li>阻塞方式下读取或者写入函数将一直等待，</li><li>非阻塞方式下，读取或者写入函数会立即返回一个状态值。</li></ul><p>指的是用户就和内核空间IO操作的方式</p><p>​        堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是堵塞的</p><p>​        非堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是不堵塞的，直接返回的，</p><p>只是返回时，可能没有数据而已</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;同步IO和异步IO&quot;&gt;&lt;a href=&quot;#同步IO和异步IO&quot; class=&quot;headerlink&quot; title=&quot;同步IO和异步IO&quot;&gt;&lt;/a&gt;同步IO和异步IO&lt;/h3&gt;&lt;p&gt;同步和异步是针对应用程序和内核的交互而言的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步指的是用
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Socket网络编程</title>
    <link href="https://liudong-code.github.io/2020/02/28/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://liudong-code.github.io/2020/02/28/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2020-02-28T08:29:54.000Z</published>
    <updated>2020-02-28T08:37:52.983Z</updated>
    
    <content type="html"><![CDATA[<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 要连接的服务端IP地址和端口</span></span><br><span class="line">String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line"><span class="comment">// 与服务端建立连接</span></span><br><span class="line">Socket socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line"><span class="comment">// 建立连接后获得输出流</span></span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">String message=<span class="string">"你好 yiwangzhibujian"</span>;</span><br><span class="line">socket.getOutputStream().write(message.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">outputStream.close();</span><br><span class="line">socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">"server将一直等待连接的到来"</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">            sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len,<span class="string">"UTF-8"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"get message from client: "</span> + sb);</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">"server将一直等待连接的到来"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            Socket socket = server.accept();</span><br><span class="line">            <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">                sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, <span class="string">"UTF-8"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"get message from client: "</span> + sb);</span><br><span class="line">            inputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">55533</span>;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">        <span class="comment">// server将一直等待连接的到来</span></span><br><span class="line">        System.out.println(<span class="string">"server将一直等待连接的到来"</span>);</span><br><span class="line">        <span class="comment">//如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;Socket socket = server.accept();</span><br><span class="line">            Runnable runnable=()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">                    InputStream inputStream = socket.getInputStream();</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    <span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8</span></span><br><span class="line">                        sb.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len, <span class="string">"UTF-8"</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"get message from client: "</span> + sb);</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            threadPool.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;客户端&quot;&gt;&lt;a href=&quot;#客户端&quot; class=&quot;headerlink&quot; title=&quot;客户端&quot;&gt;&lt;/a&gt;客户端&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>IO访问方式</title>
    <link href="https://liudong-code.github.io/2020/02/28/IO%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/02/28/IO%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-28T03:50:23.000Z</published>
    <updated>2020-02-28T08:27:25.684Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><p>​        当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从 缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。<br>​        当应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已 经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令。</p><h3 id="网络IO"><a href="#网络IO" class="headerlink" title="网络IO"></a>网络IO</h3><p>​    1）操作系统将数据从磁盘复制到操作系统内核的页缓存中</p><p>​    2）应用将数据从内核缓存复制到应用的缓存中 </p><p>​    3）应用 将数据写回内核的Socket缓存中</p><p>​    4）操作系统将数据从Socket缓存区复制到网卡缓存，然后将其通过网络发出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是图，图待补...</span><br></pre></td></tr></table></figure><p>1、当调用read系统调用时，通过DMA（Direct Memory Access）将数据copy到内核模式 </p><p>2、然后由CPU控制将内 核模式数据copy到用户模式下的 buffer中 </p><p>3、read调用完成后，write调用首先将用户模式下 buffer中的数据copy到内核模式下的socket buffer中 </p><p>4、最后通过DMA copy将内核模式下的socket buffer中的数据copy到网卡设备中传送。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ul><li>磁盘IO主要的延时是由（以15000rpm硬盘为例）： 机械转动延时（机械磁盘的主要性能瓶颈，平均为2ms） + 寻址延时（2~3ms） + 块传输延时（一般4k每块，40m/s的传输速度，延时一般为0.1ms) 决定。（平均为5ms）</li><li>网络IO主要延是由： 服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时 决定。（一般为几十到几千毫秒，受环境干扰极大）<br>所以两者一般来说网络IO延时要大于磁盘IO的延时。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;磁盘IO&quot;&gt;&lt;a href=&quot;#磁盘IO&quot; class=&quot;headerlink&quot; title=&quot;磁盘IO&quot;&gt;&lt;/a&gt;磁盘IO&lt;/h3&gt;&lt;p&gt;​        当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从 
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>缓存IO和直接IO</title>
    <link href="https://liudong-code.github.io/2020/02/28/%E7%BC%93%E5%AD%98IO%E5%92%8C%E7%9B%B4%E6%8E%A5IO/"/>
    <id>https://liudong-code.github.io/2020/02/28/%E7%BC%93%E5%AD%98IO%E5%92%8C%E7%9B%B4%E6%8E%A5IO/</id>
    <published>2020-02-28T02:21:56.000Z</published>
    <updated>2020-02-28T03:23:17.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>缓存IO：数据从磁盘通过DMA copy到内核空间，再从内核空间通过CPU copy到用户空间。</li><li>直接IO：数据从磁盘通过DMA copy到用户空间。</li></ul><h3 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h3><p>​        <strong>缓存I/O又被称作标准IO，大多数文件系统的默认操作都是缓存IO。在Linux的缓存IO机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。</strong></p><ul><li><p>读操作：</p><p>操作系统检查内核的缓冲区有没有西药的数据，如果已经缓存，那么直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。</p></li><li><p>写操作：</p><p>数据从用户空间复制到内核空间的缓存中，这时对用户程序来说写操作就已经完后才能，至于什么时候在写到磁盘中由操作系统决定，除非显示的调用了sync同步命令。–《【珍藏】linux 同步IO: sync、fsync与<br>fdatasync》。</p></li><li><p>缓存I/O的优点：</p><p>1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全；</p><p>2）可以减少读盘的次数，从而提高性能。</p></li><li><p>缓存I/O的缺点：</p><p>在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘</p><p>上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址</p><p>空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存</p><p>开销是非常大的。</p></li></ul><h3 id="直接IO"><a href="#直接IO" class="headerlink" title="直接IO"></a>直接IO</h3><p>​        <strong>直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区，自己管理IO缓冲区，这样做的目的是减少一次从内核缓冲区带用户程序缓存的数据复制。</strong></p><ul><li><p>直接IO的优点</p><p>​        应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序 缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。</p><p>​        引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓 冲区中，那么就不需要再次访问磁盘；而当进程需要向文件中写入数据时，实际上只是写到了内核缓冲区便告诉进程 已经写成功，而真正写入磁盘是通过一定的策略进行延迟的。</p><p>​        然而，对于一些较复杂的应用，比如数据库服务器，它们为了充分提高性能，希望绕过内核缓冲区，由自己在用户 态空间实现并管理I/O缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据更加 合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就 在使用系统内存。</p></li><li><p>直接IO的缺点</p><p>​        如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载 会非常缓慢。通常直接I/O跟异步I/O结合使用会得到较好的性能。</p></li></ul><p>​                   <img src="/liudong-code.github.io/2020/02/28/%E7%BC%93%E5%AD%98IO%E5%92%8C%E7%9B%B4%E6%8E%A5IO/IO.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;缓存IO：数据从磁盘通过DMA copy到内核空间，再从内核空间通过CPU copy到用户空间。&lt;/li&gt;
&lt;li&gt;直接IO：数
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>PIO和DMA</title>
    <link href="https://liudong-code.github.io/2020/02/28/PIO%E5%92%8CDMA/"/>
    <id>https://liudong-code.github.io/2020/02/28/PIO%E5%92%8CDMA/</id>
    <published>2020-02-28T02:09:06.000Z</published>
    <updated>2020-02-28T02:20:04.626Z</updated>
    
    <content type="html"><![CDATA[<h4 id="慢速IO设备和内存之间的数据传输方式有下面两种："><a href="#慢速IO设备和内存之间的数据传输方式有下面两种：" class="headerlink" title="慢速IO设备和内存之间的数据传输方式有下面两种："></a>慢速IO设备和内存之间的数据传输方式有下面两种：</h4><ul><li>PIO：磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们<strong>读取磁盘文件到内存中，数据要经过CPU储存转发，这种方式成为PIO</strong>。这种方式是不合理的，需要大量的CPU时间来读取文件，照成文件访问时系统几乎停止响应。</li><li>DMA：<strong>DMA（直接内存访问，Direct Memory Access），不经过CPU而直接进行磁盘和内存（内核空间）的数据交换</strong>。在DMA的模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据和传达即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异并不是十分明显，因为这主要取决于慢速设备的速度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;慢速IO设备和内存之间的数据传输方式有下面两种：&quot;&gt;&lt;a href=&quot;#慢速IO设备和内存之间的数据传输方式有下面两种：&quot; class=&quot;headerlink&quot; title=&quot;慢速IO设备和内存之间的数据传输方式有下面两种：&quot;&gt;&lt;/a&gt;慢速IO设备和内存之间的数据
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
