<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code</title>
  
  <subtitle>码总</subtitle>
  <link href="/liudong-code.github.io/atom.xml" rel="self"/>
  
  <link href="https://liudong-code.github.io/"/>
  <updated>2020-03-11T02:26:43.448Z</updated>
  <id>https://liudong-code.github.io/</id>
  
  <author>
    <name>Liu Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java多线程实现的四种方式</title>
    <link href="https://liudong-code.github.io/2020/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://liudong-code.github.io/2020/03/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-03-11T01:37:40.000Z</published>
    <updated>2020-03-11T02:26:43.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程实现的四种方式"><a href="#Java多线程实现的四种方式" class="headerlink" title="Java多线程实现的四种方式"></a>Java多线程实现的四种方式</h1><ul><li><strong>1.继承Thread类，重写run方法</strong></li><li><strong>2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target</strong></li><li><strong>3.通过Callable和FutureTask创建线程</strong></li><li><strong>4.通过线程池创建线程</strong></li></ul><p>前面两种可以归结为一类：无返回值，原因很简单，通过重写run方法，run方式的返回值是void，所以没有办法返回结果<br>后面两种可以归结成一类：有返回值，通过Callable接口，就要实现call方法，这个方法的返回值是Object，所以返回的结果可以放在Object对象中 </p><p> <strong>方式1：继承Thread类的线程实现方式如下：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo01</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写子类的构造方法，可缺省</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//编写自己的线程代码</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">        ThreadDemo01 threadDemo01 = <span class="keyword">new</span> ThreadDemo01(); </span><br><span class="line">        threadDemo01.setName(<span class="string">"我是自定义的线程1"</span>);</span><br><span class="line">        threadDemo01.start();       </span><br><span class="line">        System.out.println(Thread.currentThread().toString());  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">程序结果： </span><br><span class="line">Thread[main,<span class="number">5</span>,main] </span><br><span class="line">我是自定义的线程<span class="number">1</span></span><br></pre></td></tr></table></figure><p> <strong>线程实现方式2：</strong>通过实现Runnable接口，实现run方法，接口的实现类的实例作为Thread的target作为参数传入带参的Thread构造函数，通过调用start()方法启动线程 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread());</span><br><span class="line">    t1.start(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;我是通过实现接口的线程实现方式！"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">程序运行结果： </span><br><span class="line">main </span><br><span class="line">Thread-<span class="number">0</span>–&gt;我是通过实现接口的线程实现方式！</span><br></pre></td></tr></table></figure><p>  <strong>线程实现方式3</strong>：通过Callable和FutureTask创建线程  </p><p>a:创建Callable接口的实现类 ，并实现Call方法 </p><p>b:创建Callable实现类的实现，使用FutureTask类包装Callable对象，该FutureTask对象封装了Callable对象的Call方法的返回值 </p><p>c:使用FutureTask对象作为Thread对象的target创建并启动线程 </p><p>d:调用FutureTask对象的get()来获取子线程执行结束的返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">Callable&lt;Object&gt; oneCallable = <span class="keyword">new</span> Tickets&lt;Object&gt;();</span><br><span class="line">FutureTask&lt;Object&gt; oneTask = <span class="keyword">new</span> FutureTask&lt;Object&gt;(oneCallable);</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(oneTask);</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tickets</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写call方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">程序运行结果： </span><br><span class="line">main </span><br><span class="line">Thread-<span class="number">0</span>–&gt;我是通过实现Callable接口通过FutureTask包装器来实现的线程</span><br></pre></td></tr></table></figure><p> <strong>线程实现方式4</strong>：通过线程池创建线程 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo05</span></span>&#123; </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> POOL_NUM = <span class="number">10</span>;     <span class="comment">//线程池数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;POOL_NUM; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            RunnableThread thread = <span class="keyword">new</span> RunnableThread();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">            executorService.execute(thread);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        executorService.shutdown(); </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span>  </span></span><br><span class="line"><span class="class"></span>&#123;     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"通过线程池方式创建的线程："</span> + Thread.currentThread().getName() + <span class="string">" "</span>);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line">程序运行结果： </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">3</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">4</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">1</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">5</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">2</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">5</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">1</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">4</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">3</span> </span><br><span class="line">通过线程池方式创建的线程：pool-<span class="number">1</span>-thread-<span class="number">2</span></span><br></pre></td></tr></table></figure><p>ExecutorService、Callable都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，还有Future接口也是属于这个框架，有了这种特征得到返回值就很方便了。<br>通过分析可以知道，他同样也是实现了Callable接口，实现了Call方法，所以有返回值。这也就是正好符合了前面所说的两种分类</p><p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</p><p> <strong>Executors类</strong>：提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。 </p><ul><li>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。</li><li>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池，调用execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</li><li>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor。</li><li>public static ScheduledExecutorService newScheduledThreadPool(int<br>corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池，多数情况下可用来替代Timer类。</li><li>ExecutoreService提供了submit()方法，传递一个Callable，或Runnable，返回Future。如果Executor后台线程池还没有完成Callable的计算，这调用返回Future对象的get()方法，会阻塞直到计算完成。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程实现的四种方式&quot;&gt;&lt;a href=&quot;#Java多线程实现的四种方式&quot; class=&quot;headerlink&quot; title=&quot;Java多线程实现的四种方式&quot;&gt;&lt;/a&gt;Java多线程实现的四种方式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.继承Thre
      
    
    </summary>
    
    
    
      <category term="多线程" scheme="https://liudong-code.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收器</title>
    <link href="https://liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>https://liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</id>
    <published>2020-03-10T05:58:09.000Z</published>
    <updated>2020-03-10T06:10:24.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、垃圾收集器概述"><a href="#一、垃圾收集器概述" class="headerlink" title="一、垃圾收集器概述"></a>一、垃圾收集器概述</h1><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm.png" alt></p><p>如上图所示，垃圾回收算法一共有7个，3个属于年轻代、三个属于年老代，G1属于横跨年轻代和年老代的算法。</p><p>JVM会从年轻代和年老代各选出一个算法进行组合，连线表示哪些算法可以组合使用</p><h1 id="二、各个垃圾收集器说明"><a href="#二、各个垃圾收集器说明" class="headerlink" title="二、各个垃圾收集器说明"></a>二、各个垃圾收集器说明</h1><h2 id="1、Serial-年轻代）"><a href="#1、Serial-年轻代）" class="headerlink" title="1、Serial(年轻代）"></a>1、Serial(年轻代）</h2><ol><li>年轻代收集器，可以和Serial Old、CMS组合使用</li><li>采用复制算法</li><li>使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止</li><li>client模式年轻代默认算法</li><li>GC日志关键字：DefNew(Default New Generation)</li><li>图示（Serial+Serial Old)</li></ol><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm1.png" alt></p><h2 id="2、ParNew-年轻代）"><a href="#2、ParNew-年轻代）" class="headerlink" title="2、ParNew(年轻代）"></a>2、ParNew(年轻代）</h2><ol><li><p>新生代收集器，可以和Serial Old、CMS组合使用</p></li><li><p>采用复制算法</p></li><li><p>使用多线程进行垃圾回收，回收时会导致Stop The World，其它策略和Serial一样</p></li><li><p>server模式年轻代默认算法</p></li><li><p>使用-XX:ParallelGCthreads参数来限制垃圾回收的线程数</p></li><li><p>GC日志关键字：ParNew(Parallel New Generation)</p></li><li><p>图示（ParNew + Serail Old）</p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm2.png" alt></p></li></ol><h2 id="3、Paralle-Scavenge-年轻代）"><a href="#3、Paralle-Scavenge-年轻代）" class="headerlink" title="3、Paralle Scavenge(年轻代）"></a>3、Paralle Scavenge(年轻代）</h2><ol><li><p>新生代收集器，可以和Serial Old、Parallel组合使用，不能和CMS组合使用</p></li><li><p>采用复制算法</p></li><li><p>使用多线程进行垃圾回收，回收时会导致Stop The World</p></li><li><p>关注系统</p><p>吞吐量</p><ol><li>-XX:MaxGCPauseMillis：设置大于0的毫秒数，收集器尽可能在该时间内完成垃圾回收</li><li>-XX:GCTimeRatio：大于0小于100的整数，即垃圾回收时间占总时间的比率，设置越小则希望垃圾回收所占时间越小，CPU能花更多的时间进行系统操作，提高吞吐量</li><li>-XX:UseAdaptiveSizePolicy：参数开关，启动后系统动态自适应调节各参数，如-Xmn、-XX：SurvivorRatio等参数，这是和ParNew收集器重要的区别</li></ol></li><li><p>GC日志关键字：PSYoungGen</p></li></ol><h2 id="4、Serial-Old-年老代）"><a href="#4、Serial-Old-年老代）" class="headerlink" title="4、Serial Old(年老代）"></a>4、Serial Old(年老代）</h2><ol><li>年老代收集器，可以和所有的年轻代收集器组合使用(Serial收集器的年老代版本）</li><li>采用 ”标记-整理“算法，会对垃圾回收导致的内存碎片进行整理</li><li>使用单线程进行垃圾回收，回收时会导致Stop The World，用户进程停止</li><li>GC日志关键字：Tenured</li><li>图示（Serial+Serial Old)</li></ol><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm3.png" alt></p><h2 id="5、Parallel-Old-年老代）"><a href="#5、Parallel-Old-年老代）" class="headerlink" title="5、Parallel Old(年老代）"></a>5、Parallel Old(年老代）</h2><ol><li>老年代收集器，只能和Parallel Scavenge组合使用(Parallel Scavenge收集器的老年代版本）</li><li>采用 ”标记-整理“算法，会对垃圾回收导致的内存碎片进行整理</li><li>关注吞吐量的系统可以将Parallel Scavenge+Parallel Old组合使用</li><li>GC日志关键字：ParOldGen</li><li>图示(Parallel Scavenge+Parallel Old)</li></ol><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm4.png" alt></p><h2 id="6、CMS-Concurrent-Mark-Sweep年老代）"><a href="#6、CMS-Concurrent-Mark-Sweep年老代）" class="headerlink" title="6、CMS(Concurrent Mark Sweep年老代）"></a>6、CMS(Concurrent Mark Sweep年老代）</h2><ol><li><p>年老代收集器，可以和Serial、ParNew组合使用</p></li><li><p>采用 ”标记-清除“算法，可以通过设置参数在垃圾回收时进行内存碎片的整理<br>1、UserCMSCompactAtFullCollection：默认开启，FullGC时进行内存碎片整理，整理时用户进程需停止，即发生Stop The World<br>2、CMSFullGCsBeforeCompaction：设置执行多少次不压缩的Full GC后，执行一个带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）</p></li><li><p>CMS是并发算法，表示垃圾回收和用户进行同时进行，但是不是所有阶段都同时进行，在初始标记、重新标记阶段还是需要Stop the World。CMS垃圾回收分这四个阶段<br>1、初始标记（CMS Initial mark）   Stop the World  仅仅标记一下GC Roots能直接关联到的对象，速度快<br>2、并发标记（CMS concurrent mark） 进行GC Roots Tracing，时间长，不发生用户进程停顿<br>3、重新标记（CMS remark）      Stop the World  修正并发标记期间因用户程序继续运行导致标记变动的那一部分对象的标记记录，停顿时间较长，但远比并发标记时间短<br>4、并发清除（CMS concurrent sweep） 清除的同时用户进程会导致新的垃圾，时间长，不发生用户进程停顿</p></li><li><p>适合于对响应时间要求高的系统</p></li><li><p>GC日志关键字：CMS-initial-mark、CMS-concurrent-mark-start、CMS-concurrent-mark、CMS-concurrent-preclean-start、CMS-concurrent-preclean、CMS-concurrent-sweep、CMS-concurrent-reset等等</p></li><li><p>缺点</p><p><strong>CMS收集器对CPU资源非常敏感</strong></p><p> 其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。<br> CMS默认启动的回收线程数是（CPU数量+3）/ 4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大。</p><p><strong>CMS收集器无法处理浮动垃圾</strong></p><p> CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</p><p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。<br> 也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p><strong>CMS收集器会产生大量空间碎片</strong></p><p> CMS是一款基于“标记—清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。</p><p>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。</p></li></ol><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm5.png" alt></p><h2 id="7、G1收集器"><a href="#7、G1收集器" class="headerlink" title="7、G1收集器"></a>7、G1收集器</h2><p><img src="/liudong-code.github.io/2020/03/10/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/jvm6.png" alt></p><h3 id="特性："><a href="#特性：" class="headerlink" title="特性："></a><strong>特性：</strong></h3><p> G1（Garbage-First）是一款面向<strong>服务端应用</strong>的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。</p><ul><li><strong>并行与并发</strong><br> G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong><br> 与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong><br> 与CMS的“标记—清理”算法不同，G1从<strong>整体来看是基于“标记—整理”</strong>算法实现的收集器，从<strong>局部（两个Region之间）上来看是基于“复制”</strong>算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong><br> 这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><h3 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h3><p> G1收集器的运作大致可划分为以下几个步骤：</p><ul><li><strong>初始标记（Initial Marking）</strong><br> 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li><strong>并发标记（Concurrent Marking）</strong><br> 并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记（Final Marking）</strong><br> 最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程<code>Remembered Set Logs</code>里面，最终标记阶段需要把<code>Remembered Set Logs</code>的数据合并到<code>Remembered Set</code>中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收（Live Data Counting and Evacuation）</strong><br> 筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li></ul><p>参考简书：<a href="https://www.jianshu.com/p/50d5c88b272d" target="_blank" rel="noopener">https://www.jianshu.com/p/50d5c88b272d</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、垃圾收集器概述&quot;&gt;&lt;a href=&quot;#一、垃圾收集器概述&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾收集器概述&quot;&gt;&lt;/a&gt;一、垃圾收集器概述&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/liudong-code.github.io/2020/03/
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://liudong-code.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM虚拟机</title>
    <link href="https://liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2020-03-10T02:42:35.000Z</published>
    <updated>2020-03-10T05:50:43.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p> JVM是Java Virtual Machine（Java虚拟机）的缩写，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 </p><p> 有两个概念和JVM息息相关并且很容易搞混，那就是JRE和JDK。 </p><ul><li>JRE(JavaRuntimeEnvironment，Java运行环境)，指的是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户运行已开发好的java程序，只要安装JRE即可。 </li><li>JDK(JavaDevelopmentKit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。 </li></ul><p>为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。而JVM是JRE的一部分。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p><p> 下面这张图是java程序的一个总执行流程： </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM1.png" alt></p><h1 id="二、类加载机制"><a href="#二、类加载机制" class="headerlink" title="二、类加载机制"></a>二、类加载机制</h1><p> 从上图可以看到，我们写的源程序通过编译后生成的class文件，在运行的时候首先会通过类加载器系统。这边来简要说一下类加载机制。 </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM2.png" alt></p><p> 上面是一个类从最初加载到最后卸载的整个流程。我们对其中几个过程进行梳理。 </p><h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>加载过程是将class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。这个过程需要类加载器参与。</p><h2 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h2><p>链接是将java类的二进制代码合并到JVM的运行状态之中的过程。可以再细分为如下3步：</p><p><strong>① 验证</strong>：确保加载的类信息符合JVM规范，没有安全方面的问题。</p><p><strong>② 准备</strong>：正式为变量(static)分配内存并设置类变量默认值，这些内存都将在方法区中进行分配。</p><p><strong>③ 解析</strong>：虚拟机常量池内的符号引用替换为直接引用的过程。</p><h2 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h2><p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static块）中的语句合并产生的。</clinit></clinit></p><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁同步。</clinit></p><p>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</p><p> 下面是一个例子： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"运行main"</span>);</span><br><span class="line"></span><br><span class="line">            A testa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"a:"</span>+testa.a);</span><br><span class="line"></span><br><span class="line">            testa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"初始化A静态块"</span>);</span><br><span class="line"></span><br><span class="line">            a = <span class="number">300</span>；</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"创建A对象"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行main</span><br><span class="line"></span><br><span class="line">初始化A静态块</span><br><span class="line"></span><br><span class="line">创建A对象</span><br><span class="line"></span><br><span class="line">a:<span class="number">300</span></span><br><span class="line"></span><br><span class="line">创建A对象</span><br></pre></td></tr></table></figure><p> 从上面可以看出，如果类还没加载进来，会先加载类，并初始化static，其中static 加载顺序是在代码中从上到下的顺序来执行的。 </p><h3 id="2-3-1-类的主动引用"><a href="#2-3-1-类的主动引用" class="headerlink" title="2.3.1 类的主动引用"></a>2.3.1 类的主动引用</h3><p>对于类的主动引用操作，则一定会发生类的初始化。下面罗列了一些类的主动引用：</p><p>① New一个类的对象。</p><p>② 调用类的静态成员（除了final常量）和静态方法。</p><p>③ 使用java.lang.reflect包的方法对类进行反射调用。</p><p>④ 当虚拟机启动，java 会先启动main方法所在的类。</p><p>⑤ 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。</p><h3 id="2-3-2-类的被动引用"><a href="#2-3-2-类的被动引用" class="headerlink" title="2.3.2 类的被动引用"></a>2.3.2 类的被动引用</h3><p>① 当访问一个静态域时，只有真正声明这个域的类才会被初始化，通过子类引用父类的静态变量，不会导致子类初始化。</p><p>② 通过数组定义类引用，不会触发此类的初始化。</p><p>③ 引用常量不会触发此类的初始化。</p><h2 id="2-4-类加载器"><a href="#2-4-类加载器" class="headerlink" title="2.4 类加载器"></a>2.4 类加载器</h2><p>加载类必然离不开类加载器，类加载器是将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class 对象，作为方法区的访问入口。</p><p> 关于类加载有一个很有名的机制——双亲委托机制： （后续的博客仔细做讨论）</p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM3.png" alt></p><p> 这个机制采用代理模式，某个特定的类加载器在接到加载类的请求时，先将代理任务传到最高一辈，加载不了再逐级往下传，直到能加载。 </p><p> 这个机制的作用是为了保证Java核心库的类型安全。比如说如果用户自定义了一个String类，在该机制下，类加载器还是会去加载系统自带的String类，而不是加载用户自定义的这个String类。 </p><h1 id="三、JVM运行时数据区"><a href="#三、JVM运行时数据区" class="headerlink" title="三、JVM运行时数据区"></a>三、JVM运行时数据区</h1><p> 讲完类加载系统，来说一下JVM的运行时数据区，先看如下图： </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM4.png" alt></p><p> 运行的程序是内容是放在运行时数据区中的，如上图蓝色那块依次来说明一下： </p><h2 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1 堆"></a>3.1 堆</h2><p> 保存所有引用数据类型的真实信息（线程共享）。也就是说那些new出来的对象都是放在这块区域的。 </p><h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2 虚拟机栈"></a>3.2 虚拟机栈</h2><p> 基本数据、运算、指向堆内存的引用（线程私有）。 </p><p>在栈里面是由一个个栈帧组成的，每个正在执行的方法对应一个栈帧。</p><p>当一个方法运行到一半需要调用另一个方法时，就创建一个新的栈帧表示新调用的方法，将原来那个方法压入栈中。</p><p>当方法运行完毕，栈帧出栈，原来方法处于栈顶接着运行。</p><p>和栈这一数据结构一样，虚拟机栈里面的栈帧遵循后进先出的原则。</p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM5.png" alt></p><p> 常见的一个错误栈溢出 StackOverflowError 就是由于方法递归层数太多，导致栈空间满了。看如下一个例子: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        fun();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        fun();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面fun()函数无限递归调用自己，最终会造成栈溢出： </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM6.png" alt></p><h2 id="3-3-方法区"><a href="#3-3-方法区" class="headerlink" title="3.3 方法区"></a>3.3 方法区</h2><p>又叫静态区，跟堆一样，被所有的线程共享。</p><p>方法区包含所有的class和static变量。方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p><p>同时方法区里面还有一个叫常量池的地方，String的字符串等常量存储就存储在那边。</p><h2 id="3-4-程序计数器"><a href="#3-4-程序计数器" class="headerlink" title="3.4 程序计数器"></a>3.4 程序计数器</h2><p> 一个非常小的内存空间，用来保存程序执行到的位置（线程私有）。下面是一个程序计数器的演示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        str.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序会报空指针异常，如下图，在报的这个异常中，有一行日志 at TestDemo,main(TestDemo.java:4)  代表程序运行到TestDemo 中main()函数第四行的时候发生的错误，就是通过程序计数器来记录这个程序运行的位置的。</p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM7.png" alt></p><h2 id="3-5-本地方法栈"><a href="#3-5-本地方法栈" class="headerlink" title="3.5 本地方法栈"></a>3.5 本地方法栈</h2><p> 和虚拟机栈类似，不过本地方法栈里面运行的方法不是用java写的，一般是用c或c++写的方法，也有类似栈帧的的概念。 </p><h1 id="四、内存模型和垃圾回收"><a href="#四、内存模型和垃圾回收" class="headerlink" title="四、内存模型和垃圾回收"></a>四、内存模型和垃圾回收</h1><h2 id="4-1-内存模型"><a href="#4-1-内存模型" class="headerlink" title="4.1 内存模型"></a>4.1 内存模型</h2><p> JVM对于运行时对于共享数据的部分，即堆和方法区做了一个内存划分的规范。以JDK1.8为分界线，稍微有些不同，先看如下图： </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM8.png" alt></p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM9.png" alt></p><p>两者变化不大，只是将永久带变成了元空间。</p><p><strong>一般来说新生代和老年代对应着上一节所讲的堆部分，而永久带或者元空间对应着上一节所说方法区。</strong></p><p>这边的内存模型和上一节里面的JVM运行时数据区，可以理解为从不同的角度阐述了同一个物理实物。 </p><h3 id="4-1-1-年轻代"><a href="#4-1-1-年轻代" class="headerlink" title="4.1.1 年轻代"></a>4.1.1 年轻代</h3><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生  命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><h3 id="4-1-2-老年代"><a href="#4-1-2-老年代" class="headerlink" title="4.1.2 老年代"></a>4.1.2 老年代</h3><p> 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 </p><h3 id="4-1-3-永久带"><a href="#4-1-3-永久带" class="headerlink" title="4.1.3 永久带"></a>4.1.3 永久带</h3><p> 用于存放静态文件，如Java类、方法等。永久带对垃圾回收没有显著影响，一般不做垃圾回收，在JVM内存中划分空间。 </p><h3 id="4-1-4-元空间"><a href="#4-1-4-元空间" class="headerlink" title="4.1.4 元空间"></a>4.1.4 元空间</h3><p> 类似于永久带，不过它是直接使用物理内存而不占用JVM堆内存。 </p><h2 id="4-2-垃圾回收机制"><a href="#4-2-垃圾回收机制" class="headerlink" title="4.2 垃圾回收机制"></a>4.2 垃圾回收机制</h2><p> 垃圾回收是JVM中非常重要的部分，也正是由于这一机制的存在，使得Java语言不用像c++一样需要开发者自己去释放内存。而是通过垃圾回收器GC来进行内存的回收释放，下面来看下这个流程是怎么样的： </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM10.png" alt></p><p> GC主要处理的是年轻代与老年代的内存清理操作，元空间,永久代一般很少用GC。整个流程图如上图所示总的来说如下流程： </p><p> ① 当一个新对象产生，需要内存空间，为该对象进行内存空间申请。 </p><p> ② 首先判断伊甸园区是否有有内存空间，有的话直接将新对象保存在伊甸园区。 </p><p> ③ 如果此时伊甸园区内存空间不足，会自动触发MinorGC，将伊甸园区不用的内存空间进行清理，清理之后判断伊甸园区内存空间是否充足，充足的话在伊甸园区分配内存空间。 </p><p> ⑤ 如果此时存活区也没空间了，继续判断老年区，如果老年区空间充足，则将存活区中活跃对象保存到老年代，而后存活区有空余空间，随后伊甸园区将活跃对象保存在存活区之中，在伊甸园区为新对象开辟空间。 </p><p> ⑥ 如果老年代满了，此时将产生MajorGC进行老年代内存清理，进行完全垃圾回收。 </p><p> ⑦ 如果老年代执行MajorGC发现依然无法进行对象保存，此时会进行OOM异常（OutOfMemoryError）。 </p><p> 上面流程就是整个垃圾回收机制流程，总的来说，新创建的对象一般都会在伊甸园区生成，除非这个创建对象太大，那有可能直接在老年区生成。 </p><h3 id="4-3-垃圾回收算法"><a href="#4-3-垃圾回收算法" class="headerlink" title="4.3 垃圾回收算法"></a>4.3 垃圾回收算法</h3><h4 id="4-3-1-BTP和TLAB算法"><a href="#4-3-1-BTP和TLAB算法" class="headerlink" title="4.3.1 BTP和TLAB算法"></a>4.3.1 BTP和TLAB算法</h4><p> <strong>① BTP</strong>:Bump-the-Pointer,该算法的主要特点是跟踪在Eden区保存的最后一个对象，类似栈的形式，每次创建新空间时只要判断最后保存的对象是否有足够空间，可极大提高内存分配速度。 </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM11.png" alt></p><p> <strong>② TLAB</strong>：Thread-Local Allocation Buffers BTP不适合多线程，TLAB将Eden区分为多个数据块，每个数据块分别采用BTP进行分配。 </p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM12.png" alt></p><p>这两种算法都在伊甸园区使用，他们的优点在于速度快，由于伊甸园区里面的对象往往是小往往立刻就回收的，很适合这种算法。但这种算法有一个缺点就是当对象回收后会产生许多碎片。对于这个问题就需要下面一种算法来进行弥补了。</p><h3 id="4-3-2-复制算法"><a href="#4-3-2-复制算法" class="headerlink" title="4.3.2 复制算法"></a>4.3.2 复制算法</h3><p>这个算法在新生代的GC中使用，从根集合扫描出存活对象，并将找到的存活对象复制到一块空的空间中，然后清空伊甸园和前面一块有对象的存活区，这块清空的存活区就变成了空的空间供下次复制。这个算法的优点是能整合出大块连续的空间，缺点就是需要有一块空空间来存放复制后的对象，相对来说比较浪费空间。所以这个算法在存活区中使用，存活区也是相对来说最小的一块区域，两个存活区必定有一个区域是空的。</p><h3 id="4-3-2-标记压缩算法"><a href="#4-3-2-标记压缩算法" class="headerlink" title="4.3.2 标记压缩算法"></a>4.3.2 标记压缩算法</h3><p>改算法是老年代里面所采用的垃圾回收算法，采用的方式为从根集合开始扫描，对存活的对象进行标记，标记完毕后，回收不存活对象所占用的内存空间并且会将其他所存活对象都往左端空闲空间进行移动，并更新引用其对象的指针。这个算法不会产生碎片，也不需要存在一块空的空间，而其缺点就是速度慢。所以比较适合回收频率相对较低的老年区。</p><p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM14.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h1&gt;&lt;p&gt; JVM是Java Virtual Machine（Java虚拟机）的缩写，是一种用于计算设备的规范，它是一个虚构出来的计算
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://liudong-code.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySql数据库</title>
    <link href="https://liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-03-07T03:06:15.000Z</published>
    <updated>2020-03-07T15:10:50.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据库隔离级别（详见七）"><a href="#一、数据库隔离级别（详见七）" class="headerlink" title="一、数据库隔离级别（详见七）"></a>一、数据库隔离级别（详见七）</h2><p>四种隔离级别（SQL92标准）：<br>现在来看看MySQL数据库为我们提供的四种隔离级别（由低到高）：</p><p>① Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><p>② Read committed (RC，读已提交)：可避免脏读的发生。</p><p>③ Repeatable read (RR，可重复读)：可避免脏读、不可重复读的发生。</p><p>（注意事项：InnoDB的RR还可以解决幻读，主要原因是Next-Key锁，只有RR才能使用Next-Key锁）</p><p>④ Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>（由MVCC降级为Locking-Base CC）</p><h2 id="二、MYSQL有哪些存储引擎，各自优缺点"><a href="#二、MYSQL有哪些存储引擎，各自优缺点" class="headerlink" title="二、MYSQL有哪些存储引擎，各自优缺点"></a>二、MYSQL有哪些存储引擎，各自优缺点</h2><table><thead><tr><th>MyISAM</th><th>高速引擎，拥有较高的插入，查询速度，但不支持事务、不支持行锁、支持3种不同的存储格式。包括静态型、动态型和压缩型。</th></tr></thead><tbody><tr><td><strong>InnoDB</strong></td><td><strong>5.5版本后MySQL的默认数据库，支持事务和行级锁定，事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，比MyISAM处理速度稍慢、支持外键（FOREIGN KEY）</strong></td></tr><tr><td>ISAM</td><td>MyISAM的前身，MySQL5.0以后不再默认安装</td></tr><tr><td>MRG_MyISAM（MERGE）</td><td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td></tr><tr><td><strong>Memory</strong></td><td><strong>内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失</strong></td></tr><tr><td>Falcon</td><td>一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者</td></tr><tr><td>Archive</td><td>将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作</td></tr><tr><td>CSV</td><td>存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)</td></tr></tbody></table><p><strong>存储引擎的选型：</strong><br><strong>InnoDB</strong>：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p><p><strong>MyISAM</strong>：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p><p><strong>MEMORY</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，不需要持久保存，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p><p><strong>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</strong></p><h2 id="三、高并发下，如何做到安全的修改同一行数据"><a href="#三、高并发下，如何做到安全的修改同一行数据" class="headerlink" title="三、高并发下，如何做到安全的修改同一行数据"></a>三、高并发下，如何做到安全的修改同一行数据</h2><h3 id="1、使用悲观锁"><a href="#1、使用悲观锁" class="headerlink" title="1、使用悲观锁"></a>1、使用悲观锁</h3><p>悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。</p><h3 id="2、FIFO（First-Input-First-Output，先进先出）缓存队列思路"><a href="#2、FIFO（First-Input-First-Output，先进先出）缓存队列思路" class="headerlink" title="2、FIFO（First Input First Output，先进先出）缓存队列思路"></a><strong>2、FIFO（First Input First Output，先进先出）缓存队列思路</strong></h3><p>直接将请求放入队列中，就不会导致某些请求永远获取不到锁。</p><h3 id="3、使用乐观锁"><a href="#3、使用乐观锁" class="headerlink" title="3、使用乐观锁"></a><strong>3、使用乐观锁</strong></h3><p>这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。</p><h3 id="4、Zookeeper-锁"><a href="#4、Zookeeper-锁" class="headerlink" title="4、Zookeeper 锁"></a>4、Zookeeper 锁</h3><p> 基于异常的分布式锁（基于临时节点）<br>创建不带序号的节点， 创建成功获得锁， 创建不成功， 会抛出异常， 监听lock 节点， 当lock 删除时，再重新去创建节点 </p><h2 id="四、SQL执行计划"><a href="#四、SQL执行计划" class="headerlink" title="四、SQL执行计划"></a>四、SQL执行计划</h2><h3 id="一、执行计划是什么？"><a href="#一、执行计划是什么？" class="headerlink" title="一、执行计划是什么？"></a>一、执行计划是什么？</h3><p> 执行计划，简单的来说，是SQL在数据库中执行时的表现情况,通常用于SQL性能分析,优化等场景。在MySQL中使用 explain 关键字来查看 </p><h3 id="二、查看执行计划"><a href="#二、查看执行计划" class="headerlink" title="二、查看执行计划"></a>二、查看执行计划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN + sql语句</span><br></pre></td></tr></table></figure><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql.png" alt></p><h3 id="三、MySQL执行计划分析"><a href="#三、MySQL执行计划分析" class="headerlink" title="三、MySQL执行计划分析"></a>三、MySQL执行计划分析</h3><ul><li>sql如何使用索引</li><li>联接查询的执行顺序</li><li>查询扫描的数据行数</li></ul><h3 id="四、各个字段的含义"><a href="#四、各个字段的含义" class="headerlink" title="四、各个字段的含义"></a>四、各个字段的含义</h3><p><strong>ID</strong></p><ul><li>id列中的数据为一组数字，表示执行select语句顺序</li><li>id值相同时，执行顺序由上至下</li><li>id值越大优先级越高，越先被执行</li></ul><p><strong>SELECT_TYPE</strong></p><p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询。</p><ul><li>SIMPLE：简单的select查询，查询中不包含子查询或者union</li><li>PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary</li><li>SUBQUERY：在select 或 where列表中包含了子查询</li><li>DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql会递归执行这些子查询，把结果放在临时表里</li><li>UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived</li><li>UNION RESULT：从union表获取结果的select</li><li>DEPENDENT SUBQUERY: 依赖外部结果的子查询</li><li>DEPENDENT UNION: 当union作为子查询时，第二或是第二个后的查询的 select_type值<br> /article/details/91349161</li></ul><p><strong>TABLE</strong></p><ul><li>输出数据行所在的表的名称</li><li>如果不涉及对数据表的操作，那么这显示为null</li><li>如果显示为尖括号括起来的就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于<br>这个查询产生。</li><li>&lt; unionM,N&gt;由ID为M,N查询union产生的结果集</li><li>&lt; derivedN&gt;/&lt; subqueryN&gt; 由Id为n的查询产生的结果</li></ul><p><strong>PARTITIONS</strong></p><ul><li>对于分区表，显示查询的分区ID</li><li>对于非分区表，显示的为 NULL</li></ul><p><strong>TYPE</strong></p><p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p><strong>system</strong> 这是const联接类型的一个特例，当查询的表只有一行时使用</p><p><strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const</p><p><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p><p><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p><p><strong>ref_or_null</strong> 类似于 ref类型的查询，但是附加了对 null 值列的查询</p><p><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了between、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p><p><strong>index：Full</strong> Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p><p><strong>ALL：Full</strong> Table Scan，遍历全表以找到匹配的行</p><p><strong>index</strong>：关键字：条件是出现在索引树中的节点的。可能没有完全匹配索引</p><p>索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可<br>以使用索引排序或者分组的查询。</p><p><strong>POSSIBLE_KEYS</strong></p><ul><li>指出mysql能使用哪些索引来优化查询</li><li>查询列所涉及的列上的索引都会被列出来，但不一定会被使用</li></ul><p><strong>KEY</strong></p><ul><li>实际使用的索引，如果为NULL，则没有使用索引。</li><li>查询中如果使用了覆盖索引，则该索引仅出现在key列表中。</li></ul><p><strong>REF</strong></p><ul><li>如果是使用的常数等值查询，这里会显示const</li><li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li><li>如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</li></ul><p><strong>ROWS</strong></p><ul><li>表示msql通过索引的统计信息，估算的所需读取的行数</li><li>rows值的大小时个统计抽样的结果，并不十分的准确</li></ul><p><strong>extra（重要）</strong></p><p>distinct ：在select部分使用了distinct关键字</p><p>no tables used：不带from字句的查询或者From dual查询</p><p>使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p><p>using filesort（重要）</p><ul><li>​    排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</li><li>​    说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li><li>​    MySQL中无法利用索引完成的排序操作称为“文件排序”</li></ul><p>using index（重要）</p><p>查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p><p>​        表示相应的SELECT查询中使用到了覆盖索引（Covering Index），避免访问表的数据行，效率不错！<br>​        如果同时出现Using Where ，说明索引被用来执行查找索引键值<br>​        如果没有同时出现Using Where ，表明索引用来读取数据而非执行查找动作。</p><p>using temporary</p><p>​    表示使用了临时表存储中间结果。<br>​    MySQL在对查询结果order by和group by时使用临时表<br>​    临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p><p>using where（重要）</p><ul><li>表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</li><li>查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了</li></ul><h2 id="五、MySQL索引"><a href="#五、MySQL索引" class="headerlink" title="五、MySQL索引"></a>五、MySQL索引</h2><h3 id="a-索引是什么"><a href="#a-索引是什么" class="headerlink" title="a.索引是什么"></a>a.索引是什么</h3><p>​        官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目<br>录，能加快数据库的查询速度。</p><h3 id="b-索引的优势和劣势"><a href="#b-索引的优势和劣势" class="headerlink" title="b.索引的优势和劣势"></a>b.索引的优势和劣势</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。 – 检索</p><p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。 –排序</p><ul><li>被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。</li><li>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</li><li>where 索引列 在存储引擎层 处理</li><li>覆盖索引 select 字段 字段是索引</li></ul><h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><p>索引会占据磁盘空间</p><p><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件</p><h3 id="c-索引的分类"><a href="#c-索引的分类" class="headerlink" title="c.索引的分类"></a>c.索引的分类</h3><p>​    单列索引<br>​    组合索引 *<br>​    全文索引<br>​    空间索引<br>​    位图索引 Oracle</p><h3 id="d-索引的使用"><a href="#d-索引的使用" class="headerlink" title="d.索引的使用"></a>d.索引的使用</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="单列索引之普通索引"><a href="#单列索引之普通索引" class="headerlink" title="单列索引之普通索引"></a>单列索引之普通索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br></pre></td></tr></table></figure><h5 id="单列索引之唯一索引"><a href="#单列索引之唯一索引" class="headerlink" title="单列索引之唯一索引"></a>单列索引之唯一索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name(<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure><h5 id="单列索引之全文索引"><a href="#单列索引之全文索引" class="headerlink" title="单列索引之全文索引"></a>单列索引之全文索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> fulltext index_name(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><h5 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> article <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_titme_time (title(<span class="number">50</span>),<span class="built_in">time</span>(<span class="number">10</span>)) ;</span><br></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name \G</span><br></pre></td></tr></table></figure><h3 id="e-索引原理分析"><a href="#e-索引原理分析" class="headerlink" title="e.索引原理分析"></a>e.索引原理分析</h3><h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><ul><li>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引</li><li>MyISAM和InnoDB存储引擎：只支持B+ TREE索引， 也就是说默认使用BTREE，不能够更换</li><li>MEMORY/HEAP存储引擎：支持HASH和BTREE索引</li></ul><p>B树和B+树<br>数据结构示例网站：<br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><h4 id="B树图示"><a href="#B树图示" class="headerlink" title="B树图示"></a>B树图示</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个<br>分支，即多叉）平衡查找树。 多叉平衡</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql2.png" alt></p><p>B树的高度一般都是在2-4这个高度，树的高度直接影响IO读写的次数。</p><p>如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T</p><h4 id="B和B-的区别"><a href="#B和B-的区别" class="headerlink" title="B和B+的区别"></a>B和B+的区别</h4><p>​    B树和B+树的最大区别在于非叶子节点是否存储数据的问题。</p><p>​    B树是非叶子节点和叶子节点都会存储数据。</p><p>​    B+树只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是有指针指向的，也就是有顺序的。</p><h4 id="非聚集索引（MyISAM）"><a href="#非聚集索引（MyISAM）" class="headerlink" title="非聚集索引（MyISAM）"></a>非聚集索引（MyISAM）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql3.png" alt></p><p>叶子节点下面保存的是数据的地址，再由地址去找到真正的数据</p><h5 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h5><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql4.png" alt></p><h4 id="聚集索引（InnoDB）"><a href="#聚集索引（InnoDB）" class="headerlink" title="聚集索引（InnoDB）"></a>聚集索引（InnoDB）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql5.png" alt></p><p>叶子节点上 挂着所有的数据</p><p>主键索引数</p><p>主键：<br>1、建主键<br>2、没建主键<br>找唯一字段 当主键<br>自动生成伪列 当主键<br>主键创建<br>自增整数<br>不要用大字符串比如 uuid</p><h4 id="辅助索引（次要索引）-1"><a href="#辅助索引（次要索引）-1" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql6.png" alt></p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql7.png" alt></p><p>辅助索引的叶子节点下面储存的是  主键值</p><h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>select * from t where name=’Alice’ 给name做了索引，查询全部，但是在索引树上面没有全部的数据，就照成了回表。</p><p>解决方案：用组合索引对查询的值形成覆盖。</p><p>聚集索引是MyISAM采用的索引形式，B+Tree的叶子节点存储的是数据的地址</p><p>非聚集索引是INNODB引擎采用的索引形式，B+Tree的叶子节点存储的是字段的值</p><h3 id="f-索引的使用场景"><a href="#f-索引的使用场景" class="headerlink" title="f.索引的使用场景"></a>f.索引的使用场景</h3><p><strong>哪些情况需要创建索引</strong><br>1、主键自动建立唯一索引<br>2、频繁作为查询条件的字段应该创建索引<br>3、多表关联查询中，关联字段应该创建索引 on 两边都要创建索引<br>4、查询中排序的字段，应该创建索引 B + tree 有顺序<br>5、覆盖索引 好处是？ 不需要回表 组合索引<br>6、统计或者分组字段，应该创建索引</p><p><strong>哪些情况不需要创建索引</strong><br>1、表记录太少 索引是要有存储的开销<br>2、频繁更新 索引要维护<br>3、查询字段使用频率不高</p><h3 id="g-组合索引"><a href="#g-组合索引" class="headerlink" title="g.组合索引"></a>g.组合索引</h3><p>由多个字段组成的索引 使用顺序就是创建的顺序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(col1,col2,col3）</span><br></pre></td></tr></table></figure><p><strong>使用：</strong><br><strong>遵循最左前缀原则</strong><br><strong>1、前缀索引</strong><br><strong>like 常量% 使用索引 like %常量 不使用索引</strong><br><strong>2、最左前缀</strong><br><strong>从左向右匹配直到遇到范围查询 &gt; &lt; between 索引失效</strong></p><h3 id="h-索引失效"><a href="#h-索引失效" class="headerlink" title="h.索引失效"></a>h.索引失效</h3><h4 id="1-全值匹配我最爱"><a href="#1-全值匹配我最爱" class="headerlink" title="1.全值匹配我最爱"></a>1.全值匹配我最爱</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name='zhaoyun' and age=1 and sex='1';</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_name_age_sex | idx_name_age_sex | <span class="number">312</span></span><br><span class="line">| <span class="keyword">const</span>,<span class="keyword">const</span>,<span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">条件与索引一一对应</span><br></pre></td></tr></table></figure><h4 id="2-最佳左前缀法则"><a href="#2-最佳左前缀法则" class="headerlink" title="2.最佳左前缀法则"></a>2.最佳左前缀法则</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组合索引 : 带头索引不能死，中间索引不能断</span><br></pre></td></tr></table></figure><p>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且不跳过索引中的列。</p><h4 id="3-不要在索引上做计算"><a href="#3-不要在索引上做计算" class="headerlink" title="3.不要在索引上做计算"></a>3.不要在索引上做计算</h4><h4 id="4-范围条件右边的列失效"><a href="#4-范围条件右边的列失效" class="headerlink" title="4.范围条件右边的列失效"></a>4.范围条件右边的列失效</h4><p>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name='asd' and age&gt;20 and sex='1';</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | range | idx_name_age_sex | idx_name_age_sex | <span class="number">308</span></span><br><span class="line">| <span class="literal">NULL</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br></pre></td></tr></table></figure><h4 id="5-尽量使用覆盖索引"><a href="#5-尽量使用覆盖索引" class="headerlink" title="5.尽量使用覆盖索引"></a>5.尽量使用覆盖索引</h4><h4 id="6-索引字段上不要使用不等"><a href="#6-索引字段上不要使用不等" class="headerlink" title="6.索引字段上不要使用不等"></a>6.索引字段上不要使用不等</h4><p>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where loginname!='zhy';</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows</span><br><span class="line">| Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_loginname | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="number">1</span></span><br><span class="line">| Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br></pre></td></tr></table></figure><h4 id="7-主键索引字段上不可以判断null"><a href="#7-主键索引字段上不可以判断null" class="headerlink" title="7.主键索引字段上不可以判断null"></a>7.主键索引字段上不可以判断null</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">主键字段上不可以使用 null</span><br><span class="line">索引字段上使用 is null 判断时，可使用索引</span><br><span class="line">mysql&gt; explain select * from tuser where name is null;</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_name_age_sex | idx_name_age_sex | <span class="number">303</span></span><br><span class="line">| <span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; explain select * from tuser where loginname is null</span>;</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len |</span><br><span class="line">ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_loginname | idx_loginname | <span class="number">303</span> |</span><br><span class="line"><span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br></pre></td></tr></table></figure><h4 id="8-索引字段使用like不以通配符开头"><a href="#8-索引字段使用like不以通配符开头" class="headerlink" title="8.索引字段使用like不以通配符开头"></a>8.索引字段使用like不以通配符开头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描</span><br><span class="line">mysql&gt; explain select * from tuser where name like 'a%';</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | range | idx_name_age_sex | idx_name_age_sex | <span class="number">303</span></span><br><span class="line">| <span class="literal">NULL</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">mysql&gt; explain select * from tuser where name like '%a';</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows</span><br><span class="line">| Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="number">2</span></span><br><span class="line">| Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br></pre></td></tr></table></figure><h4 id="9-索引字段字符串要加单引号"><a href="#9-索引字段字符串要加单引号" class="headerlink" title="9.索引字段字符串要加单引号"></a>9.索引字段字符串要加单引号</h4><p>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name=<span class="number">123</span>;</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref |</span><br><span class="line">rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_name_age_sex | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"><span class="number">2</span> | Using where |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br></pre></td></tr></table></figure><h4 id="10-索引字段不要使用or"><a href="#10-索引字段不要使用or" class="headerlink" title="10.索引字段不要使用or"></a>10.索引字段不要使用or</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">索引字段使用 <span class="keyword">or</span> 时，会导致索引失效而转向全表扫描</span><br><span class="line">mysql&gt; explain select * from tuser where name='asd' or age=23;</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref |</span><br><span class="line">rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_name_age_sex | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"><span class="number">2</span> | Using where |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br></pre></td></tr></table></figure><h4 id="11-口诀"><a href="#11-口诀" class="headerlink" title="11.口诀"></a>11.口诀</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">全值匹配我最爱，最左前缀要遵守 </span><br><span class="line">带头大哥不能死，中间兄弟不能断 </span><br><span class="line">索引列上少计算，范围之后全失效 </span><br><span class="line">LIKE符号写最右，覆盖索引不写星 </span><br><span class="line">不等空值还有or，索引失效要少用 </span><br><span class="line">var引号不能丢，SQL高级也不难 </span><br><span class="line">分组之前必排序，一定要上索引啊</span><br></pre></td></tr></table></figure><h2 id="六、数据库MySQL锁"><a href="#六、数据库MySQL锁" class="headerlink" title="六、数据库MySQL锁"></a>六、数据库MySQL锁</h2><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql1.png" alt></p><h3 id="一-表级锁介绍"><a href="#一-表级锁介绍" class="headerlink" title="一.表级锁介绍"></a>一.表级锁介绍</h3><p>由MySQL SQL layer层实现</p><h4 id="1-MySQL的表级锁有两种："><a href="#1-MySQL的表级锁有两种：" class="headerlink" title="1.MySQL的表级锁有两种："></a>1.MySQL的表级锁有两种：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种是表锁。</span><br><span class="line">一种是元数据锁（meta data lock，MDL)</span><br></pre></td></tr></table></figure><h4 id="2-表锁介绍"><a href="#2-表锁介绍" class="headerlink" title="2.表锁介绍"></a>2.表锁介绍</h4><p>表锁有两种表现形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表共享读锁（Table Read Lock）</span><br><span class="line">表独占写锁（Table Write Lock）</span><br></pre></td></tr></table></figure><p>手动增加表锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock table 表名称 read(write),表名称2 read(write)，其他;</span><br></pre></td></tr></table></figure><p>删除表锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="3-元数据锁介绍"><a href="#3-元数据锁介绍" class="headerlink" title="3.元数据锁介绍"></a>3.元数据锁介绍</h4><p>MDL (metaDataLock) 元数据：表结构</p><p>在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p><h3 id="二、行级锁"><a href="#二、行级锁" class="headerlink" title="二、行级锁"></a>二、行级锁</h3><h4 id="行级锁介绍"><a href="#行级锁介绍" class="headerlink" title="行级锁介绍"></a>行级锁介绍</h4><pre><code>InnoDB存储引擎实现</code></pre><p>InnoDB的行级锁，按照锁定范围来说，分为三种：</p><ul><li>记录锁（Record Locks）:锁定索引中一条记录。 主键指定 where id=3</li><li>间隙锁（Gap Locks）: 锁定记录前、记录中、记录后的行 RR隔离级 （可重复读）</li><li>Next-Key 锁: 记录锁 + 间隙锁</li></ul><h4 id="行级锁分类"><a href="#行级锁分类" class="headerlink" title="行级锁分类"></a>行级锁分类</h4><p>按照功能来说，分为两种：</p><h5 id="共享读锁（S）："><a href="#共享读锁（S）：" class="headerlink" title="共享读锁（S）："></a>共享读锁（S）：</h5><p>​    允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> <span class="comment">-- 共享读锁 手动添加</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="comment">-- 无锁</span></span><br></pre></td></tr></table></figure><h5 id="排他写锁（X）："><a href="#排他写锁（X）：" class="headerlink" title="排他写锁（X）："></a>排他写锁（X）：</h5><pre><code>允许获得排他写锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁（不是读）和排他写锁。</code></pre><h6 id="1、自动加-DML"><a href="#1、自动加-DML" class="headerlink" title="1、自动加 DML"></a>1、自动加 DML</h6><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p><h6 id="2、手动加"><a href="#2、手动加" class="headerlink" title="2、手动加"></a>2、手动加</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><p>InnoDB也实现了表级锁，也就是意向锁，意向锁是mysql内部使用的，不需要用户干预。</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>意向锁的主要作用是为了【全表更新数据】时的性能提升。否则在全表更新数据时，需要先检索该表是否某些记录上面有行锁。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql8.png" alt></p><h4 id="两阶段锁（2PL）"><a href="#两阶段锁（2PL）" class="headerlink" title="两阶段锁（2PL）"></a>两阶段锁（2PL）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql9.png" alt></p><p>锁操作分为两个阶段：加锁阶段与解锁阶段，</p><p>加锁阶段与解锁阶段不相交。</p><p>加锁阶段：只加锁，不放锁。</p><p>解锁阶段：只放锁，不加锁</p><h3 id="三，行锁演示"><a href="#三，行锁演示" class="headerlink" title="三，行锁演示"></a>三，行锁演示</h3><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p><h4 id="行读锁"><a href="#行读锁" class="headerlink" title="行读锁"></a>行读锁</h4><p>session1（Navicat）、session2（mysql）<br>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p><p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</p><p>Innodb_row_lock_time_avg：每次等待所花平均时间；</p><p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</p><p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看行锁状态 show STATUS like 'innodb_row_lock%';</span><br><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">select * from mylock where ID=<span class="number">1</span> lock in share mode; --手动加id=<span class="number">1</span>的行读</span><br><span class="line">锁,使用索引</span><br><span class="line"><span class="number">2</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; -- 未锁定该行可以修改</span><br><span class="line"><span class="number">3</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">1</span>; -- 锁定该行修改阻塞</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">-- 锁定超时</span><br><span class="line"><span class="number">4</span>、session1: commit; --提交事务 或者 rollback 释放读锁</span><br><span class="line"><span class="number">5</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">1</span>; --修改成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1 Changed: 1 Warnings: 0</span></span><br><span class="line">注：使用索引加行锁 ，未锁定的行可以访问</span><br></pre></td></tr></table></figure><h4 id="行读锁升级为表锁"><a href="#行读锁升级为表锁" class="headerlink" title="行读锁升级为表锁"></a>行读锁升级为表锁</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">--手动加name=<span class="string">'c'</span>的行读锁,未使用索引</span><br><span class="line">select * from mylock where name=<span class="string">'c'</span> lock in share mode;</span><br><span class="line"><span class="number">2</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; -- 修改阻塞 未用索引行锁升级为表锁</span><br><span class="line"><span class="number">3</span>、session1: commit; --提交事务 或者 rollback 释放读锁</span><br><span class="line"><span class="number">4</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; --修改成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1 Changed: 1 Warnings: 0</span></span><br><span class="line">注：未使用索引行锁升级为表锁</span><br></pre></td></tr></table></figure><h4 id="行写锁"><a href="#行写锁" class="headerlink" title="行写锁"></a>行写锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">--手动加id=<span class="number">1</span>的行写锁,</span><br><span class="line">select * from mylock where id=<span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line"><span class="number">2</span>、session2：select * from mylock where id=<span class="number">2</span> ; -- 可以访问</span><br><span class="line"><span class="number">3</span>、session2: select * from mylock where id=<span class="number">1</span> ; -- 可以读 不加锁</span><br><span class="line"><span class="number">4</span>、session2: select * from mylock where id=<span class="number">1</span> lock in share mode ; -- 加读锁</span><br><span class="line">被阻塞</span><br><span class="line"><span class="number">5</span>、session1：commit; -- 提交事务 或者 rollback 释放写锁</span><br><span class="line"><span class="number">5</span>、session2：执行成功</span><br><span class="line">主键索引产生记录锁</span><br></pre></td></tr></table></figure><h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">案例演示：</span><br><span class="line">mysql&gt; create table news (id int, number int,primary key (id));</span><br><span class="line">mysql&gt; insert into news values(1,2);</span><br><span class="line">......</span><br><span class="line"><span class="comment">--加非唯一索引</span></span><br><span class="line">mysql&gt; alter table news add index idx_num(number);</span><br><span class="line"><span class="comment">-- 非唯一索引的等值</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"></span><br><span class="line">注：id和number都在间隙内则阻塞。</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 主键索引的范围</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line">````</span><br><span class="line">注：id和number都在间隙内则阻塞。</span><br><span class="line">    </span><br><span class="line"><span class="comment">--无穷大</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> xx <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">13</span> ;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#(执行成功)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);<span class="comment">#(执行成功)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">14</span>,<span class="number">11</span>);<span class="comment">#(阻塞)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">15</span>,<span class="number">12</span>);<span class="comment">#(阻塞)</span></span><br><span class="line">检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因</span><br><span class="line">此，session 1的间隙锁的范围（11，无穷大）</span><br><span class="line">注：非主键索引产生间隙锁，主键范围产生间隙锁</span><br></pre></td></tr></table></figure><h3 id="四，死锁"><a href="#四，死锁" class="headerlink" title="四，死锁"></a>四，死锁</h3><p>两个 session 互相等等待对方的资源释放之后，才能释放自己的资源,造成了死锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、session1: <span class="keyword">begin</span>;<span class="comment">--开启事务未提交</span></span><br><span class="line"><span class="comment">--手动加行写锁 id=1 ，使用索引</span></span><br><span class="line"><span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'m'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line">2、session2：<span class="keyword">begin</span>;<span class="comment">--开启事务未提交</span></span><br><span class="line"><span class="comment">--手动加行写锁 id=2 ，使用索引</span></span><br><span class="line"><span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'m'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line">3、session1: <span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'nn'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>; <span class="comment">-- 加写锁被阻塞</span></span><br><span class="line">4、session2：<span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'nn'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- 加写锁会死锁，不允许操作</span></span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting</span><br><span class="line">transaction</span><br></pre></td></tr></table></figure><h2 id="七、MySQL事务"><a href="#七、MySQL事务" class="headerlink" title="七、MySQL事务"></a>七、MySQL事务</h2><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>在MySQL中的事务是由存储引擎实现的，而且支持事务的存储引擎不多，我们主要讲解InnoDB存储引擎中的事务。</p><p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p><p>事务用来管理DDL、DML、DCL 操作，比如 insert,update,delete 语句，默认是自动提交的。</p><h4 id="事务开启"><a href="#事务开启" class="headerlink" title="事务开启"></a>事务开启</h4><p>BEGIN 或START TRANSACTION<code>；显式地开启一个事务；</code></p><p><code>COMMIT 也可以使用COMMIT WORK ，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；</code></p><p><code>ROLLBACK 有可以使用ROLLBACK WORK</code>，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p><h4 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h4><p>Atomicity（原子性）：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。</p><p>Consistency（一致性）：数据库在事务执行前后状态都必须是稳定的或者是一致的。</p><p>Isolation（隔离性）：事务之间不会相互影响。</p><p>​        由锁机制和MVCC机制来实现的</p><p>​        MVCC(多版本并发控制)：优化读写性能（读不加锁、读写不冲突）</p><p>Durability（持久性）：事务执行成功后必须全部写入磁盘。</p><p><strong>总结来说，事务的隔离性</strong><br>        由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现。</p><h4 id="RedoLog"><a href="#RedoLog" class="headerlink" title="RedoLog"></a>RedoLog</h4><p>数据库日志和数据落盘机制，如下图所示:</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql15.png" alt></p><p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略</p><h4 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h4><p><strong>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</strong></p><p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql16.png" alt></p><p>数据和回滚日志的逻辑存储结构</p><p><strong>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undolog（也看成数据库数据）的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</strong></p><p>我们再来总结一下数据库事务的整个流程，如下图所示</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql14.png" alt></p><p><strong>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</strong></p><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务并发问题</p><p>在事务的并发操作中可能会出现一些问题：</p><ul><li>丢失更新：两个事务针对同一数据都发生修改操作时，会存在丢失更新问题。</li><li>脏读：一个事务读取到另一个事务未提交的数据。</li><li>不可重复读：一个事务因读取到另一个事务已提交的update或者delete数据。导致对同一条记录读取两次以上的结果不一致。</li><li>幻读：一个事务因读取到另一个事务已提交的insert数据。导致对同一张表读取两次以上的结果不一致。</li></ul><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>现在来看看MySQL数据库为我们提供的四种隔离级别（由低到高）：<br>① Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<br>② Read committed (RC，读已提交)：可避免脏读的发生。<br>③ Repeatable read (RR，可重复读)：可避免脏读、不可重复读的发生。<br>（注意事项：InnoDB的RR还可以解决幻读，主要原因是Next-Key锁，只有RR才能使用Next-Key锁）<br>④ Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。（由MVCC降级为Locking-Base CC）</p><h4 id="InnoDB的MVCC实现"><a href="#InnoDB的MVCC实现" class="headerlink" title="InnoDB的MVCC实现"></a>InnoDB的MVCC实现</h4><p>我们首先来看一下wiki上对MVCC的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiversion concurrency control (MCC or MVCC), is a concurrency control method</span><br><span class="line">commonly used by database management systems to provide concurrent access to the</span><br><span class="line">database and in programming languages to implement transactional memory.</span><br></pre></td></tr></table></figure><h5 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h5><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。</p><ul><li>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</li><li>当前读，读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这<br>条记录。</li></ul><p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？<br>以MySQL InnoDB为例：</p><ul><li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析) 不加读锁 读历史版本</li><li>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。 加行写锁 读当前版本</li></ul><h5 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h5><ul><li>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。</li><li>如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个最新可见快照。</li></ul><p>MVCC 在mysql 中的实现依赖的是 undo log 与 read view 。</p><h5 id="Undo-Log-结构"><a href="#Undo-Log-结构" class="headerlink" title="Undo Log 结构"></a>Undo Log 结构</h5><p>InnoDB行记录有三个隐藏字段：分别对应该<strong>行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，</strong></p><p>其中 <strong>db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。</strong></p><p>根据行为的不同，undo log分为两种：insert undo log和update undo log</p><h6 id="insert-undo-log："><a href="#insert-undo-log：" class="headerlink" title="insert undo log："></a>insert undo log：</h6><p>是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，</p><p>rollback 在该事务中直接删除 ，不需要进行 purge 操作</p><h6 id="update-undo-log-："><a href="#update-undo-log-：" class="headerlink" title="update undo log ："></a>update undo log ：</h6><p>是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，</p><p>rollback MVCC机制会找他的历史版本进行恢复</p><p>是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql17.png" alt></p><p>如下图所示（初始状态）：</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql19.png" alt></p><p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undolog中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。</p><p>如下图所示（第一次修改）：</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql20.png" alt></p><p>当事务3进行修改与事务2的处理过程类似，如下图所示（第二次修改）</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql21.png" alt></p><h5 id="事务链表"><a href="#事务链表" class="headerlink" title="事务链表"></a>事务链表</h5><p>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的事务链表中，这是一个基本的链表结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-trx --&gt; trx11 --&gt; trx9 --&gt; trx6 --&gt; trx5 --&gt; trx3;</span><br></pre></td></tr></table></figure><p>事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除</p><p>RR隔离级别下，在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)</p><p>RC隔离级别下，在每个语句开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)</p><p><strong>show engine innodb status ,就能够看到事务列表。</strong></p><h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>当前事务（读）能读哪个历史版本？</p><p><strong>Read View是事务开启时当前所有事务的一个集合，这个类中存储了当前Read View中最大事务ID及最小事务ID。</strong></p><p>这就是当前活跃的事务列表。如下所示，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-trx --&gt; trx11 --&gt; trx9 --&gt; trx6 --&gt; trx5 --&gt; trx3;</span><br></pre></td></tr></table></figure><p>ct-trx 表示当前事务的id，对应上面的read_view数据结构如下，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_view-&gt;creator_trx_id = ct-trx;</span><br><span class="line">read_view-&gt;up_limit_id = trx3; 低水位</span><br><span class="line">read_view-&gt;low_limit_id = trx11; 高水位</span><br><span class="line">read_view-&gt;trx_ids = [trx11, trx9, trx6, trx5, trx3];</span><br></pre></td></tr></table></figure><p><strong>low_limit_id是“高水位”，即当时活跃事务的最大id，如果读到row的db_trx_id&gt;=low_limit_id，说明这些id在此之前的数据都没有提交，如注释中的描述，这些数据都不可见。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line">注：readview 部分源码</span><br></pre></td></tr></table></figure><p><strong>up_limit_id是“低水位”，即当时活跃事务列表的最小事务id，如果row的db_trx_id&lt;up_limit_id,说明这些数据在事务创建的id时都已经提交，如注释中的描述，这些数据均可见。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>row的db_trx_id在low_limit_id和up_limit_id之间，则查找该记录的db_trx_id是否在自己事务的read_view-&gt;trx_ids列表中，如果在则该记录的当前版本不可见，否则该记录的当前版本可见。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql18.png" alt></p><h5 id="不同隔离级别ReadView实现方式"><a href="#不同隔离级别ReadView实现方式" class="headerlink" title="不同隔离级别ReadView实现方式"></a>不同隔离级别ReadView实现方式</h5><ol><li><h6 id="read-commited"><a href="#read-commited" class="headerlink" title="read-commited:"></a>read-commited:</h6></li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数：ha_innobase::external_lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;isolation_level &lt;= TRX_ISO_READ_COMMITTED</span><br><span class="line">        </span><br><span class="line">&amp;&amp; trx-&gt;global_read_view) &#123;</span><br><span class="line">        </span><br><span class="line">/ At low transaction isolation levels we let</span><br><span class="line">        each consistent <span class="built_in">read</span> set its own snapshot /</span><br><span class="line">        </span><br><span class="line">read_view_close_for_mysql(trx);</span><br></pre></td></tr></table></figure><ol start="2"><li><h6 id="repeatable-read："><a href="#repeatable-read：" class="headerlink" title="repeatable read："></a>repeatable read：</h6></li></ol><p>在repeatable read的隔离级别下，创建事务trx结构的时候，就生成了当前的global read view。使用trx_assign_read_view函数创建，一直维持到事务结束。在事务结束这段时间内 每一次查询都不会重新重建Read View ， 从而实现了可重复读。</p><h2 id="八、MySQL-落盘"><a href="#八、MySQL-落盘" class="headerlink" title="八、MySQL 落盘"></a>八、MySQL 落盘</h2><h4 id="InnoDB架构图"><a href="#InnoDB架构图" class="headerlink" title="InnoDB架构图"></a>InnoDB架构图</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql10.png" alt></p><h4 id="InnoDB磁盘文件"><a href="#InnoDB磁盘文件" class="headerlink" title="InnoDB磁盘文件"></a>InnoDB磁盘文件</h4><p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和<br>归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p><h5 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h5><ul><li>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且double write buffer,change buffer,undo logs的存储区域。</li><li>系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的。</li></ul><p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path 对数据文件的大小和数量进行配置。</p><p>innodb_data_file_path 的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=datafile1[,datafile2]...</span><br></pre></td></tr></table></figure><p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path = /db/ibdata1:<span class="number">1000</span>M;/dr2/db/ibdata2:<span class="number">1000</span>M:autoextend</span><br></pre></td></tr></table></figure><p>设置innodb_data_file_path参数之后，所有基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空间只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的系统表空间中。</p><p>下图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql11.png" alt></p><p>系统表空间（共享表空间）<br>1、数据字典(data dictionary)：记录数据库相关信息<br>2、doublewrite write buffer：解决部分写失败（页断裂）<br>3、insert buffer：内存insert buffer数据，周期写入共享表空间，防止意外宕机<br>4、回滚段(rollback segments)<br>5、undo空间：undo页</p><p>用户表空间<br>1、每个表的数据和索引都会存在自已的表空间中<br>2、undo空间：undo页 （需要设置）</p><h5 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h5><ul><li>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log file)，它记录了对于InnoDB存储引擎的事务日志。</li><li>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</li><li>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。</li><li>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</li><li>在日志组中每个重做日志文件的大小一致，并以【循环写入】的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</li><li>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</li><li>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。</li></ul><h5 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h5><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一 个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql12.png" alt></p><ul><li>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。</li><li>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</li><li>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。</li><li>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。</li></ul><h5 id="日志的刷盘机制如下图所示："><a href="#日志的刷盘机制如下图所示：" class="headerlink" title="日志的刷盘机制如下图所示："></a>日志的刷盘机制如下图所示：</h5><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql13.png" alt></p><p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。</p><ul><li>当参数值为0时，写入效率最高，但是数据安全最低；</li><li>参数值为1时，写入效率最低，但是数据安全最高；</li><li>参数值为2时，二者都是中等水平。</li><li>一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、数据库隔离级别（详见七）&quot;&gt;&lt;a href=&quot;#一、数据库隔离级别（详见七）&quot; class=&quot;headerlink&quot; title=&quot;一、数据库隔离级别（详见七）&quot;&gt;&lt;/a&gt;一、数据库隔离级别（详见七）&lt;/h2&gt;&lt;p&gt;四种隔离级别（SQL92标准）：&lt;br&gt;现在
      
    
    </summary>
    
    
    
      <category term="数据库" scheme="https://liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>缓存</title>
    <link href="https://liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/"/>
    <id>https://liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/</id>
    <published>2020-03-05T08:53:57.000Z</published>
    <updated>2020-03-06T09:17:19.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是缓存？"><a href="#一、什么是缓存？" class="headerlink" title="一、什么是缓存？"></a><strong>一、什么是缓存？</strong></h2><ul><li>缓存就是数据交换的缓冲区（称作：Cache），当某一硬件要读取数据时，会首先从缓存汇总查询数据，有则直接执行，不存在时从内存中获取。由于缓存的数据比内存快的多，所以缓存的作用就是帮助硬件更快的运行。</li><li>缓存往往使用的是RAM（断电既掉的非永久存储），所以在用完后还是会把文件送到硬盘等存储器中永久存储。电脑中最大缓存就是内存条，硬盘上也有16M或者32M的缓存。</li><li>高速缓存是用来协调CPU与主存之间存取速度的差异而设置的。一般CPU工作速度高，但内存的工作速度相对较低，为了解决这个问题，通常使用高速缓存，高速缓存的存取速度介于CPU与主存之间。系统将一些CPU在最近几个时间段经常访问的内容存在高速缓存，这样就在一定程度上缓解了由于主存速度低造成的CPU“停工待料”的情况。</li><li>缓存就是把一些外存上的数据保存在内存上而已，为什么保存在内存上，我们运行的所有程序里面的变量都是存放在内存中的，所以如果想将值放入内存上，可以通过变量的方式存储。在JAVA中一些缓存一般都是通过Map集合来实现的。</li></ul><p>缓存在不同的场景下，作用是不一样的具体举例说明：</p><ul><li>操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。</li><li>数据库缓存——&gt;减少文件系统IO。</li><li>应用程序缓存——&gt;减少对数据库的查询。</li><li>Web服务器缓存——&gt;减少应用服务器请求。</li><li>客户端浏览器缓存——&gt;减少对网站的访问。</li></ul><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache.png" alt></p><h2 id="二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"><a href="#二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。" class="headerlink" title="二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"></a>二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。</h2><p> 【1】由于不同系统的数据访问模式不同，同一种缓存策略很难在不同的数据访问模式下取得满意的性能，研究人员提出不同缓存策略以适应不同的需求。缓存策略的分类： </p><p>  1）、基于访问的时间：此类算法按各缓存项被访问时间来组织缓存队列，决定替换对象。如 LRU；<br>   2）、基于访问频率：此类算法用缓存项的被访问频率来组织缓存。如 LFU、LRU2、2Q、LIRS；<br>   3）、访问时间与频率兼顾：通过兼顾访问时间和频率。使得数据模式在变化时缓存策略仍有较好性能。如 FBR、LRUF、ALRFU。多数此类算法具有一个可调或自适应参数，通过该参数的调节使缓存策略在基于访问时间与频率间取得一个平衡；<br>   4）、基于访问模式：某些应用有较明确的数据访问特点，进而产生与其相适应的缓存策略。如专用的 VoD 系统设计的A&amp;L缓存策略，同时适应随机、顺序两种访问模式的 SARC策略；</p><p> 【2】、数据不一致性产生的原因： </p><p> 1）、先操作缓存，再写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。在分布式环境下，数据的读写都是并发的，一个服务多机器部署，对同一个数据进行读写，在数据库层面并不能保证完成顺序，就有可能后读的操作先完成（读取到的是脏数据），如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>【解决办法】：</p><ul><li>可采用更新前后双删除缓存策略；</li><li>可以通过“串行化”解决，保证同一个数据的读写落在同一个后端服务上；</li></ul><p>  2）、先操作数据库，再清除缓存。如果删缓存失败了，就会出现数据不一致问题。<br>【解决办法】：①、将删除失败的 key 值存入队列中重复删除</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache1.png" alt></p><p> （1）更新数据库数据。<br>  （2）缓存因为种种问题删除失败。<br>  （3）将需要删除的key发送至消息队列。<br>  （4）自己消费消息，获得需要删除的key。<br>  （5）继续重试删除操作，直到成功。<br>  <strong>缺点</strong>：对业务线代码造成大量的侵入。于是有了方案二。 </p><p> ②、方案二：通过订阅 binlog 获取需要重新删除的 Key 值数据。在应用程序中，另起一段程序，获得这个订阅程序传来的消息，进行删除缓存操作 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache2.png" alt></p><p>​    （1）更新数据库数据<br>​    （2）数据库会将操作信息写入binlog日志当中<br>​    （3）订阅程序提取出所需要的数据以及key<br>​    （4）另起一段非业务代码，获得该信息<br>​    （5）尝试删除缓存操作，发现删除失败<br>​    （6）将这些信息发送至消息队列<br>​    （7）重新从消息队列中获得该数据，重试操作。</p><h2 id="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"><a href="#三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。" class="headerlink" title="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"></a><strong>三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。</strong></h2><p> <strong>【</strong>1】、缓存穿透：缓存穿透是说收到一个请求，但是该请求缓存中不存在，只能去数据库中查询，然后放进缓存。但当有好多请求同时访问同一个数据时，业务系统把这些请求全发到了数据库；或者恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次都会被发送到数据库，最总导致数据库挂掉。 </p><p> 【<strong>解决的办法</strong>】：对于恶意访问，一种思路是先做校验，对恶意数据直接过滤掉，不要发送至数据库层；第二种思路是缓存空结果，就是对查询不存在的数据也记录在缓存中，这样就可以有效的减少查询数据库的次数。非恶意访问，结合缓存击穿说明。 </p><p> 【2】、缓存击穿：上面提到的某个数据没有，然后好多请求查询数据库，可以归为缓存击穿的范畴：对于<strong>热点数据</strong>，当缓存失效的一瞬间，所有的请求都被下放到数据库去请求更新缓存，数据库被压垮。 </p><p>【解决的办法】：防范此类问题，一种思路是加<strong>全局锁</strong>，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但现在大部分系统都是分布式的，本地锁无法控制其他服务器也等待，所以要用到全局锁，比如Redis的setnx实现全局锁。另一种思想是对<strong>即将过期的数据进行主动刷新</strong>，比如新起一个线程轮询数据，或者比如把所有的数据划分为不同的缓存区间，定期分区间刷新数据。第二个思路与缓存雪崩有点关系。</p><p> 【3】、缓存雪崩：缓存雪崩是指当我们给所有的缓存设置了同样的过期时间，当某一时刻，整个缓存的数据全部过期了，然后瞬间所有的请求都被抛向了数据库，数据库就崩掉了。 </p><p> 【<strong>解决的办法</strong>】：解决思路要么是分治，<strong>划分更小的缓存区间</strong>，按区间过期；要么<strong>给每个key的过期时间加一个随机值</strong>，避免同时过期，达到错峰刷新缓存的目的。  </p><p>对于 Redis 挂掉了，请求全部走数据库，也属于缓存雪崩，我们可以有以下思路进行解决：</p><ul><li><p>事发前：实现 Redis 的高可用（主从架构+Sentinel 或者 Redis Cluster），尽可能避免 Redis 挂掉这种情况。</p></li><li><p>事发中：万一 Redis 真的挂了，我们可以设置本地缓存（ehcache）+ 限流（hystrix），尽量避免我们的数据库被干掉。</p></li><li><p>事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</p></li></ul><h2 id="四、Redis内存用完会发生什么？"><a href="#四、Redis内存用完会发生什么？" class="headerlink" title="四、Redis内存用完会发生什么？"></a><strong>四、Redis内存用完会发生什么？</strong></h2><p> 如果达到设置的上限，Redis 的<strong>写命令会返回错误信息</strong>（但是读命令还是可以正常返回），或者将 Redis 当缓存使用，<strong>配置缓存淘汰机制</strong>，当 Redis 达到内存的上线时会冲掉旧的数据。 </p><h2 id="五、Redis-的-List-结构相关的操作"><a href="#五、Redis-的-List-结构相关的操作" class="headerlink" title="五、Redis 的 List 结构相关的操作"></a><strong>五、Redis 的 List 结构相关的操作</strong></h2><p> 【1】、PUSH操作：是从队列头部和尾部增加节点的操作。 </p><ul><li>RPUSH KEY VALUE [VALUE …] ：从队列的右端入队一个或者多个数据，如果key值不存在，会自动创建一个空的列表。如果对应的key不是一个List，则会返回一个错误。</li><li>LPUSH KEY VALUE [VALUE…] ：从队列的左边入队一个或多个元素。复杂度O(1)。</li><li>RPUSHX KEY VALUE：从队列的右边入队一个元素，仅队列存在时有效，当队列不存在时，不进行任何操作。</li><li>LPUSHX KEY VALUE：从队列的左边入队一个元素，仅队列存在时有效。当队列不存在时，不进行任何操作。</li></ul><p> 【2】、POP操作：获取并删除头尾节点的操作。 </p><ul><li>LPOP KEY：从队列左边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li><li>RPOP KEY：从队列的右边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li><li>BLPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最左边的第一个元素，当队列为空时，阻塞TIMEOUT时间，单位是秒（这个时间内尝试获取KEY中的数据），超过TIMEOUT后如果仍未数据则返回(nil)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; BLPOP <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> (nil)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> (<span class="number">1.10</span>s)</span><br></pre></td></tr></table></figure><ul><li><p>BRPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最后一个元素，或阻塞TIMEOUT。如上↑ </p><p>【4】、其他 </p></li><li><p>LLEN KEY：获取队列（List）的长度。</p></li><li><p>LRANG KEY START STOP：从列表中获取指定（START-STOP）长度的元素。负数表示从右向左数。需要注意的是，超出范围的下标不会产生错误：如果start&gt;end，会得到空列表，如果end超过队尾，则Redis会将其当做列表的最后一个元素。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> redis&gt; rpush q1 a b c d f e g</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q1 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"f"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"e"</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br></pre></td></tr></table></figure><ul><li><p>LINDEX KEY INDEX：获取一个元素，通过其索引列表。我们之前介绍的操作都是对list的两端进行的，所以算法复杂度都只有O(1)。而这个操作是指定位置来进行的，每次操作，list都得找到对应的位置，因此算法复杂度为O(N)。list的下表是从0开始的，index为负的时候是从右向左数。-1表示最后一个元素。当下标超出的时候，会返回nul。所以不用像操作数组一样担心范围越界的情况。</p></li><li><p>LSET KEY INDEX：重置队列中INDEX位置的值。当index越界的时候，这里会报异常。 </p></li><li><p>LREM KEY COUNT VALUE：从列表中删除COUNT个VALUE元素。COUNT参数有三种情况： </p><p>​      count &gt; 0: 表示从头向尾（左到右）移除值为value的元素。<br>​      count &lt; 0: 表示从尾向头（右向左）移除值为value的元素。<br>​      count = 0: 表示移除所有值为value的元素。 </p></li><li><p>LTRIM KEY START STOP：修剪到指定范围内的清单，相当与截取，只保留START-STOP之间的数据。 </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; rpush q a b c d e f g</span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"e"</span></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"f"</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br><span class="line"><span class="number">11</span> redis&gt; ltrim q <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">12</span> OK</span><br><span class="line"><span class="number">13</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">14</span> <span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">15</span> <span class="number">2</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">16</span> <span class="number">3</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">17</span> <span class="number">4</span>) <span class="string">"e"</span></span><br></pre></td></tr></table></figure><ul><li>LINSERT KEY BEFORE|AFTER 元素 VALUE：在列表中的另一个元素之前或之后插入VAULE。当 key 不存在时，这个List被视为空列表，任何操作都不会发生。当key存在，但保存的不是 List，则会报 error。该命令会返回修改之后的 List的长度，如果找不到元素，则会返回 -1。</li></ul><h2 id="六、Redis的数据结构都有哪些"><a href="#六、Redis的数据结构都有哪些" class="headerlink" title="六、Redis的数据结构都有哪些"></a><strong>六、Redis的数据结构都有哪些</strong></h2><p>【1】、String：可以是字符串，整数或者浮点数，对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作。<br>【2】、List：一个链表，链表上的每个节点都包含了一个字符串，链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素。可参考5<br>【3】、Set：包含字符串的无序收集器(unordered collection)、并且被包含的每个字符串都是独一无二的。添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集（sinter），并集（suion），差集（sdiff），从集合里面随机获取元素。<br>【4】、SortSet：是一个排好序的 Set，它在 Set 的基础上增加了一个顺序属性 score，这个属性在添加修改元素时可以指定，每次指定后，SortSet 会自动重新按新的值排序。sorted set 的内部使用 HashMap 和跳跃表(SkipList)来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 score。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> <span class="string">"one"</span> <span class="number">2</span> <span class="string">"two"</span> <span class="number">3</span> <span class="string">"three"</span> #添加元素</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrem myzset one   <span class="comment">//删除元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>【 5】、hash：Hash 是一个 String 类型的 field 和 value 之间的映射表，即 redis 的 Hash 数据类型的 key（hash表名称）对应的 value 实际的内部存储结构为一个 HashMap，因此 Hash 特别适合存储对象。相对于把一个对象的每个属性存储为 String 类型，将整个对象存储在 Hash 类型中会占用更少内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash age <span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash name</span><br><span class="line"><span class="string">"zhangsan"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash age</span><br><span class="line"><span class="string">"20"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"><a href="#七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。" class="headerlink" title="七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"></a><strong>七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</strong></h2><p>使用阶段我们从数据存储和数据获取两个方面来说明开发时的注意事项：<br>【1】数据存储：因为内存空间的局限性，注定了能存储的数据量有限，如何在有限的空间内存储更多的数据信息是我们应该关注的。Redis内存储的都是键值对，那么如何减小键值对所占据的内存空间就是空间优化的本质。在能清晰表达业务含义的基础上尽可能缩减Key的字符长度，比如一个键是user:{id}:logintime ，可以使用业务属性的简写来u:{id}:lgt,只要能清晰表达业务意义，使用简写形式是有其必要性的。在不影响使用的情况下，缩减Value的数据大小。如果Value是较大的数据信息，比如图片，大文本等，可以使用压缩工具压缩过后再存入Redis；如果Value是对象序列化或者gson信息，可以考虑去除非必要的业务属性。<br>减少键值对的数量，对于大量的String类型的小对象，可以尝试使用Hash的形式组合他们，在Hash对象内Field数量少于1000，且Value的字符长度小于40时，内部使用ziplist的编码形式，能够极大的降低小对象占据的内存空间。<br>Redis内维护了一个[0-9999]的整数对象池，类似Java内的运行时常量池，只创建一个常量，使用时都去引用这个常量，所以当存储的value是这个范围内的数字时均是引用向都一个内存地址，所以能够降低一些内存空间耗费。但是共享对象池和maxmemory+LRU的内存回收策略冲突，因为共享Value对象的lru值也共享，难以通过lru知道哪个Key的最后引用时间，所以永远也不能回收内存。如果多次数据操作要求原子性，可使用Multi来实现Redis的事务。<br>【2】数据查询：Redis 是一种数据库，和其他数据库一样，操作时也需要有连接对象，连接对象的创建和销毁也需要耗费资源，复用连接对象很有必要，所以推荐使用连接池来管理连接。Redis数据存储在内存中，查询很快，但不代表连接也很快。一次Redis查询可能IO部分占据了请求时间的绝大部分比例，缩短IO时间是开发过程中很需要注意的一点。对于一个业务内的多次查询，考虑使用Pipeline，将多次查询合并为一次查询，命令会被执行多次，但是只有一个IO传输，能够有效的提高响应速度。<br>对于多次String类型的查询，使用mget，将多次请求合并为一次，同时命令和会被合并为一次，能有效提高响应速度，对于Hash内多个Field查询，使用hmget，起到和mget同样的效果。Redis是单线程执行的，也就是说同一时间只能执行一条命令，如果一条命令执行的时间较长，其他线程在此期间均会被阻塞，所以在操作Redis时要注意操作指令的涉及的数据量，尽量降低单次操作的执行时间。<br>【持久化方式】：RDB 时间点快照 AOF 记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。可参考14深度解析<br>【内存设置】：maxmemory used_memory<br>【虚拟内存】： vm-enabled yes<br>【集群的应用和优劣势】：参考9<br>【内存优化】：<a href="http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage</a><br>【淘汰策略】：<a href="http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html</a></p><p>Redis 提供 6 种数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用 的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数 据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据 淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><h2 id="八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制"><a href="#八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制" class="headerlink" title="八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制"></a><strong>八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制</strong></h2><p>集群方式的区别：Redis3 采用Cluster，Redis2 采用客户端分区方案和代理方案；<br>通信过程说明：<br>  1） 集群中的每个节点都会单独开辟一个TCP通道， 用于节点之间彼此通信， 通信端口号在基础端口上加10000。<br>  2） 每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。<br>  3） 接收到 ping 消息的节点用 pong 消息作为响应。</p><h2 id="九、当前-Redis-集群有哪些玩法，各自优缺点，场景。"><a href="#九、当前-Redis-集群有哪些玩法，各自优缺点，场景。" class="headerlink" title="九、当前 Redis 集群有哪些玩法，各自优缺点，场景。"></a><strong>九、当前 Redis 集群有哪些玩法，各自优缺点，场景。</strong></h2><p>【1】数据共享：Redis 提供多个节点实例间的数据共享，也就是 Redis A,B,C,D彼此之间的数据是同步的，同样彼此之间也可以通信，而对于客户端操作的 keys 是由 Redis 系统自行分配到各个节点中。<br>【2】主从复制：Redis 的多个实例间通信时，一旦其中的一个节点故障，那么 Redis 集群就不能继续正常工作，所以需要一种复制机制（Master-Slave）机制，做到一旦节点A故障了，那么其从节点A1和A2就可以接管并继续提供与A同样的工作服务，当然如果节点A,A1,A2节点都出现问题，那么同样这个集群不会继续保持工作，但是这种情况比较罕见，即使出现了，也会及时发现并修复使用。建议：部署主从复制机制（Master-Slave）。<br>【3】哈希槽值：Redis 集群中使用哈希槽来存储客户端的 keys，而在 Redis 中，目前存在16384个哈希槽，它们被全部分配给所有的节点，正如上图所示，所有的哈希槽值被节点A，B，C分配完成了。<br>参考：<a href="https://www.cnblogs.com/RENQIWEI1995/p/8931678.html" target="_blank" rel="noopener">https://www.cnblogs.com/RENQIWEI1995/p/8931678.html</a></p><h2 id="十、Memcache-的原理，哪些数据适合放在缓存中。"><a href="#十、Memcache-的原理，哪些数据适合放在缓存中。" class="headerlink" title="十、Memcache 的原理，哪些数据适合放在缓存中。"></a><strong>十、Memcache 的原理，哪些数据适合放在缓存中。</strong></h2><p> 首先要说明一点，MemCache 的数据存放在内存中，存放在内存中个人认为意味着几点： </p><p> 【1】访问数据的速度比传统的关系型数据库要快，因为 Oracle、MySQL 这些传统的关系型数据库为了保持数据的持久性，数据存放在硬盘中，IO操作速度慢； </p><p> 【2】MemCache 的数据存放在内存中同时意味着只要 MemCache 重启了，数据就会消失； </p><p> 【3】既然 MemCache 的数据存放在内存中，那么势必受到机器位数的限制，这个之前的文章写过很多次了，32位机器最多只能使用2GB的内存空间，64位机器可以认为没有上限。</p><p>  然后我们来看一下 MemCache 的原理，MemCache 最重要的莫不是内存分配的内容了，MemCache 采用的内存分配方式是固定空间分配，一张图说明： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache3.png" alt></p><p>这张图片里面涉及了slab_class、slab、page、chunk四个概念，它们之间的关系是：<br>【1】、MemCache将内存空间分为一组slab<br>【2】、每个slab下又有若干个page，每个page默认是1M，如果一个slab占用100M内存的话，那么这个slab下应该有100个page<br>【3】、每个page里面包含一组chunk，chunk是真正存放数据的地方，同一个slab里面的chunk的大小是固定的<br>【4】、有相同大小chunk的slab被组织在一起，称为slab_class<br>MemCache内存分配的方式称为allocator，slab的数量是有限的，几个、十几个或者几十个，这个和启动参数的配置相关。<br>MemCache中的value过来存放的地方是由value的大小决定的，value总是会被存放到与chunk大小最接近的一个slab中，比如slab[1]的chunk大小为80字节、slab[2]的chunk大小为100字节、slab[3]的chunk大小为128字节（相邻slab内的chunk基本以1.25为比例进行增长，MemCache启动时可以用-f指定这个比例），那么过来一个88字节的value，这个value将被放到2号slab中。放slab的时候，首先slab要申请内存，申请内存是以page为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的page被分配给该slab。申请到page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk数组，最后从这个chunk数组中选择一个用于存储数据。<br>如果这个slab中没有chunk可以分配了怎么办，如果MemCache启动没有追加-M（禁止LRU，这种情况下内存不够会报Out Of Memory错误），那么MemCache会把这个slab中最近最少使用的chunk中的数据清理掉，然后放上最新的数据。针对MemCache的内存分配及回收算法，总结三点：</p><p> 【1】、MemCache的内存分配chunk里面会有内存浪费，88字节的value分配在128字节（紧接着大的用）的chunk中，就损失了30字节，但是这也避免了管理内存碎片的问题 </p><p> 【2】、MemCache的LRU算法不是针对全局的，是针对slab的 </p><p> 【3】、应该可以理解为什么MemCache存放的value大小是限制的，因为一个新数据过来，slab会先以page为单位申请一块内存，申请的内存最多就只有1M，所以value大小自然不能大于1M了。 </p><p> <strong>再总结 MemCache 的特性和限制：</strong> </p><p>上面已经对于MemCache做了一个比较详细的解读，这里再次总结MemCache的限制和特性：<br>1】、MemCache中可以保存的item数据量是没有限制的，只要内存足够<br>2】、MemCache单进程在32位机中最大使用内存为2G，这个之前的文章提了多次了，64位机则没有限制<br>3】、Key最大为250个字节，超过该长度无法存储<br>4】、单个item最大数据是1MB，超过1MB的数据不予存储<br>5】、MemCache服务端是不安全的，比如已知某个MemCache节点，可以直接telnet过去，并通过flush_all让已经存在的键值对立即失效<br>6】、不能够遍历MemCache中所有的item，因为这个操作的速度相对缓慢且会阻塞其他的操作<br>7】、MemCache的高性能源自于两阶段哈希结构：第一阶段在客户端，通过Hash算法根据Key值算出一个节点；第二阶段在服务端，通过一个内部的Hash算法，查找真正的item并返回给客户端。从实现的角度看，MemCache是一个非阻塞的、基于事件的服务器程序<br>8】、MemCache设置添加某一个Key值的时候，传入expiry为0表示这个Key值永久有效，这个Key值也会在30天之后失效。</p><p> <strong>MemCache适合存储：</strong> </p><p>变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线状态、在线人数..)门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入到memcache中.(配合jquey的ajax请求)。 </p><h2 id="十一、Redis-和-Memcached-的内存管理的区别"><a href="#十一、Redis-和-Memcached-的内存管理的区别" class="headerlink" title="十一、Redis 和 Memcached 的内存管理的区别"></a><strong>十一、Redis 和 Memcached 的内存管理的区别</strong></h2><p>可参考博客1：<a href="http://lib.csdn.net/article/redis/55323" target="_blank" rel="noopener">http://lib.csdn.net/article/redis/55323</a><br>可参考博客2：<a href="https://www.cnblogs.com/work115/p/5584646.html" target="_blank" rel="noopener">https://www.cnblogs.com/work115/p/5584646.html</a> </p><h2 id="十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？"><a href="#十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？" class="headerlink" title="十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？"></a>十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？</h2><p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在 Jedis 客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：<br>【1】客户端角度，为保证每个客户端间正常有序与 Redis 进行通信，对连接进行池化，同时对客户端读写 Redis 操作采用内部锁 synchronized。<br>【2】服务器角度，利用 setnx 实现锁</p><p> MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：<br>   ☆ MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行<br>   ☆ EXEC，告诉 Redis 开始执行事务<br>   ☆ DISCARD，告诉 Redis 取消事务<br>   ☆ WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。</p><p>【<strong>Redis 事务机制</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a><br>【<strong>CAS 操作</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a> </p><h2 id="十三、Redis-的选举算法和流程是怎样的"><a href="#十三、Redis-的选举算法和流程是怎样的" class="headerlink" title="十三、Redis 的选举算法和流程是怎样的"></a><strong>十三、Redis 的选举算法和流程是怎样的</strong></h2><p><strong>Raft</strong> 采用心跳机制触发 Leader 选举。系统启动后，全部节点初始化为 Follower，term 为0。节点如果收到了 RequestVote 或者AppendEntries，就会保持自己的 Follower 身份。如果一段时间内没收到 AppendEntries 消息直到选举超时，说明在该节点的超时时间内还没发现 Leader，Follower 就会转换成 Candidate，自己开始竞选 Leader。一旦转化为 Candidate，该节点立即开始下面几件事情：<br> 1）、增加自己的term。<br> 2）、启动一个新的定时器。<br> 3）、给自己投一票。<br> 4）、向所有其他节点发送RequestVote，并等待其他节点的回复。<br>✔ 如果在这过程中收到了其他节点发送的AppendEntries，就说明已经有Leader产生，自己就转换成Follower，选举结束。<br>✔ 如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送AppendEntries，告知自己成为了Leader。<br>✔ 每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，Follower会投给第一个收到RequestVote的节点。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC, 则自己转换为Candidate, 开始请求投票，就是上面的的竞选Leader步骤。<br>✔ 如果多个Candidate发起投票，每个Candidate都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为Candidate，重复前面竞选Leader步骤。<br>✔ Raft协议的定时器采取随机超时时间，这是选举Leader的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的1倍到2倍之间。由于随机配置，所以各个Follower同时转成Candidate的时间一般不一样，在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。多个节点同时转换为Candidate的可能性很小。即使几个Candidate同时发起投票，在该term内有几个节点获得一样高的票数，只是这个term无法选出Leader。由于各个节点定时器的超时时间随机生成，那么最先进入下一个term的节点，将更有机会成为Leader。连续多次发生在一个term内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般1-2个term类，Leader就会被选出来。</p><p><strong>【Sentinel 的选举流程】</strong>：Sentinel 集群正常运行的时候每个节点 epoch 相同，当需要故障转移的时候会在集群中选出 Leader执行故障转移操作。Sentinel采 用了Raft 协议实现了 Sentinel 间选举 Leader 的算法，不过也不完全跟论文描述的步骤一致。Sentinel 集群运行过程中故障转移完成，所有 Sentinel 又会恢复平等。Leader 仅仅是故障转移操作出现的角色。</p><p>【选举流程】：1）、某个 Sentinel 认定 master 客观下线的节点后，该 Sentinel 会先看看自己有没有投过票，如果自己已经投过票给其他 Sentinel 了，在2倍故障转移的超时时间自己就不会成为 Leader。相当于它是一个 Follower。<br>  2）、如果该 Sentinel 还没投过票，那么它就成为 Candidate。<br>  3）、和 Raft 协议描述的一样，成为 Candidate，Sentinel 需要完成几件事情。<br>   【1】更新故障转移状态为start<br>   【2】当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。<br>   【3】更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。<br>   【4】向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。<br>   【5】给自己投一票，在 Sentinel 中，投票的方式是把自己 master 结构体里的 leader 和 leader_epoch 改成投给的 Sentinel 和它的 epoch。<br>   4）、其他Sentinel会收到Candidate的is-master-down-by-addr命令。如果Sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的Sentinel后，在当前epoch内自己就只能成为Follower。<br>   5）、Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。Sentinel比Raft协议增加了quorum，这样一个Sentinel能否当选Leader还取决于它配置的quorum。<br>   6）、如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。<br>   7）、如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。<br>   8）、如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。<br>   9）、与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他Sentinel。其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p><h2 id="十四、Redis-的持久化的机制，AOF和RDB的区别。"><a href="#十四、Redis-的持久化的机制，AOF和RDB的区别。" class="headerlink" title="十四、Redis 的持久化的机制，AOF和RDB的区别。"></a>十四、Redis 的持久化的机制，AOF和RDB的区别。</h2><p><strong>Redis的持久化机制</strong>：Redis 提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。<br> <strong>AOF和RDB的区别</strong>：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache4.png" alt></p><p> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache5.png" alt></p><p>【二者优缺点】：RDB存在哪些优势：<br>【1】一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。<br>【2】对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。<br>【3】性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。<br>【4】相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p><p>【RDB又存在哪些劣势】：<br>【1】如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。<br>【2】由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p><p>【AOF 的优势有哪些】：<br>【1】该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。<br>【2】由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。<br>【3】如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。<br>【4】AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p><p>【AOF 的劣势有哪些】：<br>【1】对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>【2】根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p><p> <strong>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</strong> </p><h2 id="十五、缓存预热"><a href="#十五、缓存预热" class="headerlink" title="十五、缓存预热"></a><strong>十五、缓存预热</strong></h2><p> 新的缓存系统没有任何数据，在缓存重建数据的过程中，系统性能和数据负载都不太好，所以最好在系统上线之前就把缓存的热点数据加载到缓存中，这种缓存预加载手段就是缓存预热。 </p><h2 id="十六、缓存热备"><a href="#十六、缓存热备" class="headerlink" title="十六、缓存热备"></a><strong>十六、缓存热备</strong></h2><p> 缓存热备既当一个缓存服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从节点备用，一旦主节点挂掉，从节点会被哨兵提升为主节点使用。 </p><h2 id="十七、Redis-的集群怎么同步的数据的"><a href="#十七、Redis-的集群怎么同步的数据的" class="headerlink" title="十七、Redis 的集群怎么同步的数据的"></a><strong>十七、Redis 的集群怎么同步的数据的</strong></h2><p>Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。</p><p>Reds 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。</p><p>使用哈希槽的好处就在于可以方便的添加或移除节点。</p><p>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</p><p>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；</p><p>在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务</p><p><strong>Redis集群的主从架构：</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品。</p><p>例如有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少B节点所承担的哈希槽这个范围的槽而不可用。</p><p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了。当然如果B和B1都down了，那集群还是不可用的，不过这种情况微乎其妙，基本不用考虑，出发你交换机挂了吧，或者机房断电。</p><p> <strong>Redis 集群搭建</strong>的方式有很多种，但从 redis 3.0 版本之后，支持 redis-cluster 集群，它是 Redis 官方提供的解决方案，Redis Cluster 采用的是 无中心架构 ，每个节点保存数据和整个集群状态，每个节点都和其他节点有所连接。其架构如下： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache6.png" alt></p><p>客户端与 redis 节点直连，不需要中间件 proxy 层，客户端不需要连接集群所有节点，连接集群汇中任何一个节点即可。所有的 redis 节点彼此互联（PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。 </p><p> <strong>分布式存储机制-槽</strong> </p><p>【1】、redis_cluster 把所有的节点映射到 [0-16383] slot 槽上，cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value 三者之间的关系。<br>【2】、Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先将 key 使用 CRC16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点上。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，当有三个节点时，槽分布的值如下：</span><br><span class="line">节点1：   0-5460</span><br><span class="line">节点2：   5461-10921</span><br><span class="line">节点3:    10922-16383</span><br></pre></td></tr></table></figure><h2 id="十八、知道哪些-Redis-的优化操作"><a href="#十八、知道哪些-Redis-的优化操作" class="headerlink" title="十八、知道哪些 Redis 的优化操作"></a>十八、知道哪些 Redis 的优化操作</h2><h3 id="一、Linux-操作系统"><a href="#一、Linux-操作系统" class="headerlink" title="一、Linux 操作系统"></a><strong>一、Linux 操作系统</strong></h3><p>【1】<strong>ulimit 与 TCP backlog：1</strong>）、修改 ulimit：通过 ulimit 修改 open files 参数，redis 建议把 open files 至少设置成 10032，因为 maxclients 是10000  [客户端的数据是以文件的形式进行保存的] ，另外 redis 内部最多会使用 32 个文件描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n <span class="number">10032</span>  #但重启后就无效了，也可以通过配置文件limits.conf 的形式持久修改</span><br><span class="line">#修改了，重新登录后就立刻生效.可以用CentOS ulimit -a 查看确认</span><br><span class="line">[root@dev ~]<span class="meta"># ulimit -a</span></span><br><span class="line">#... 省略</span><br><span class="line"><span class="function"><span class="built_in">open</span> <span class="title">files</span>                      <span class="params">(-n)</span> 10032</span></span><br></pre></td></tr></table></figure><p> 2）、修改 TCP backlog：redis 默认的 tcp-backlog 为 511，可通过配置 tcp-backlog 进行调整，如果 Linux 的 tcp-backlog 小于 redis 的 tcp-backlog，日志里会出有 warning。此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须小于或等于 Linux 系统定义的 [/proc/sys/net/core/somaxconn] 值，而 Linux 的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建议修改为 <span class="number">2048</span> 修改somaxconn</span><br><span class="line">#该内核参数默认值一般是<span class="number">128</span>，对于负载很大的服务程序来说大大的不够。一般会将它修改为<span class="number">2048</span>或者更大。</span><br><span class="line">echo <span class="number">2048</span> &gt; /proc/sys/net/core/somaxconn #但是这样系统重启后保存不了</span><br><span class="line"></span><br><span class="line">#持久化设置: 在 /etc/sysctl.conf 中添加如下:</span><br><span class="line"><span class="meta">#net.core.somaxconn = 2048</span></span><br><span class="line"></span><br><span class="line">#然后在终端中执行:sysctl -p</span><br></pre></td></tr></table></figure><p>【2】<strong>vm.overcommit_mermory</strong>：表示内核在分配内存时候做检查的方式。<br>  1）、redis 建议将 vm.overcommit_memory 设置为1，防止极端情况下 fork 出错。<br>  2）、vm.overcommit_memory 取值说明：Linux 对大多数申请内存的回复均为 YES，以运行更多程序，因为申请后并不是立马使用，该技术叫 vm.overcommit。<br>  ■  0：内核将检查是否有足够的内存，如果足够，申请通过，否则内存申请失败把错误返回给应用进程。<br>  ■  1：表示内核容许超量使用内存直到用完为止。<br>  ■  2：内存绝不过量使用内存，既系统整个内存空间不能超过 swap+50% 的 RAM[（random access memory）即随机存储内存 ]值，50% 是 overcommit_ratio 的默认值，支持修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.overcommit_memory=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p> 【3】<strong>swappiness 参数</strong>：</p><p>1）：swappiness 参数决定操作系统使用 swap 的倾向程度，取值范围是0~100，swappiness 的值越大，说明操作系统可能使用 swap 的概率越高，swappiness 值越低，表示操作系统更加倾向于使用物理内存。 </p><p>2）、建议 Linux3.5 以上设置为1，否则建议设置为0。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.swappiness=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p> 【4】<strong>Transparent Huge Pages</strong>：支持大内存分页（2MB）分配，默认开启，redis 建议关闭此功能。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig --add disable-transparent-hugepages</span><br></pre></td></tr></table></figure><p>【5】OOM killer：会在可用内存不足时选择性杀掉用户进程，OOM killer 会为每个用户进程设置一个权重，权重越大被 kill 的可能性越大。每个进程的权重放在 [/proc/{progress_id}/oom_adj]。对于 Redis 服务器来说，可以将所有 Redis 的 oom_adj 设置为最低值或者稍小的值，降低被 OOM killer 杀掉的概率。应该设置与进程有关，无法一次性设置。</p><h3 id="二、Redis-关键参数"><a href="#二、Redis-关键参数" class="headerlink" title="二、Redis 关键参数"></a><strong>二、Redis 关键参数</strong></h3><p><strong>【1】客户端最大连接数（maxclients）：</strong></p><p>  1）、现象：如果连接数不够，或者请求返回比较慢导致连接数不足，可能会报[ max number of clients reached ]。</p><p>  2）、优化：调整 maxclients，或者优化 redis 命令处理性能。要注意该参数受到操作系统最大文件句柄的限制（ulimit -n <n>）</n></p><p><strong>【2】repl-ping-slave-period/repl-timeout：</strong></p><p>1）、说明：slave 会每隔 repl-ping-slave-period（默认10秒）ping 一次 master，如果查过 repl-timeout（默认 60秒）都没有收到响应，就会认为 Master 挂掉。</p><p>2）、优化：如果 Master 明明没挂掉但被阻塞住了也会报这个错。可以适当调大 repl-timeout</p><p> <strong>【3】client-output-buffer-limit：</strong></p><p>  1）说明：客户端输出缓冲区大小。</p><p>  2）、当使用主从复制时，性能压测下，数据量会急剧增长，导致从节点需要复制的数据很大，消耗时长增加。slave 没挂但被阻塞住了，比如正在 loading Master 发过来的 RDB，Master 的指令不能立刻发送给 slave，就会放在 output-buffer 中，在配置文件中有如下配置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-<span class="built_in">buffer</span>-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br></pre></td></tr></table></figure><p>上述配置说明：负责发送给 slave的 client，如果 buffer 超过 256m 或者连续 60秒超过 64m，就会被立刻强行关闭。所以此时应该相应调大数值，否则就会出现很悲剧的循环：Master 传输一个很大的 RDB 给 slave，slave 努力地装载，但是还没装载完，Master 对 client 的缓存存满了，关闭后再来一次。</p><h3 id="三、Redis-性能测试"><a href="#三、Redis-性能测试" class="headerlink" title="三、Redis 性能测试"></a><strong>三、Redis 性能测试</strong></h3><p> Redis 官网自动 Redis 性能测试工具 <strong>Redis-benchmark</strong>，可以有效的测试 Redis 服务的性能。 </p><p> 【1】案例一：命令如下，100个并发连接，100000个请求，检测host为127.0.0.1 端口为 6379 的 redis 服务器性能 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> -c <span class="number">100</span> -n <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">#对集合写入测试 结果如下</span><br><span class="line"><span class="number">100000</span> requests completed in <span class="number">2.38</span> seconds #<span class="number">100000</span>个请求在<span class="number">2.38</span>秒内完成</span><br><span class="line"><span class="number">20</span> parallel clients  #每次请求有<span class="number">20</span>个并发客户端</span><br><span class="line"><span class="number">3</span> bytes payload  #每次写入<span class="number">3</span>个字节的数据</span><br><span class="line">keep alive: <span class="number">1</span>  #保持一个连接，一台服务器来处理这些请求</span><br><span class="line"></span><br><span class="line"><span class="number">93.06</span>% &lt;= <span class="number">15</span> milliseconds</span><br><span class="line"><span class="number">99.96</span>% &lt;= <span class="number">31</span> milliseconds</span><br><span class="line"><span class="number">99.98</span>% &lt;= <span class="number">46</span> milliseconds</span><br><span class="line"><span class="number">99.99</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line"><span class="number">100.00</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line">#所有请求在<span class="number">62</span>毫秒内完成</span><br><span class="line"><span class="number">42105.26</span> requests per second</span><br><span class="line">#每秒处理<span class="number">42105.26</span>次请求</span><br></pre></td></tr></table></figure><p> 【2】案例二：命令如下，测试指定操作命令的性能。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -t <span class="built_in">set</span>,lpush -n <span class="number">100000</span> -q</span><br></pre></td></tr></table></figure><h3 id="四、查找慢查询语句"><a href="#四、查找慢查询语句" class="headerlink" title="四、查找慢查询语句"></a><strong>四、查找慢查询语句</strong></h3><p> Redis 提供了记录耗时操作语句的功能，当语句执行（不包括命令排队时间）超过了阈值，则被认为是慢查询。 </p><p>【1】参数设置：[ slowlog-log-slower-than ]：记录运行耗时语句的阈值，单位是微妙（1秒=1000毫秒=1000 000微妙，默认值：10000）。当值为0时，记录所有请求。当值&lt;0时，不记录任何请求。</p><p> [ slowlog-max-len ]：该参数用于设置慢查询保存的条数。</p><p>【2】功能使用：[ slowlog get ]：用于查询慢查询信息。[ slowlog len ]：显示当前 redis 有多少条慢查询</p><h2 id="十九、Reids-的主从复制机制原理"><a href="#十九、Reids-的主从复制机制原理" class="headerlink" title="十九、Reids 的主从复制机制原理"></a><strong>十九、Reids 的主从复制机制原理</strong></h2><h3 id="一、Redis-复制"><a href="#一、Redis-复制" class="headerlink" title="一、Redis 复制"></a><strong>一、Redis 复制</strong></h3><p> <strong>复制（Replication）</strong>：是 Redis 实现高可用的基础。且在复制过程中，主节点/从节点都是非阻塞的，但是从节点在执行同步时使用的是旧数据集提供查询。 </p><p> Redis 复制启动图与流程说明： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache7.png" alt></p><p>1）、当从节点连接到主节点时，会发送 psync 命令给主节点，runId 是主节点的 ID，如果没有默认是 -1；offset 是从节点保存复制偏移量，主节点根据复制偏移量仅发送从节点所需的增量部分，如果是第一次复制则为 -1；</p><p>2）、如果主节点回复 <strong>+FULLRESYNC</strong>，那么从节点将触发全量复制流程。</p><p>3）、如果主节点回复 <strong>+CONTINUE</strong>，那么从节点触发部分复制。</p><p>4）、如果主节点回复 <strong>+ERR</strong>，说名主节点不支持该命令。</p><h3 id="二、Redis-主从全量复制"><a href="#二、Redis-主从全量复制" class="headerlink" title="二、Redis 主从全量复制"></a><strong>二、Redis 主从全量复制</strong></h3><p> <strong>主从复制：</strong>主机数据更新后根据配置和策略，自动同步到备机的 master/slaver 机制，Master以写为主，Slave以读为主。 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache8.png" alt></p><h3 id="三、Redis-主从部分复制"><a href="#三、Redis-主从部分复制" class="headerlink" title="三、Redis 主从部分复制"></a><strong>三、Redis 主从部分复制</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache9.png" alt></p><h3 id="四、Redis-主从搭建"><a href="#四、Redis-主从搭建" class="headerlink" title="四、Redis 主从搭建"></a><strong>四、Redis 主从搭建</strong></h3><p> 【1】修改主节点 redis.conf 文件：使用[./redis-server redis.conf]启动主节点。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">Port <span class="number">7000</span></span><br><span class="line"></span><br><span class="line">#是否开启保护模式，默认为 yes 是开启。要是配置里没有指定 bind 和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。</span><br><span class="line">#要是开启了密码和 bind，可以开启。否则最好关闭，设置为no。</span><br><span class="line"><span class="keyword">protected</span>-mode no </span><br><span class="line">#修改 redis 安全密码</span><br><span class="line">requirepass <span class="string">"123456789"</span></span><br><span class="line"></span><br><span class="line">master 设置密码</span><br><span class="line"></span><br><span class="line">masterauth <span class="string">"123456789"</span></span><br><span class="line">#开启appendonly 模式后,redis 将每一次写操作请求都追加到appendonly.aof 文件中</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>  【2】新建从节点并配置复制主节点信息（配从(库)不配主(库)）每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 info replication（Redis Sentinel 还使用该信息来发现 slave 实例） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#slaveof 主库IP 主库端口</span></span><br><span class="line"></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><p><strong>【3】Redis 主/从复制注意点：</strong></p><p>1）、主/从节点应启用持久化：master 和 slave 中应启用持久化。当由于性能要求不能启用持久化时，应配置实例避免自动重启，因为主节点未持久化又重启时，内存数据为空，会导致从节点同步主节点空数据。<br> 2）、从节点应配置只读属性：主从复制中，从节点应配置只读属性[replica-read-only yes]。<br> 3）、从节点应配置对主节点的验证：主节点通过 requirepass 配置了密码时，从节点应使用[masterauth <password>]配置对主节点的访问密码。<br> 4）、主节点配置写查询接收条件：为了尽量保证主从一致性，主节点应配置当至少有 N 个 slave，并且滞后小于 M 秒时，才接收客户端写入命令[min-slaves-to-write &lt;slave 数量&gt; min-slaves-max-lag &lt;秒数&gt;]</password></p><h3 id="五、主从复制常用3招"><a href="#五、主从复制常用3招" class="headerlink" title="五、主从复制常用3招"></a><strong>五、主从复制常用3招</strong></h3><ol><li>一主二仆： 一个 Master 两个 Slave； </li><li>薪火相传：上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master，可以有效减轻 Master 的写压力。中途变更转向会清除之前的数据，重新建立拷贝最新的slaveof 新主库IP 新主库端口；</li><li>反客为主：SLAVEOF NO ONE。使当前数据库停止与其他数据库的同步，转成主数据库 </li></ol><h3 id="六、主从复制原理"><a href="#六、主从复制原理" class="headerlink" title="六、主从复制原理"></a><strong>六、主从复制原理</strong></h3><p> 【1】slave 启动成功连接到 master 后会发送一个 sync 命令。 </p><p> 【2】Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，以完成一次完全同步。 </p><p> 【3】全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。 </p><p> 【4】增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步。 </p><p> 【5】但是只要是重新连接 master，一次完全同步（全量复制)将被自动执行。 </p><p> <strong>复制的缺点：</strong>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。 </p><h2 id="二十、Redis-的线程模型是什么"><a href="#二十、Redis-的线程模型是什么" class="headerlink" title="二十、Redis 的线程模型是什么"></a><strong>二十、Redis 的线程模型是什么</strong></h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h3><p>【1】、Redis 是基于 Reactor 模式开发的网络事件处理器：这个处理器被称为文件事件处理器（file event handler），这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型：</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）机制监听多个套接字 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</li><li>当被监听的套接字准备好执行连接<strong>应答（accept）、读取（read）、写入（write）、关闭（close）</strong>等操作时。与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>【2】、虽然文件事件处理器以单线程的方式运行，但其使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><h3 id="二、文件事件处理器的结构"><a href="#二、文件事件处理器的结构" class="headerlink" title="二、文件事件处理器的结构"></a><strong>二、文件事件处理器的结构</strong></h3><p> 【1】、文件事件处理器的结构包含 4 个部分：</p><p>  ● 多个 socket</p><p>  ● IO 多路复用程序</p><p>  ● 文件事件分派器</p><p>  ● 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache10.png" alt></p><p>【2】、多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。<strong>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字，</strong> 如图：<br> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache11.png" alt></p><p> 文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。 </p><p>【3】、<strong>I/O 多路复用程序的实现</strong>：Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库来实现的， 每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件， 比如 ae_select.c 、 ae_epoll.c 、 ae_kqueue.c ， 诸如此类。因为 Redis 为每个 I/O 多路复用函数库都实现了相同的 API ， 所以 I/O 多路复用程序的底层实现是可以互换的， 如下图所示：</p><p> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache12.png" alt></p><p> Redis 在 I/O 多路复用程序的实现源码中用 <code>#include</code> 宏定义了相应的规则， 程序会在编译时自动选择系统中性能最高的 I/O 多路复用函数库来作为 Redis 的 I/O 多路复用程序的底层实现： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 包括此系统支持的最佳复用层</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下应按性能降序排列。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>【4】、<strong>事件的类型</strong>：I/O 多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件， 这两类事件和套接字操作之间的对应关系如下：<br>   ■  当套接字变得可读时（客户端对套接字执行 write 操作，或者执行 close 操作）， 或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 操作）， 套接字产生 AE_READABLE 事件。<br>   ■  当套接字变得可写时（客户端对套接字执行 read 操作）， 套接字产生 AE_WRITABLE 事件。</p><p><strong>I/O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 AE_READABLE 事件， 等到 AE_READABLE 事件处理完之后， 才处理 AE_WRITABLE 事件。这也就是说， 如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</strong><br> 【5】、API：ae.c/aeCreateFileEvent 函数接受一个套接字描述符、 一个事件类型、 以及一个事件处理器作为参数， 将给定套接字的给定事件加入到 I/O 多路复用程序的监听范围之内， 并对事件和事件处理器进行关联。</p><p>ae.c/aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参数， 让 I/O 多路复用程序取消对给定套接字的给定事件的监听， 并取消事件和事件处理器之间的关联。</p><p>ae.c/aeGetFileEvents 函数接受一个套接字描述符， 返回该套接字正在被监听的事件类型：</p><p>如果套接字没有任何事件被监听， 那么函数返回 AE_NONE 。<br>如果套接字的读事件正在被监听， 那么函数返回 AE_READABLE 。<br>如果套接字的写事件正在被监听， 那么函数返回 AE_WRITABLE 。<br>如果套接字的读事件和写事件正在被监听， 那么函数返回 AE_READABLE | AE_WRITABLE 。<br>ae.c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数， 在给定的时间内阻塞并等待套接字的给定类型事件产生， 当事件成功产生， 或者等待超时之后， 函数返回。</p><p>ae.c/aeApiPoll 函数接受一个 sys/time.h/struct timeval 结构为参数， 并在指定的时间內， 阻塞并等待所有被 aeCreateFileEvent 函数设置为监听状态的套接字产生文件事件， 当有至少一个事件产生， 或者等待超时后， 函数返回。</p><p>ae.c/aeProcessEvents 函数是文件事件分派器， 它先调用 aeApiPoll 函数来等待事件产生， 然后遍历所有已产生的事件， 并调用相应的事件处理器来处理这些事件。</p><p>ae.c/aeGetApiName 函数返回 I/O 多路复用程序底层所使用的 I/O 多路复用函数库的名称： 返回 “epoll” 表示底层为 epoll 函数库， 返回”select” 表示底层为 select 函数库， 诸如此类。</p><p> 【6】、<strong>文件事件的处理器</strong>：Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如：</p><p>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</p><p>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</p><p>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</p><p>当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。</p><p> <strong>在这些事件处理器里面， 服务器最常用的要数与客户端进行通信的连接应答处理器、 命令请求处理器和命令回复处理器。</strong> </p><p> 【7】、<strong>连接应答处理器</strong>：<code>networking.c/acceptTcpHandler</code> 函数是 Redis 的连接应答处理器， 这个处理器用于对连接服务器监听套接字的客户端进行应答， 具体实现为<code>sys/socket.h/accept</code> 函数的包装。 </p><p>当 Redis 服务器进行初始化的时候， 程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来， 当有客户端用sys/socket.h/connect 函数连接服务器监听套接字的时候， 套接字就会产生 AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作， 如图 IMAGE_SERVER_ACCEPT_CONNECT 所示。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache13.png" alt></p><p>【8】、<strong>命令请求处理器</strong>：networking.c/readQueryFromClient 函数是 Redis 的命令请求处理器， 这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为 unistd.h/read 函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来， 当客户端向服务器发送命令请求的时候， 套接字就会产生 AE_READABLE 事件， 引发命令请求处理器执行， 并执行相应的套接字读入操作， 如图 IMAGE_SERVER_RECIVE_COMMAND_REQUEST 所示。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache14.png" alt></p><p> 当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 <code>AE_WRITABLE</code> 事件之间的关联 </p><h3 id="三、客户端与-redis-的一次通信过程"><a href="#三、客户端与-redis-的一次通信过程" class="headerlink" title="三、客户端与 redis 的一次通信过程"></a><strong>三、客户端与 redis 的一次通信过程</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache15.png" alt></p><p>【1】客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p><p>【2】假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p><p>【3】如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。这样便完成了一次通信。</p><h3 id="四、为啥-redis-单线程模型也能效率这么高"><a href="#四、为啥-redis-单线程模型也能效率这么高" class="headerlink" title="四、为啥 redis 单线程模型也能效率这么高"></a><strong>四、为啥 redis 单线程模型也能效率这么高</strong></h3><p>■ 纯内存操作</p><p>■ 核心是基于非阻塞的 IO 多路复用机制</p><p>■ 单线程反而避免了多线程的频繁上下文切换问题 </p><h2 id="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"><a href="#二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点" class="headerlink" title="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"></a><strong>二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点</strong></h2><h3 id="为什么要有本地缓存？"><a href="#为什么要有本地缓存？" class="headerlink" title="为什么要有本地缓存？"></a>为什么要有本地缓存？</h3><p>在系统中，有些数据，数据量小，但是访问十分频繁（例如国家标准行政区域数据），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略。</p><h3 id="为什么是本地缓存，而不是分布式的集群缓存？"><a href="#为什么是本地缓存，而不是分布式的集群缓存？" class="headerlink" title="为什么是本地缓存，而不是分布式的集群缓存？"></a>为什么是本地缓存，而不是分布式的集群缓存？</h3><p>​     目前的数据，大多是业务无关的小数据缓存，没有必要搞分布式的集群缓存，目前涉及到订单和商品的数据，会直接走DB进行请求，再加上分布式缓存的构建，集群维护成本比较高，不太适合紧急的业务项目。</p><h3 id="本地缓存在那个区域？"><a href="#本地缓存在那个区域？" class="headerlink" title="本地缓存在那个区域？"></a>本地缓存在那个区域？</h3><p>​     目前考虑的是占用了JVM的heap区域，再细化一点的就是heap中的old区，目前的数据量来看，都是一些小数据，加起来没有几百兆，放在heap区域最快最方便。后期如果需要放置在本地缓存的数据大的时候，可以考虑在off-heap区域，但是off-heap区域的话，需要考虑对象的序列化（因为off-heap区域存储的是二进制的数据），另外一个的话就是off-heap的GC问题。其实，如果真的数据量比较大，那其实就可以考虑搞一个集中式的缓存系统，可以是单机，也可以是集群，来承担缓存的作用</p><h3 id="本地缓存和分布式缓存的比较："><a href="#本地缓存和分布式缓存的比较：" class="headerlink" title="本地缓存和分布式缓存的比较："></a>本地缓存和分布式缓存的比较：</h3><ul><li><p>分布式缓存一致性更好一点，本地缓存 每个实例都有自己的缓存，可能会存在不一致的情况。</p></li><li><p>本地缓存会占用堆内存，影响垃圾回收、影响系统性能。分布式缓存两大开销会导致其慢于本地缓存，网络延迟和对象序列化</p></li><li><p>进程内缓存适用于较小且频率可见的访问场景，尤其适用于不变对象，对于较大且不可预见的访问，最好采用分布式缓存。</p></li></ul><h2 id="二十二、本地缓存在并发使用时的注意事项"><a href="#二十二、本地缓存在并发使用时的注意事项" class="headerlink" title="二十二、本地缓存在并发使用时的注意事项"></a><strong>二十二、本地缓存在并发使用时的注意事项</strong></h2><p>使用本地缓存需要注意两个问题：</p><p>1 内存管理，及时解除无用对象的引用。防止大量无用对象进入old区，引发full gc。</p><p>2 数据同步，如果应用是一个集群，需要保持各台机器的数据一致性。</p><p>问题1的解决可以采用<strong>LRU算法</strong>( <strong><code>Least Recently Used</code></strong> )，预先定好缓存大小。达到最大值后，清除最近最少使用的对象。</p><p>问题2比较复杂，需要有一个集中的地方控制缓存一致，比如可以采用消息中间件，写时进行异步复制。这种方式成本较大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是缓存？&quot;&gt;&lt;a href=&quot;#一、什么是缓存？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是缓存？&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、什么是缓存？&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;缓存就是数据交换的缓冲区（称作：Cache），
      
    
    </summary>
    
    
    
      <category term="Redis相关" scheme="https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>hashCode和equals</title>
    <link href="https://liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/"/>
    <id>https://liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/</id>
    <published>2020-03-04T07:59:33.000Z</published>
    <updated>2020-03-04T08:05:09.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>用来判断两个对象是否相同，再Object类中是通过判断对象间的内存地址来决定是否相同 </p><p>equals() 方法用于比较两个对象是否相等，它与 == 相等比较符有着本质的不同。</p><p>在万物皆对象的 Java 体系中，系统把判断对象是否相等的权力交给程序员。具体的措施是把 equals() 方法写到 Object 类中，并让所有类继承 Object 类。 这样程序员就能在自定义的类中重写 equals() 方法, 从而实现自己的比较逻辑.</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p> 获取哈希码，也称为散列码，返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 </p><p>hashCode() 的意思是哈希值, 哈希值是经哈希函数运算后得到的结果，哈希函数能够保证相同的输入能够得到相同的输出(哈希值)，但是不能够保证不同的输入总是能得出不同的输出。</p><p>当输入的样本量足够大时，是会产生哈希冲突的，也就是说不同的输入产生了相同的输出。</p><p>暂且不谈冲突，就相同的输入能够产生相同的输出这点而言，是及其宝贵的。它使得系统只需要通过简单的运算，在时间复杂度O(1)的情况下就能得出数据的映射关系，根据这种特性，散列表应运而生。</p><p>一种主流的散列表实现是：用数组作为哈希函数的输出域，输入值经过哈希函数计算后得到哈希值。然后根据哈希值，在数组种找到对应的存储单元。当发生冲突时，对应的存储单元以链表的形式保存冲突的数据。</p><h1 id="hashCode-与-equals-之间的关系"><a href="#hashCode-与-equals-之间的关系" class="headerlink" title="hashCode() 与 equals() 之间的关系"></a>hashCode() 与 equals() 之间的关系</h1><p><img src="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/hashCode.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;equals&quot;&gt;&lt;a href=&quot;#equals&quot; class=&quot;headerlink&quot; title=&quot;equals()&quot;&gt;&lt;/a&gt;equals()&lt;/h2&gt;&lt;p&gt;用来判断两个对象是否相同，再Object类中是通过判断对象间的内存地址来决定是否相同 &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HashSet内部是如何工作的</title>
    <link href="https://liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-03-04T07:47:57.000Z</published>
    <updated>2020-03-04T07:56:17.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h2><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以HashSet中所有 key 的都有一个默认 value。类似于HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p><h2 id="HashSet："><a href="#HashSet：" class="headerlink" title="HashSet："></a>HashSet：</h2><ul><li>实现了Set接口</li><li>HashSet依赖的数据结构是哈希表</li><li>因为实现的是Set接口，所以不允许有重复的值</li><li>插入到HashSet中的对象不保证与插入的顺序保持一致。对象的插入是根据它的hashcode</li><li>HashSet中允许有NULL值</li><li>HashSet也实现了Searlizable和Cloneable两个接口</li></ul><h2 id="HashSet的构造函数："><a href="#HashSet的构造函数：" class="headerlink" title="HashSet的构造函数："></a>HashSet的构造函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h = <span class="keyword">new</span> HashSet();      </span><br><span class="line">默认初始化大小是<span class="number">16</span>，默认装载因子是<span class="number">0.75</span>.</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity);  </span><br><span class="line">默认装载因子是<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor);</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(Collection C);</span><br></pre></td></tr></table></figure><h2 id="什么是初始化大小与装载因子："><a href="#什么是初始化大小与装载因子：" class="headerlink" title="什么是初始化大小与装载因子："></a>什么是初始化大小与装载因子：</h2><p>初始化尺寸就是当创建哈希表（HashSet内部用哈希表的数据结构）的时候桶（buckets）的数量。如果当前的尺寸已经满了，那么桶的数量会自动增长。</p><p>装载因子衡量的是在HashSet自动增长之前允许有多满。当哈希表中实体的数量已经超出装载因子与当前容量的积，那么哈希表就会再次进行哈希（也就是内部数据结构重建），这样哈希表大致有两倍桶的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">                    表中已经存储的元素的数量</span><br><span class="line"></span><br><span class="line">装载因子 = *-----------------------------------------*</span><br><span class="line"></span><br><span class="line">                    哈希表的大小</span><br></pre></td></tr></table></figure><p> 例如：如果内部容量为16，装载因子为0.75，那么当表中有12个元素的时候，桶的数量就会自动增长。 </p><p>性能影响：</p><p>装载因子和初始化容量是影响HashSet操作的两个主要因素。装载因子为0.75的时候可以提供关于时间和空间复杂度方面更有效的性能。如果我们加大这个装载因子，那么内存的上限就会减小（因为它减少了内部重建的操作），但是将影响哈希表中的add与查询的操作。为了减少再哈希操作，我们应该选择一个合适的初始化大小。如果初始化容量大于实体的最大数量除以装载因子，那么就不会有再哈希的动作发生了。</p><p>HashSet中的一些重要方法：</p><ul><li>boolean add(E e)：如果不存在则添加，存在则返回false。</li><li>void clear() ：移除Set中所有的元素</li><li>boolean contains(Object o)：如果这个元素在set中存在，那么返回true。</li><li>boolean remove(Object o)：如果这个元素在set中存在，那么从set中删除。</li><li>Iterator iterator()：返回set中这个元素的迭代器。</li></ul><h2 id="HashSet内部是如何工作的？"><a href="#HashSet内部是如何工作的？" class="headerlink" title="HashSet内部是如何工作的？"></a>HashSet内部是如何工作的？</h2><p> 所有Set接口的类内部都是由Map做支撑的。HashSet用HashMap对它的内部对象进行排序。你一定好奇输入一个值到HashMap，我们需要的是一个键值对，但是我们传给HashSet的是一个值。 </p><p>那么HashMap是如何排序的？</p><p>实际上我们插入到HashSet中的值在map对象中起的是键的作用，因为它的值Java用了一个常量。所以在键值对中所有的键的值都是一样的。</p><p>如果我们在Java Doc中看一下HashSet的实现，大致是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 1</span></span><br><span class="line"><span class="comment">// All the constructors are internally creating HashMap Object.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p> 如果我们看下HashSet中的add方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以注意到，HashSet类的add()方法内部调用的是HashMap的put()方法，通过你指定的值作为key，常量“PRESENT”作为值传过去。 </p><p> remove()也是用类似的方法工作。它内部调用的是Map接口的remove。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet操作的时间复杂度：</p><p>HashSet底层的数据结构是哈希表，所以HashSet的add，remove与查询（包括contain方法）的分摊（平均或者一般情况）时间复杂度是O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-中的-HashSet，内部是如何工作的？&quot;&gt;&lt;a href=&quot;#Java-中的-HashSet，内部是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;Java 中的 HashSet，内部是如何工作的？&quot;&gt;&lt;/a&gt;Java 中的 Has
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="https://liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-04T07:30:28.000Z</published>
    <updated>2020-03-04T07:34:53.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：SUN提供的反射机制的类："><a href="#1：SUN提供的反射机制的类：" class="headerlink" title="1：SUN提供的反射机制的类："></a>1：SUN提供的反射机制的类：</h2><p>java.lang.Class<T></T></p><p>java.lang.reflect.Constructor<T></T></p><p>java.lang.reflect.Field</p><p>java.lang.reflect.Method</p><p>java.lang.reflect.Modifier</p><h2 id="2：什么是反射"><a href="#2：什么是反射" class="headerlink" title="2：什么是反射"></a>2：什么是反射</h2><p> JAVA反射机制是在运行状态中，对于任意一个类。都能都知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称之为java语言的反射机制； </p><h2 id="3：反射的作用"><a href="#3：反射的作用" class="headerlink" title="3：反射的作用"></a>3：反射的作用</h2><p>反编译 .class –à .java</p><p>通过反射机制可以访问java对象中的属性，方法，构造方法</p><h2 id="4：创建Class对象的三种方式"><a href="#4：创建Class对象的三种方式" class="headerlink" title="4：创建Class对象的三种方式"></a>4：创建Class对象的三种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">China</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">char</span> sex ;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span> ();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span> ();</span><br><span class="line">           <span class="keyword">this</span> .name = name;</span><br><span class="line">           <span class="keyword">this</span> .age = age;</span><br><span class="line">           <span class="keyword">this</span> .sex = sex;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> name ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .name = name;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> age ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .age = age;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sex ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .sex = sex;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System. out .println(<span class="string">"吃了"</span> );</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayChina</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">          System. out .println(<span class="string">"作者："</span> + AUTHOR + <span class="string">"国籍："</span>+ NATIONAL );</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">"姓名:"</span> + name + <span class="string">"年龄："</span>+ age + <span class="string">"性别:"</span> + sex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span> ,<span class="number">20</span>,<span class="string">'男'</span> );</span><br><span class="line">          Person p2 = <span class="keyword">new</span> Person(<span class="string">"小红"</span> ,<span class="number">23</span>,<span class="string">'女'</span> );</span><br><span class="line">    </span><br><span class="line">           <span class="comment">//创建Class对象的方式一：(对象.getClass())，获取person类中的字节码文件</span></span><br><span class="line">           Class class1 = p1.getClass();</span><br><span class="line">          System. out.println(p1.getClass().getName());</span><br><span class="line">           Class class2 = p2.getClass();</span><br><span class="line">          System. out.println(class1 == class2 );</span><br><span class="line">    </span><br><span class="line">          System. out.println(<span class="string">"=============================="</span> );</span><br><span class="line">           <span class="comment">//创建Class对象的方式二：(类.class:需要输入一个明确的类，任意一个类型都有一个静态的class属性)</span></span><br><span class="line">           Class class3 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">          System. out.println(class1 == class2);</span><br><span class="line">    </span><br><span class="line">          System. out.println(<span class="string">"=============================="</span> );</span><br><span class="line">           <span class="comment">//创建Class对象的方式三：(forName():传入时只需要以字符串的方式传入即可)</span></span><br><span class="line">           <span class="comment">//通过Class类的一个forName（String className)静态方法返回一个Class对象，className必须是全路径名称；</span></span><br><span class="line">           <span class="comment">//Class.forName()有异常：ClassNotFoundException</span></span><br><span class="line">    </span><br><span class="line">           Class class4 = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">              class4 = Class.forName(<span class="string">"cn.itcast.Person"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System. out.println(class4 == class3);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：在开发中一般使用第三种方法，因为第三种接收的是一个字符串路径，将来可以通过配置文件获取，通用性好； </p><p> 4：newInstance()方法 —&gt; 获取class类型之后,可以创建该类型的对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span><span class="keyword">throws</span> InstantiationException,IllegalAccessException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflect03</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class c1 = Class.forName(<span class="string">"com.itheima04.Test_20171106.Test_20171207.Person"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建此Class对象所表示类的一个新实例,</span></span><br><span class="line">    <span class="comment">//newInstance方法调用的是Person的空参数构造方法</span></span><br><span class="line">    Object o = c1.newInstance();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：SUN提供的反射机制的类：&quot;&gt;&lt;a href=&quot;#1：SUN提供的反射机制的类：&quot; class=&quot;headerlink&quot; title=&quot;1：SUN提供的反射机制的类：&quot;&gt;&lt;/a&gt;1：SUN提供的反射机制的类：&lt;/h2&gt;&lt;p&gt;java.lang.Class&lt;T&gt;
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Map类</title>
    <link href="https://liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/"/>
    <id>https://liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/</id>
    <published>2020-03-04T06:02:37.000Z</published>
    <updated>2020-03-04T07:21:15.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map.png" alt></p><p> 下面针对各个实现类的特点做一些说明： </p><p> (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 </p><p> (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 </p><p> (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><p> 4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 </p><p> 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 </p><p> 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 </p><h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p> 搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 </p><h2 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h2><p> 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map1.png" alt></p><p> 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ </p><p> (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 </p><p> (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p> 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 </p><p> 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 </p><p> 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line">   <span class="keyword">int</span> modCount;  </span><br><span class="line">   <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p> 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 </p><p> 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 </p><p> size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 </p><p> 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/liuqiyao_01/article/details/14475159">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 </p><p> 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/v_july_v/article/details/6105630">http://blog.csdn.net/v_july_v/article/details/6105630</a>。 </p><h2 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h2><p> HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 </p><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><p> 不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。 </p><p> 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 </p><p> 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 </p><p> 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 </p><p> 下面举例说明下，n为table的长度。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map2.png" alt></p><h3 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h3><p> HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map3.png" alt></p><p> ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； </p><p> ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； </p><p> ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； </p><p> ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； </p><p> ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </p><p> ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 </p><p> JDK1.8HashMap的put方法源码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                   <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                          <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p> 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 </p><p> 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 </p><p> 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map4.png" alt></p><p> 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map5.png" alt></p><p> 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map6.png" alt></p><p> 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map7.png" alt></p><p> 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p> 在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map8.png" alt></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map9.png" alt></p><p> e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map10.png" alt></p><p> 于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 </p><h1 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h1><p> HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 </p><h2 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h2><p>为了便于测试，我们先写一个类Key，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Key(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Key key = (Key) o;</span><br><span class="line">        <span class="keyword">return</span> value == key.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</span><br><span class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</span><br><span class="line">           map.put(Keys.of(i), i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</span><br><span class="line">           map.get(Keys.of(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">       System.out.println(endTime - beginTime);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</span><br><span class="line">           test(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map11.png" alt></p><p> 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 </p><h2 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h2><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 仍然执行main方法，得出的结果如下表所示： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map12.png" alt></p><p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p><p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数组和链表数据结构描述，各自的时间复杂度</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-03-04T05:55:00.000Z</published>
    <updated>2020-03-04T05:57:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用"><a href="#两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用" class="headerlink" title="两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用"></a>两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用</h2><h2 id="一、各自的特点："><a href="#一、各自的特点：" class="headerlink" title="一、各自的特点："></a>一、各自的特点：</h2><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。</p><h2 id="二、数组和链表的区别："><a href="#二、数组和链表的区别：" class="headerlink" title="二、数组和链表的区别："></a>二、数组和链表的区别：</h2><p>1、从逻辑结构角度来看：</p><p>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。<br>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）<br>2、数组元素在栈区，链表元素在堆区；</p><p>3、从内存存储角度来看：</p><p>(静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。<br>链表从堆中分配空间, 自由度大但申请管理比较麻烦。<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot;&gt;&lt;a href=&quot;#两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot; class=&quot;headerlink&quot; title=&quot;两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java8的新特性</title>
    <link href="https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-03-04T04:33:02.000Z</published>
    <updated>2020-03-04T05:52:32.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a><strong>一、接口的默认方法</strong></h2><p> Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);   <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);      <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p> 首先看看在老版本的Java中是如何排列字符串的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： </p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a><strong>四、方法与构造函数引用</strong></h2><p> 前一节中的代码还可以通过静态方法引用来表示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p> Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure><p> 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String firstName;  </span><br><span class="line">  String lastName; </span><br><span class="line"></span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person(String firstName, String lastName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来我们指定一个用来创建Person对象的对象工厂接口： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure><p> 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 </p><h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a><strong>五、Lambda 作用域</strong></h2><p> 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 </p><h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a><strong>六、访问局部变量</strong></h2><p> 我们可以直接在lambda表达式中访问外层的局部变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> 在lambda表达式中试图修改num同样是不允许的。 </p><h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p> 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">   <span class="keyword">int</span> outerNum; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">      outerNum = <span class="number">23</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">      outerStaticNum = <span class="number">72</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p> 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure><p> JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 </p><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p> Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);       <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p> Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); </span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);   <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure><h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();  <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p> Consumer 接口表示执行在单个参数上的操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);       <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2); <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure><h3 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a>Optional 接口</h3><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();      <span class="comment">// true</span></span><br><span class="line">optional.get();         <span class="comment">// "bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);  <span class="comment">// "bam"</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));   <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure><p> Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： </p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a><strong>Filter 过滤</strong></h3><p> 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"></span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure><h3 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h3><p> 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .sorted()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure><p> 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p> 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p> Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>)); </span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a><strong>Count 计数</strong></h3><p> 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">    .count(); </span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce 规约"></a>Reduce 规约</h3><p> 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line"></span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure><h3 id="并行Streams"><a href="#并行Streams" class="headerlink" title="并行Streams"></a>并行Streams</h3><p> 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 </p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">  UUID uuid = UUID.randomUUID();</span><br><span class="line">  values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们计算一下排序这个Stream要耗时多久， </p><p> 串行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 串行耗时: 899 ms </p><p> 并行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 </p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><p> 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure><p> 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 </p><p> 下面的例子展示了map上的其他有用的函数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p> 接下来展示如何在Map里删除一个键值全都匹配的项： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// val33 </span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p> 另外一个有用的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>); <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9 </span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><p> Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 </p><h2 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a><strong>九、Date API</strong></h2><p> java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： </p><h3 id="Clock-时钟"><a href="#Clock-时钟" class="headerlink" title="Clock 时钟"></a><strong>Clock 时钟</strong></h3><p> Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = clock.millis(); </span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);  <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p> 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// prints all available timezone ids </span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime 本地时间"></a>LocalTime 本地时间</h3><p> LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line"></span><br><span class="line"> LocalTime now2 = LocalTime.now(zone2); </span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);    <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);   <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p> LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(late);    <span class="comment">// 23:59:59 </span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">  DateTimeFormatter</span><br><span class="line">    .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">    .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);  <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate 本地日期"></a><strong>LocalDate 本地日期</strong></h3><p> LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);  <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line"></span><br><span class="line">   DateTimeFormatter</span><br><span class="line">    .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">    .withLocale(Locale.GERMAN); </span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);  <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure><p>LocalDateTime 本地日期时间</p><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。</p><p>LocalDateTime提供了一些能访问具体字段的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);   <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);     <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);  <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure><p> 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">  .atZone(ZoneId.systemDefault())</span><br><span class="line">    .toInstant(); </span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);   <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure><p> 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =  DateTimeFormatter.ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>); </span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);   <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure><p> 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a> </p><h2 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a><strong>十、Annotation 注解</strong></h2><p> 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">  Hint[] value();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p><p> 例 1: 使用包装类当容器来存多个注解（老方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 例 2：使用多重注解（新方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hint);          <span class="comment">// null </span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hints</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotationsByType</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints2.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p> 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p> 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、接口的默认方法&quot;&gt;&lt;a href=&quot;#一、接口的默认方法&quot; class=&quot;headerlink&quot; title=&quot;一、接口的默认方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、接口的默认方法&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; Java 8允许我们给接口添加一个非抽象的方法实
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>动态代理与cglib实现的区别</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-04T03:54:58.000Z</published>
    <updated>2020-03-04T04:06:13.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ol><li>Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷；</li><li>Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上；</li><li>Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来。</li><li>InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul><li>JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。</li><li>JDK动态代理的基础是反射机制（method.invoke(对象，参数)）Proxy.newProxyInstance()</li></ul><h3 id="jdk动态代理代码"><a href="#jdk动态代理代码" class="headerlink" title="jdk动态代理代码"></a><strong>jdk动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line">      <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.得到目标对象的类加载器</span></span><br><span class="line">        ClassLoader classLoader = target.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 2.得到目标对象的实现接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 3.第三个参数需要一个实现invocationHandler接口的对象</span></span><br><span class="line">        Object newProxyInstance = Proxy.newProxyInstance(classLoader, interfaces, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数:代理对象.一般不使用;第二个参数:需要增强的方法;第三个参数:方法中的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        JDKProxyFactory proxy = <span class="keyword">new</span> JDKProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​        原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意</strong>:</h3><p>​        jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。 </p><h3 id="cglib动态代理代码"><a href="#cglib动态代理代码" class="headerlink" title="cglib动态代理代码"></a><strong>cglib动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123; </span><br><span class="line">      <span class="comment">//得到目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法传递目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.传递目标对象的class</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调操作</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数一:代理对象;参数二:需要增强的方法;参数三:需要增强方法的参数;参数四:需要增强的方法的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = methodProxy.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        CglibProxyFactory proxy = <span class="keyword">new</span> CglibProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-04T02:29:37.000Z</published>
    <updated>2020-03-04T03:51:24.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、单例模式："><a href="#1、单例模式：" class="headerlink" title="1、单例模式："></a>1、单例模式：</h1><p>在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式</p><h1 id="2、单例模式的设计原则："><a href="#2、单例模式的设计原则：" class="headerlink" title="2、单例模式的设计原则："></a>2、单例模式的设计原则：</h1><p>1、构造方法私有化<br>2、在类中创建好该类对象<br>3、在类中，给外界提供获取该对象的公有方式 </p><h2 id="2-1饿汉式"><a href="#2-1饿汉式" class="headerlink" title="2.1饿汉式"></a>2.1饿汉式</h2><p>在加载类的同时，就要初始化静态成员变量，所以就同时将该类对象创建出来了<br>饿汉式：一有机会，马上就吃，不去等待。（一旦加载类型，马上创建对象） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例设计模式之饿汉式</span></span><br><span class="line"><span class="comment">//能多早创建对象就多早创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_SingtonleHunger</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SingtonHunger sh1 = SingtonHunger.getInstance();</span><br><span class="line">SingtonHunger sh2 = SingtonHunger.getInstance();</span><br><span class="line">System.out.println(sh1==sh2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonHunger</span></span>&#123;</span><br><span class="line"><span class="comment">//1.先私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonHunger</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2.私有创建对象的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonHunger sh = <span class="keyword">new</span> SingtonHunger();</span><br><span class="line"><span class="comment">//3.通过创建对外界可见的方法来调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonHunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。 </p><h2 id="2-2懒汉式"><a href="#2-2懒汉式" class="headerlink" title="2.2懒汉式"></a>2.2懒汉式</h2><p>在加载类的时候，不同时创建该类对象，等到需要获取这个对象时，才去创建这个对象<br>懒汉式：不着急、能不创建的时候，就不创建，能拖就拖 </p><p>注意事项：<br>1、只有在sl == null的时候，才会创建对象<br>2、sl的判断和sl的赋值，不希望分离开，否则在多线程环境下，会出现多个对象的状态，所以sl的判断和sl的赋值，需要放到一个同步代码块中。<br>3、同步代码块的效率非常低，不是每次获取对象的时候，都需要判断锁对象，只有在sl为null的时候， 才应该判断锁对象，因此在外层需要嵌套一个if判断，判断sl是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式之懒汉式</span></span><br><span class="line"><span class="comment">//能多晚创建对象就多晚创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_SingletonLazy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SingtonLazy sl1 = SingtonLazy.getInstance();</span><br><span class="line">SingtonLazy sl2 = SingtonLazy.getInstance();</span><br><span class="line">System.out.println(sl1==sl2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonLazy</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.私有创建对象的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonLazy sl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供对外公开的方法创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//最外层判断是否为空用来提高效率</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SingtonLazy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">//加上同步锁提高线程安全</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line">sl = <span class="keyword">new</span> SingtonLazy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种懒汉式</p><p>public class SingletonDemo2 {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法同步，调用效率低</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">        instance=<span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种如果是多线程的，会有JVM 指令重排的机制，破坏其单例类，所以双重锁判断机制好一些</p><h2 id="2-3静态内部类实现"><a href="#2-3静态内部类实现" class="headerlink" title="2.3静态内部类实现"></a>2.3静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo3 instance=<span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4枚举类"><a href="#2-4枚举类" class="headerlink" title="2.4枚举类"></a>2.4枚举类</h2><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo4 &#123;</span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、单例模式：&quot;&gt;&lt;a href=&quot;#1、单例模式：&quot; class=&quot;headerlink&quot; title=&quot;1、单例模式：&quot;&gt;&lt;/a&gt;1、单例模式：&lt;/h1&gt;&lt;p&gt;在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式&lt;/p&gt;
&lt;h1 id=&quot;2、单
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-03-04T02:01:02.000Z</published>
    <updated>2020-03-04T02:20:23.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。<br> 比如说对象 A 和对象 B，二者都是 ClassC 的对象，具有成员变量 a 和 b，现在对对象 A 进行拷贝赋值给 B，也就是 B.a = A.a; B.b = A.b;</p><p>这时再去改变 B 的属性 a 或者 b 时，可能会遇到问题：假设 a 是基础数据类型，b 是引用类型。<br> 当改变 B.a 的值时，没有问题；<br> 当改变 B.b 的值时，同时也会改变 A.b 的值，因为其实上面的例子中只是把 A.b 赋值给了 B.b，因为是 b 引用类型的，所以它们是指向同一个地址的。这可能就会给我们使用埋下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。</span><br></pre></td></tr></table></figure><h1 id="拷贝分类"><a href="#拷贝分类" class="headerlink" title="拷贝分类"></a>拷贝分类</h1><p>上面的问题，其实就是因为对拷贝的不熟悉导致的。</p><p>根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种：</p><ul><li>浅拷贝 (<code>Shallow Copy</code>)</li><li>深拷贝 (<code>Deep Copy</code>)</li></ul><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="1-浅拷贝介绍"><a href="#1-浅拷贝介绍" class="headerlink" title="1. 浅拷贝介绍"></a>1. 浅拷贝介绍</h2><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h2 id="2-浅拷贝特点"><a href="#2-浅拷贝特点" class="headerlink" title="2. 浅拷贝特点"></a>2. 浅拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。<br> (2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy.png" alt></p><h2 id="3-浅拷贝的实现"><a href="#3-浅拷贝的实现" class="headerlink" title="3. 浅拷贝的实现"></a>3. 浅拷贝的实现</h2><p>实现对象拷贝的类，需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br></pre></td></tr></table></figure><p>输出的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:lishi],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject[Subject:<span class="number">1163157884</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="1-深拷贝介绍"><a href="#1-深拷贝介绍" class="headerlink" title="1. 深拷贝介绍"></a>1. 深拷贝介绍</h2><p>通过上面的例子可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 <code>studentB</code> 的 <code>subject</code>，但是 <code>studentA</code> 的 <code>subject</code> 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></pre></td></tr></table></figure><h2 id="2-深拷贝特点"><a href="#2-深拷贝特点" class="headerlink" title="2. 深拷贝特点"></a>2. 深拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。<br> (2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。<br> (3) 对于有多层对象的，每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。<br> (4) 深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy2.png" alt></p><h2 id="3-深拷贝的实现"><a href="#3-深拷贝的实现" class="headerlink" title="3. 深拷贝的实现"></a>3. 深拷贝的实现</h2><p>对于 <code>Student</code> 的引用类型的成员变量 <code>Subject</code> ，需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>Student</code> 的 <code>clone()</code> 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.subject = (Subject) subject.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一样的使用方式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:yuwen],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject:[Subject:<span class="number">356573597</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p> 由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。&lt;br&gt; 比如说对象 A 和对象 B，二者都是 ClassC 的
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java内存溢出</title>
    <link href="https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2020-03-02T02:16:07.000Z</published>
    <updated>2020-03-02T02:56:53.160Z</updated>
    
    <content type="html"><![CDATA[<p>–本文源自于《深入理解Java虚拟机》</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>​        Java堆用于储存对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象到达最大堆的容量之后，就会产生内存溢出异常。</p><p>java.lang.OutOfMem0ryError:Java  heap space</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Vm Args:-Xms20m XMx20m -XX:+HeapDumpOnOUtOFMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">aList.add(<span class="string">"asdasdasdas"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">System.out.println(aList.size());</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决手段："><a href="#解决手段：" class="headerlink" title="解决手段："></a>解决手段：</h3><p>​        先通过内存映像分析工具（如：Eclipse Memory Analyzer）堆Dump出来的堆转储快照进行分析，重点确认内存中的对象是否是必要的，也就是药神分清楚到底是出现了内存泄漏还是内存溢出。</p><p>​        如果是内存泄漏，可以进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾回收器无法自动回收他们的。掌握了泄漏对象的类型信息，及GCRoots引用链的信息，就可以比较准确的定位出泄漏代码的 位置。</p><p>​        如果不是泄漏，就是在内存中对象还活着，应当检查虚拟机的堆参数（-Xmx与Xms）</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>​        Java虚拟机规范中描述了两种异常</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(i++);</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JvmTest j = <span class="keyword">new</span> JvmTest();</span><br><span class="line">j.a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>–待补</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>–待补</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;–本文源自于《深入理解Java虚拟机》&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://liudong-code.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>throw和throws的区别</title>
    <link href="https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-29T11:12:48.000Z</published>
    <updated>2020-02-29T11:18:05.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>抛出异常有三种形式</strong></p><ul><li>throw</li><li>throws</li><li>系统自动抛异常</li></ul><p><strong>一、系统自动抛异常</strong></p><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常：（举个栗子）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>; </span><br><span class="line">    System.out.println(<span class="number">5</span>/b);   <span class="comment">// 此处系统会自动抛出ArithmeticException异常</span></span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、throw</strong></p><p>throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>运行时，系统会抛出如下异常：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NumberFormatException at......</span><br></pre></td></tr></table></figure><p><strong>三、throws</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当某个方法可能会抛出某种异常时用于<span class="keyword">throws</span> 声明可能抛出的异常，然后交给上层调用它的方法程序处理</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">testThrows</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123; </span><br><span class="line">String s = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(Double.parseDouble(s)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">function(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; </span><br><span class="line">System.err.println(<span class="string">"非数据类型不能强制类型转换。"</span>); </span><br><span class="line"><span class="comment">//e.printStackTrace(); </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 四、throw与throws的比较</p><p>throws出现在方法函数头；而throw出现在函数体。<br>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p><p>五、编程习惯：</p><p>在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；<br>用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();<br>如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；<br>如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理</p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;抛出异常有三种形式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;throw&lt;/li&gt;
&lt;li&gt;throws&lt;/li&gt;
&lt;li&gt;系统自动抛异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一、系统自动抛异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当程序语句出现一些逻
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java中的异常链</title>
    <link href="https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/"/>
    <id>https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/</id>
    <published>2020-02-29T11:07:08.000Z</published>
    <updated>2020-02-29T11:11:28.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   ChainTest ct=<span class="keyword">new</span> ChainTest();<span class="comment">//创建chainTest实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     ct.test2();    </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span><span class="keyword">throws</span> DrunkException</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> DrunkException(<span class="string">"喝车别开酒"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     test1();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (DrunkException e)&#123;</span><br><span class="line"></span><br><span class="line">       RuntimeException newExc=<span class="keyword">new</span> RuntimeException(<span class="string">"司机一滴酒亲人两行泪"</span>)；<span class="comment">//含参构造器  </span></span><br><span class="line"></span><br><span class="line">       newExc.initCause(e);<span class="comment">//调用newExc的init方法，把捕获的DrunkException传进去</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> newExc;<span class="comment">//抛出新异常</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 &lt;
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java的异常体系</title>
    <link href="https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2020-02-29T10:54:18.000Z</published>
    <updated>2020-02-29T11:20:57.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java中异常的体系结构图解："><a href="#java中异常的体系结构图解：" class="headerlink" title="java中异常的体系结构图解："></a>java中异常的体系结构图解：</h3><p><img src="/liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/yichang.png" alt></p><p>​        java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。 </p><h3 id="java异常体系结构"><a href="#java异常体系结构" class="headerlink" title="java异常体系结构"></a><strong>java异常体系结构</strong></h3><p>​        Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p><p>1、Error与Exception<br>         Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<br>         Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<br>2、运行时异常和非运行时异常<br>         运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>         非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a><strong>异常的捕获和处理</strong></h3><h4 id="try、catch、finally"><a href="#try、catch、finally" class="headerlink" title="try、catch、finally"></a>try、catch、finally</h4><p>  第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。<br>  第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。<br>  第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。<br>   第四：先Catch子类异常再Catch父类异常。 </p><h4 id="throw、throws关键字"><a href="#throw、throws关键字" class="headerlink" title="throw、throws关键字"></a>throw、throws关键字</h4><pre><code>throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方</code></pre><p>法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取</p><p>的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span>&#123;  </span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"方法test中的Exception"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java中异常的体系结构图解：&quot;&gt;&lt;a href=&quot;#java中异常的体系结构图解：&quot; class=&quot;headerlink&quot; title=&quot;java中异常的体系结构图解：&quot;&gt;&lt;/a&gt;java中异常的体系结构图解：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/liudong
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何格式化日期</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/</id>
    <published>2020-02-29T10:42:07.000Z</published>
    <updated>2020-02-29T11:24:29.516Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String date = localDate.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(<span class="string">"date:"</span>+date)；</span><br></pre></td></tr></table></figure><p> 补充:java的时间日期API一直以来都是被诟病的东西,为了解决这一问题,java8中引入了新的时间日期API,其中包括LocalDate,LocalTime,LocalDate,LocalDateTime,Clock,Instant等类,这些的类的设计都使用了不变模式,因此是线程安全的设计.</p><p>原文链接：<a href="https://blog.csdn.net/riju4713/article/details/88220120" target="_blank" rel="noopener">https://blog.csdn.net/riju4713/article/details/88220120</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/</id>
    <published>2020-02-29T10:35:58.000Z</published>
    <updated>2020-02-29T10:38:33.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可以被继承，代码如下"><a href="#可以被继承，代码如下" class="headerlink" title="可以被继承，代码如下"></a>可以被继承，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span></span>&#123;</span><br><span class="line"><span class="comment">//空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line">oneFn</span><br><span class="line">One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br><span class="line">one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br></pre></td></tr></table></figure><h3 id="不能被重写，代码如下"><a href="#不能被重写，代码如下" class="headerlink" title="不能被重写，代码如下"></a>不能被重写，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被重写？以及原因？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"two"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"TwoFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line"><span class="comment">//oneFn</span></span><br><span class="line"><span class="comment">//One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br><span class="line"><span class="comment">//one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。</p><p>注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可以被继承，代码如下&quot;&gt;&lt;a href=&quot;#可以被继承，代码如下&quot; class=&quot;headerlink&quot; title=&quot;可以被继承，代码如下&quot;&gt;&lt;/a&gt;可以被继承，代码如下&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
