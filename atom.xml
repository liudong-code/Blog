<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>code</title>
  
  <subtitle>码总</subtitle>
  <link href="/liudong-code.github.io/atom.xml" rel="self"/>
  
  <link href="https://liudong-code.github.io/"/>
  <updated>2020-03-06T09:08:44.395Z</updated>
  <id>https://liudong-code.github.io/</id>
  
  <author>
    <name>Liu Dong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓存</title>
    <link href="https://liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/"/>
    <id>https://liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/</id>
    <published>2020-03-05T08:53:57.000Z</published>
    <updated>2020-03-06T09:08:44.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是缓存？"><a href="#一、什么是缓存？" class="headerlink" title="一、什么是缓存？"></a><strong>一、什么是缓存？</strong></h2><ul><li>缓存就是数据交换的缓冲区（称作：Cache），当某一硬件要读取数据时，会首先从缓存汇总查询数据，有则直接执行，不存在时从内存中获取。由于缓存的数据比内存快的多，所以缓存的作用就是帮助硬件更快的运行。</li><li>缓存往往使用的是RAM（断电既掉的非永久存储），所以在用完后还是会把文件送到硬盘等存储器中永久存储。电脑中最大缓存就是内存条，硬盘上也有16M或者32M的缓存。</li><li>高速缓存是用来协调CPU与主存之间存取速度的差异而设置的。一般CPU工作速度高，但内存的工作速度相对较低，为了解决这个问题，通常使用高速缓存，高速缓存的存取速度介于CPU与主存之间。系统将一些CPU在最近几个时间段经常访问的内容存在高速缓存，这样就在一定程度上缓解了由于主存速度低造成的CPU“停工待料”的情况。</li><li>缓存就是把一些外存上的数据保存在内存上而已，为什么保存在内存上，我们运行的所有程序里面的变量都是存放在内存中的，所以如果想将值放入内存上，可以通过变量的方式存储。在JAVA中一些缓存一般都是通过Map集合来实现的。</li></ul><p>缓存在不同的场景下，作用是不一样的具体举例说明：</p><ul><li>操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。</li><li>数据库缓存——&gt;减少文件系统IO。</li><li>应用程序缓存——&gt;减少对数据库的查询。</li><li>Web服务器缓存——&gt;减少应用服务器请求。</li><li>客户端浏览器缓存——&gt;减少对网站的访问。</li></ul><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache.png" alt></p><h2 id="二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"><a href="#二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。" class="headerlink" title="二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"></a>二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。</h2><p> 【1】由于不同系统的数据访问模式不同，同一种缓存策略很难在不同的数据访问模式下取得满意的性能，研究人员提出不同缓存策略以适应不同的需求。缓存策略的分类： </p><p>  1）、基于访问的时间：此类算法按各缓存项被访问时间来组织缓存队列，决定替换对象。如 LRU；<br>   2）、基于访问频率：此类算法用缓存项的被访问频率来组织缓存。如 LFU、LRU2、2Q、LIRS；<br>   3）、访问时间与频率兼顾：通过兼顾访问时间和频率。使得数据模式在变化时缓存策略仍有较好性能。如 FBR、LRUF、ALRFU。多数此类算法具有一个可调或自适应参数，通过该参数的调节使缓存策略在基于访问时间与频率间取得一个平衡；<br>   4）、基于访问模式：某些应用有较明确的数据访问特点，进而产生与其相适应的缓存策略。如专用的 VoD 系统设计的A&amp;L缓存策略，同时适应随机、顺序两种访问模式的 SARC策略；</p><p> 【2】、数据不一致性产生的原因： </p><p> 1）、先操作缓存，再写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。在分布式环境下，数据的读写都是并发的，一个服务多机器部署，对同一个数据进行读写，在数据库层面并不能保证完成顺序，就有可能后读的操作先完成（读取到的是脏数据），如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>【解决办法】：</p><ul><li>可采用更新前后双删除缓存策略；</li><li>可以通过“串行化”解决，保证同一个数据的读写落在同一个后端服务上；</li></ul><p>  2）、先操作数据库，再清除缓存。如果删缓存失败了，就会出现数据不一致问题。<br>【解决办法】：①、将删除失败的 key 值存入队列中重复删除</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache1.png" alt></p><p> （1）更新数据库数据。<br>  （2）缓存因为种种问题删除失败。<br>  （3）将需要删除的key发送至消息队列。<br>  （4）自己消费消息，获得需要删除的key。<br>  （5）继续重试删除操作，直到成功。<br>  <strong>缺点</strong>：对业务线代码造成大量的侵入。于是有了方案二。 </p><p> ②、方案二：通过订阅 binlog 获取需要重新删除的 Key 值数据。在应用程序中，另起一段程序，获得这个订阅程序传来的消息，进行删除缓存操作 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache2.png" alt></p><p>​    （1）更新数据库数据<br>​    （2）数据库会将操作信息写入binlog日志当中<br>​    （3）订阅程序提取出所需要的数据以及key<br>​    （4）另起一段非业务代码，获得该信息<br>​    （5）尝试删除缓存操作，发现删除失败<br>​    （6）将这些信息发送至消息队列<br>​    （7）重新从消息队列中获得该数据，重试操作。</p><h2 id="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"><a href="#三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。" class="headerlink" title="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"></a><strong>三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。</strong></h2><p> <strong>【</strong>1】、缓存穿透：缓存穿透是说收到一个请求，但是该请求缓存中不存在，只能去数据库中查询，然后放进缓存。但当有好多请求同时访问同一个数据时，业务系统把这些请求全发到了数据库；或者恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次都会被发送到数据库，最总导致数据库挂掉。 </p><p> 【<strong>解决的办法</strong>】：对于恶意访问，一种思路是先做校验，对恶意数据直接过滤掉，不要发送至数据库层；第二种思路是缓存空结果，就是对查询不存在的数据也记录在缓存中，这样就可以有效的减少查询数据库的次数。非恶意访问，结合缓存击穿说明。 </p><p> 【2】、缓存击穿：上面提到的某个数据没有，然后好多请求查询数据库，可以归为缓存击穿的范畴：对于<strong>热点数据</strong>，当缓存失效的一瞬间，所有的请求都被下放到数据库去请求更新缓存，数据库被压垮。 </p><p>【解决的办法】：防范此类问题，一种思路是加<strong>全局锁</strong>，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但现在大部分系统都是分布式的，本地锁无法控制其他服务器也等待，所以要用到全局锁，比如Redis的setnx实现全局锁。另一种思想是对<strong>即将过期的数据进行主动刷新</strong>，比如新起一个线程轮询数据，或者比如把所有的数据划分为不同的缓存区间，定期分区间刷新数据。第二个思路与缓存雪崩有点关系。</p><p> 【3】、缓存雪崩：缓存雪崩是指当我们给所有的缓存设置了同样的过期时间，当某一时刻，整个缓存的数据全部过期了，然后瞬间所有的请求都被抛向了数据库，数据库就崩掉了。 </p><p> 【<strong>解决的办法</strong>】：解决思路要么是分治，<strong>划分更小的缓存区间</strong>，按区间过期；要么<strong>给每个key的过期时间加一个随机值</strong>，避免同时过期，达到错峰刷新缓存的目的。  </p><p>对于 Redis 挂掉了，请求全部走数据库，也属于缓存雪崩，我们可以有以下思路进行解决：</p><ul><li><p>事发前：实现 Redis 的高可用（主从架构+Sentinel 或者 Redis Cluster），尽可能避免 Redis 挂掉这种情况。</p></li><li><p>事发中：万一 Redis 真的挂了，我们可以设置本地缓存（ehcache）+ 限流（hystrix），尽量避免我们的数据库被干掉。</p></li><li><p>事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</p></li></ul><h2 id="四、Redis内存用完会发生什么？"><a href="#四、Redis内存用完会发生什么？" class="headerlink" title="四、Redis内存用完会发生什么？"></a><strong>四、Redis内存用完会发生什么？</strong></h2><p> 如果达到设置的上限，Redis 的<strong>写命令会返回错误信息</strong>（但是读命令还是可以正常返回），或者将 Redis 当缓存使用，<strong>配置缓存淘汰机制</strong>，当 Redis 达到内存的上线时会冲掉旧的数据。 </p><h2 id="五、Redis-的-List-结构相关的操作"><a href="#五、Redis-的-List-结构相关的操作" class="headerlink" title="五、Redis 的 List 结构相关的操作"></a><strong>五、Redis 的 List 结构相关的操作</strong></h2><p> 【1】、PUSH操作：是从队列头部和尾部增加节点的操作。 </p><ul><li>RPUSH KEY VALUE [VALUE …] ：从队列的右端入队一个或者多个数据，如果key值不存在，会自动创建一个空的列表。如果对应的key不是一个List，则会返回一个错误。</li><li>LPUSH KEY VALUE [VALUE…] ：从队列的左边入队一个或多个元素。复杂度O(1)。</li><li>RPUSHX KEY VALUE：从队列的右边入队一个元素，仅队列存在时有效，当队列不存在时，不进行任何操作。</li><li>LPUSHX KEY VALUE：从队列的左边入队一个元素，仅队列存在时有效。当队列不存在时，不进行任何操作。</li></ul><p> 【2】、POP操作：获取并删除头尾节点的操作。 </p><ul><li>LPOP KEY：从队列左边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li><li>RPOP KEY：从队列的右边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li><li>BLPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最左边的第一个元素，当队列为空时，阻塞TIMEOUT时间，单位是秒（这个时间内尝试获取KEY中的数据），超过TIMEOUT后如果仍未数据则返回(nil)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; BLPOP <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> (nil)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> (<span class="number">1.10</span>s)</span><br></pre></td></tr></table></figure><ul><li><p>BRPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最后一个元素，或阻塞TIMEOUT。如上↑ </p><p>【4】、其他 </p></li><li><p>LLEN KEY：获取队列（List）的长度。</p></li><li><p>LRANG KEY START STOP：从列表中获取指定（START-STOP）长度的元素。负数表示从右向左数。需要注意的是，超出范围的下标不会产生错误：如果start&gt;end，会得到空列表，如果end超过队尾，则Redis会将其当做列表的最后一个元素。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> redis&gt; rpush q1 a b c d f e g</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q1 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"f"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"e"</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br></pre></td></tr></table></figure><ul><li><p>LINDEX KEY INDEX：获取一个元素，通过其索引列表。我们之前介绍的操作都是对list的两端进行的，所以算法复杂度都只有O(1)。而这个操作是指定位置来进行的，每次操作，list都得找到对应的位置，因此算法复杂度为O(N)。list的下表是从0开始的，index为负的时候是从右向左数。-1表示最后一个元素。当下标超出的时候，会返回nul。所以不用像操作数组一样担心范围越界的情况。</p></li><li><p>LSET KEY INDEX：重置队列中INDEX位置的值。当index越界的时候，这里会报异常。 </p></li><li><p>LREM KEY COUNT VALUE：从列表中删除COUNT个VALUE元素。COUNT参数有三种情况： </p><p>​      count &gt; 0: 表示从头向尾（左到右）移除值为value的元素。<br>​      count &lt; 0: 表示从尾向头（右向左）移除值为value的元素。<br>​      count = 0: 表示移除所有值为value的元素。 </p></li><li><p>LTRIM KEY START STOP：修剪到指定范围内的清单，相当与截取，只保留START-STOP之间的数据。 </p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; rpush q a b c d e f g</span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"e"</span></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"f"</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br><span class="line"><span class="number">11</span> redis&gt; ltrim q <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">12</span> OK</span><br><span class="line"><span class="number">13</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">14</span> <span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">15</span> <span class="number">2</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">16</span> <span class="number">3</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">17</span> <span class="number">4</span>) <span class="string">"e"</span></span><br></pre></td></tr></table></figure><ul><li>LINSERT KEY BEFORE|AFTER 元素 VALUE：在列表中的另一个元素之前或之后插入VAULE。当 key 不存在时，这个List被视为空列表，任何操作都不会发生。当key存在，但保存的不是 List，则会报 error。该命令会返回修改之后的 List的长度，如果找不到元素，则会返回 -1。</li></ul><h2 id="六、Redis的数据结构都有哪些"><a href="#六、Redis的数据结构都有哪些" class="headerlink" title="六、Redis的数据结构都有哪些"></a><strong>六、Redis的数据结构都有哪些</strong></h2><p>【1】、String：可以是字符串，整数或者浮点数，对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作。<br>【2】、List：一个链表，链表上的每个节点都包含了一个字符串，链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素。可参考5<br>【3】、Set：包含字符串的无序收集器(unordered collection)、并且被包含的每个字符串都是独一无二的。添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集（sinter），并集（suion），差集（sdiff），从集合里面随机获取元素。<br>【4】、SortSet：是一个排好序的 Set，它在 Set 的基础上增加了一个顺序属性 score，这个属性在添加修改元素时可以指定，每次指定后，SortSet 会自动重新按新的值排序。sorted set 的内部使用 HashMap 和跳跃表(SkipList)来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 score。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> <span class="string">"one"</span> <span class="number">2</span> <span class="string">"two"</span> <span class="number">3</span> <span class="string">"three"</span> #添加元素</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrem myzset one   <span class="comment">//删除元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>【 5】、hash：Hash 是一个 String 类型的 field 和 value 之间的映射表，即 redis 的 Hash 数据类型的 key（hash表名称）对应的 value 实际的内部存储结构为一个 HashMap，因此 Hash 特别适合存储对象。相对于把一个对象的每个属性存储为 String 类型，将整个对象存储在 Hash 类型中会占用更少内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash age <span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash name</span><br><span class="line"><span class="string">"zhangsan"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash age</span><br><span class="line"><span class="string">"20"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"><a href="#七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。" class="headerlink" title="七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"></a><strong>七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</strong></h2><p>使用阶段我们从数据存储和数据获取两个方面来说明开发时的注意事项：<br>【1】数据存储：因为内存空间的局限性，注定了能存储的数据量有限，如何在有限的空间内存储更多的数据信息是我们应该关注的。Redis内存储的都是键值对，那么如何减小键值对所占据的内存空间就是空间优化的本质。在能清晰表达业务含义的基础上尽可能缩减Key的字符长度，比如一个键是user:{id}:logintime ，可以使用业务属性的简写来u:{id}:lgt,只要能清晰表达业务意义，使用简写形式是有其必要性的。在不影响使用的情况下，缩减Value的数据大小。如果Value是较大的数据信息，比如图片，大文本等，可以使用压缩工具压缩过后再存入Redis；如果Value是对象序列化或者gson信息，可以考虑去除非必要的业务属性。<br>减少键值对的数量，对于大量的String类型的小对象，可以尝试使用Hash的形式组合他们，在Hash对象内Field数量少于1000，且Value的字符长度小于40时，内部使用ziplist的编码形式，能够极大的降低小对象占据的内存空间。<br>Redis内维护了一个[0-9999]的整数对象池，类似Java内的运行时常量池，只创建一个常量，使用时都去引用这个常量，所以当存储的value是这个范围内的数字时均是引用向都一个内存地址，所以能够降低一些内存空间耗费。但是共享对象池和maxmemory+LRU的内存回收策略冲突，因为共享Value对象的lru值也共享，难以通过lru知道哪个Key的最后引用时间，所以永远也不能回收内存。如果多次数据操作要求原子性，可使用Multi来实现Redis的事务。<br>【2】数据查询：Redis 是一种数据库，和其他数据库一样，操作时也需要有连接对象，连接对象的创建和销毁也需要耗费资源，复用连接对象很有必要，所以推荐使用连接池来管理连接。Redis数据存储在内存中，查询很快，但不代表连接也很快。一次Redis查询可能IO部分占据了请求时间的绝大部分比例，缩短IO时间是开发过程中很需要注意的一点。对于一个业务内的多次查询，考虑使用Pipeline，将多次查询合并为一次查询，命令会被执行多次，但是只有一个IO传输，能够有效的提高响应速度。<br>对于多次String类型的查询，使用mget，将多次请求合并为一次，同时命令和会被合并为一次，能有效提高响应速度，对于Hash内多个Field查询，使用hmget，起到和mget同样的效果。Redis是单线程执行的，也就是说同一时间只能执行一条命令，如果一条命令执行的时间较长，其他线程在此期间均会被阻塞，所以在操作Redis时要注意操作指令的涉及的数据量，尽量降低单次操作的执行时间。<br>【持久化方式】：RDB 时间点快照 AOF 记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。可参考14深度解析<br>【内存设置】：maxmemory used_memory<br>【虚拟内存】： vm-enabled yes<br>【集群的应用和优劣势】：参考9<br>【内存优化】：<a href="http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage</a><br>【淘汰策略】：<a href="http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html</a></p><p>Redis 提供 6 种数据淘汰策略：</p><ol><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用 的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数 据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据 淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ol><h2 id="八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制"><a href="#八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制" class="headerlink" title="八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制"></a><strong>八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制</strong></h2><p>集群方式的区别：Redis3 采用Cluster，Redis2 采用客户端分区方案和代理方案；<br>通信过程说明：<br>  1） 集群中的每个节点都会单独开辟一个TCP通道， 用于节点之间彼此通信， 通信端口号在基础端口上加10000。<br>  2） 每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。<br>  3） 接收到 ping 消息的节点用 pong 消息作为响应。</p><h2 id="九、当前-Redis-集群有哪些玩法，各自优缺点，场景。"><a href="#九、当前-Redis-集群有哪些玩法，各自优缺点，场景。" class="headerlink" title="九、当前 Redis 集群有哪些玩法，各自优缺点，场景。"></a><strong>九、当前 Redis 集群有哪些玩法，各自优缺点，场景。</strong></h2><p>【1】数据共享：Redis 提供多个节点实例间的数据共享，也就是 Redis A,B,C,D彼此之间的数据是同步的，同样彼此之间也可以通信，而对于客户端操作的 keys 是由 Redis 系统自行分配到各个节点中。<br>【2】主从复制：Redis 的多个实例间通信时，一旦其中的一个节点故障，那么 Redis 集群就不能继续正常工作，所以需要一种复制机制（Master-Slave）机制，做到一旦节点A故障了，那么其从节点A1和A2就可以接管并继续提供与A同样的工作服务，当然如果节点A,A1,A2节点都出现问题，那么同样这个集群不会继续保持工作，但是这种情况比较罕见，即使出现了，也会及时发现并修复使用。建议：部署主从复制机制（Master-Slave）。<br>【3】哈希槽值：Redis 集群中使用哈希槽来存储客户端的 keys，而在 Redis 中，目前存在16384个哈希槽，它们被全部分配给所有的节点，正如上图所示，所有的哈希槽值被节点A，B，C分配完成了。<br>参考：<a href="https://www.cnblogs.com/RENQIWEI1995/p/8931678.html" target="_blank" rel="noopener">https://www.cnblogs.com/RENQIWEI1995/p/8931678.html</a></p><h2 id="十、Memcache-的原理，哪些数据适合放在缓存中。"><a href="#十、Memcache-的原理，哪些数据适合放在缓存中。" class="headerlink" title="十、Memcache 的原理，哪些数据适合放在缓存中。"></a><strong>十、Memcache 的原理，哪些数据适合放在缓存中。</strong></h2><p> 首先要说明一点，MemCache 的数据存放在内存中，存放在内存中个人认为意味着几点： </p><p> 【1】访问数据的速度比传统的关系型数据库要快，因为 Oracle、MySQL 这些传统的关系型数据库为了保持数据的持久性，数据存放在硬盘中，IO操作速度慢； </p><p> 【2】MemCache 的数据存放在内存中同时意味着只要 MemCache 重启了，数据就会消失； </p><p> 【3】既然 MemCache 的数据存放在内存中，那么势必受到机器位数的限制，这个之前的文章写过很多次了，32位机器最多只能使用2GB的内存空间，64位机器可以认为没有上限。</p><p>  然后我们来看一下 MemCache 的原理，MemCache 最重要的莫不是内存分配的内容了，MemCache 采用的内存分配方式是固定空间分配，一张图说明： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache3.png" alt></p><p>这张图片里面涉及了slab_class、slab、page、chunk四个概念，它们之间的关系是：<br>【1】、MemCache将内存空间分为一组slab<br>【2】、每个slab下又有若干个page，每个page默认是1M，如果一个slab占用100M内存的话，那么这个slab下应该有100个page<br>【3】、每个page里面包含一组chunk，chunk是真正存放数据的地方，同一个slab里面的chunk的大小是固定的<br>【4】、有相同大小chunk的slab被组织在一起，称为slab_class<br>MemCache内存分配的方式称为allocator，slab的数量是有限的，几个、十几个或者几十个，这个和启动参数的配置相关。<br>MemCache中的value过来存放的地方是由value的大小决定的，value总是会被存放到与chunk大小最接近的一个slab中，比如slab[1]的chunk大小为80字节、slab[2]的chunk大小为100字节、slab[3]的chunk大小为128字节（相邻slab内的chunk基本以1.25为比例进行增长，MemCache启动时可以用-f指定这个比例），那么过来一个88字节的value，这个value将被放到2号slab中。放slab的时候，首先slab要申请内存，申请内存是以page为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的page被分配给该slab。申请到page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk数组，最后从这个chunk数组中选择一个用于存储数据。<br>如果这个slab中没有chunk可以分配了怎么办，如果MemCache启动没有追加-M（禁止LRU，这种情况下内存不够会报Out Of Memory错误），那么MemCache会把这个slab中最近最少使用的chunk中的数据清理掉，然后放上最新的数据。针对MemCache的内存分配及回收算法，总结三点：</p><p> 【1】、MemCache的内存分配chunk里面会有内存浪费，88字节的value分配在128字节（紧接着大的用）的chunk中，就损失了30字节，但是这也避免了管理内存碎片的问题 </p><p> 【2】、MemCache的LRU算法不是针对全局的，是针对slab的 </p><p> 【3】、应该可以理解为什么MemCache存放的value大小是限制的，因为一个新数据过来，slab会先以page为单位申请一块内存，申请的内存最多就只有1M，所以value大小自然不能大于1M了。 </p><p> <strong>再总结 MemCache 的特性和限制：</strong> </p><p> 上面已经对于MemCache做了一个比较详细的解读，这里再次总结MemCache的限制和特性： </p><p>上面已经对于MemCache做了一个比较详细的解读，这里再次总结MemCache的限制和特性：<br>1】、MemCache中可以保存的item数据量是没有限制的，只要内存足够<br>2】、MemCache单进程在32位机中最大使用内存为2G，这个之前的文章提了多次了，64位机则没有限制<br>3】、Key最大为250个字节，超过该长度无法存储<br>4】、单个item最大数据是1MB，超过1MB的数据不予存储<br>5】、MemCache服务端是不安全的，比如已知某个MemCache节点，可以直接telnet过去，并通过flush_all让已经存在的键值对立即失效<br>6】、不能够遍历MemCache中所有的item，因为这个操作的速度相对缓慢且会阻塞其他的操作<br>7】、MemCache的高性能源自于两阶段哈希结构：第一阶段在客户端，通过Hash算法根据Key值算出一个节点；第二阶段在服务端，通过一个内部的Hash算法，查找真正的item并返回给客户端。从实现的角度看，MemCache是一个非阻塞的、基于事件的服务器程序<br>8】、MemCache设置添加某一个Key值的时候，传入expiry为0表示这个Key值永久有效，这个Key值也会在30天之后失效。</p><p> <strong>MemCache适合存储：</strong> </p><p>变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线状态、在线人数..)门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入到memcache中.(配合jquey的ajax请求)。 </p><h2 id="十一、Redis-和-Memcached-的内存管理的区别"><a href="#十一、Redis-和-Memcached-的内存管理的区别" class="headerlink" title="十一、Redis 和 Memcached 的内存管理的区别"></a><strong>十一、Redis 和 Memcached 的内存管理的区别</strong></h2><p>可参考博客1：<a href="http://lib.csdn.net/article/redis/55323" target="_blank" rel="noopener">http://lib.csdn.net/article/redis/55323</a><br>可参考博客2：<a href="https://www.cnblogs.com/work115/p/5584646.html" target="_blank" rel="noopener">https://www.cnblogs.com/work115/p/5584646.html</a> </p><h2 id="十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？"><a href="#十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？" class="headerlink" title="十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？"></a>十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？</h2><p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在 Jedis 客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：<br>【1】客户端角度，为保证每个客户端间正常有序与 Redis 进行通信，对连接进行池化，同时对客户端读写 Redis 操作采用内部锁 synchronized。<br>【2】服务器角度，利用 setnx 实现锁</p><p> MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：<br>   ☆ MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行<br>   ☆ EXEC，告诉 Redis 开始执行事务<br>   ☆ DISCARD，告诉 Redis 取消事务<br>   ☆ WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。</p><p>【<strong>Redis 事务机制</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a><br>【<strong>CAS 操作</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a> </p><h2 id="十三、Redis-的选举算法和流程是怎样的"><a href="#十三、Redis-的选举算法和流程是怎样的" class="headerlink" title="十三、Redis 的选举算法和流程是怎样的"></a><strong>十三、Redis 的选举算法和流程是怎样的</strong></h2><p><strong>Raft</strong> 采用心跳机制触发 Leader 选举。系统启动后，全部节点初始化为 Follower，term 为0。节点如果收到了 RequestVote 或者AppendEntries，就会保持自己的 Follower 身份。如果一段时间内没收到 AppendEntries 消息直到选举超时，说明在该节点的超时时间内还没发现 Leader，Follower 就会转换成 Candidate，自己开始竞选 Leader。一旦转化为 Candidate，该节点立即开始下面几件事情：<br> 1）、增加自己的term。<br> 2）、启动一个新的定时器。<br> 3）、给自己投一票。<br> 4）、向所有其他节点发送RequestVote，并等待其他节点的回复。<br>✔ 如果在这过程中收到了其他节点发送的AppendEntries，就说明已经有Leader产生，自己就转换成Follower，选举结束。<br>✔ 如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送AppendEntries，告知自己成为了Leader。<br>✔ 每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，Follower会投给第一个收到RequestVote的节点。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC, 则自己转换为Candidate, 开始请求投票，就是上面的的竞选Leader步骤。<br>✔ 如果多个Candidate发起投票，每个Candidate都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为Candidate，重复前面竞选Leader步骤。<br>✔ Raft协议的定时器采取随机超时时间，这是选举Leader的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的1倍到2倍之间。由于随机配置，所以各个Follower同时转成Candidate的时间一般不一样，在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。多个节点同时转换为Candidate的可能性很小。即使几个Candidate同时发起投票，在该term内有几个节点获得一样高的票数，只是这个term无法选出Leader。由于各个节点定时器的超时时间随机生成，那么最先进入下一个term的节点，将更有机会成为Leader。连续多次发生在一个term内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般1-2个term类，Leader就会被选出来。</p><p><strong>【Sentinel 的选举流程】</strong>：Sentinel 集群正常运行的时候每个节点 epoch 相同，当需要故障转移的时候会在集群中选出 Leader执行故障转移操作。Sentinel采 用了Raft 协议实现了 Sentinel 间选举 Leader 的算法，不过也不完全跟论文描述的步骤一致。Sentinel 集群运行过程中故障转移完成，所有 Sentinel 又会恢复平等。Leader 仅仅是故障转移操作出现的角色。</p><p>【选举流程】：1）、某个 Sentinel 认定 master 客观下线的节点后，该 Sentinel 会先看看自己有没有投过票，如果自己已经投过票给其他 Sentinel 了，在2倍故障转移的超时时间自己就不会成为 Leader。相当于它是一个 Follower。<br>  2）、如果该 Sentinel 还没投过票，那么它就成为 Candidate。<br>  3）、和 Raft 协议描述的一样，成为 Candidate，Sentinel 需要完成几件事情。<br>   【1】更新故障转移状态为start<br>   【2】当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。<br>   【3】更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。<br>   【4】向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。<br>   【5】给自己投一票，在 Sentinel 中，投票的方式是把自己 master 结构体里的 leader 和 leader_epoch 改成投给的 Sentinel 和它的 epoch。<br>   4）、其他Sentinel会收到Candidate的is-master-down-by-addr命令。如果Sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的Sentinel后，在当前epoch内自己就只能成为Follower。<br>   5）、Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。Sentinel比Raft协议增加了quorum，这样一个Sentinel能否当选Leader还取决于它配置的quorum。<br>   6）、如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。<br>   7）、如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。<br>   8）、如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。<br>   9）、与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他Sentinel。其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p><h2 id="十四、Redis-的持久化的机制，AOF和RDB的区别。"><a href="#十四、Redis-的持久化的机制，AOF和RDB的区别。" class="headerlink" title="十四、Redis 的持久化的机制，AOF和RDB的区别。"></a>十四、Redis 的持久化的机制，AOF和RDB的区别。</h2><p><strong>Redis的持久化机制</strong>：Redis 提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。<br> <strong>AOF和RDB的区别</strong>：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache4.png" alt></p><p> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache5.png" alt></p><p>【二者优缺点】：RDB存在哪些优势：<br>【1】一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。<br>【2】对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。<br>【3】性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。<br>【4】相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p><p>【RDB又存在哪些劣势】：<br>【1】如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。<br>【2】由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p><p>【AOF 的优势有哪些】：<br>【1】该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。<br>【2】由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。<br>【3】如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。<br>【4】AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p><p>【AOF 的劣势有哪些】：<br>【1】对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>【2】根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p><p> <strong>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</strong> </p><h2 id="十五、缓存预热"><a href="#十五、缓存预热" class="headerlink" title="十五、缓存预热"></a><strong>十五、缓存预热</strong></h2><p> 新的缓存系统没有任何数据，在缓存重建数据的过程中，系统性能和数据负载都不太好，所以最好在系统上线之前就把缓存的热点数据加载到缓存中，这种缓存预加载手段就是缓存预热。 </p><h2 id="十六、缓存热备"><a href="#十六、缓存热备" class="headerlink" title="十六、缓存热备"></a><strong>十六、缓存热备</strong></h2><p> 缓存热备既当一个缓存服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从节点备用，一旦主节点挂掉，从节点会被哨兵提升为主节点使用。 </p><h2 id="十七、Redis-的集群怎么同步的数据的"><a href="#十七、Redis-的集群怎么同步的数据的" class="headerlink" title="十七、Redis 的集群怎么同步的数据的"></a><strong>十七、Redis 的集群怎么同步的数据的</strong></h2><p>Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。</p><p>Reds 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。</p><p>使用哈希槽的好处就在于可以方便的添加或移除节点。</p><p>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</p><p>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；</p><p>在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务</p><p><strong>Redis集群的主从架构：</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品。</p><p>例如有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少B节点所承担的哈希槽这个范围的槽而不可用。</p><p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了。当然如果B和B1都down了，那集群还是不可用的，不过这种情况微乎其妙，基本不用考虑，出发你交换机挂了吧，或者机房断电。</p><p> <strong>Redis 集群搭建</strong>的方式有很多种，但从 redis 3.0 版本之后，支持 redis-cluster 集群，它是 Redis 官方提供的解决方案，Redis Cluster 采用的是 无中心架构 ，每个节点保存数据和整个集群状态，每个节点都和其他节点有所连接。其架构如下： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache6.png" alt></p><p>客户端与 redis 节点直连，不需要中间件 proxy 层，客户端不需要连接集群所有节点，连接集群汇中任何一个节点即可。所有的 redis 节点彼此互联（PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。 </p><p> <strong>分布式存储机制-槽</strong> </p><p>【1】、redis_cluster 把所有的节点映射到 [0-16383] slot 槽上，cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value 三者之间的关系。<br>【2】、Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先将 key 使用 CRC16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点上。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，当有三个节点时，槽分布的值如下：</span><br><span class="line">节点1：   0-5460</span><br><span class="line">节点2：   5461-10921</span><br><span class="line">节点3:    10922-16383</span><br></pre></td></tr></table></figure><h2 id="十八、知道哪些-Redis-的优化操作"><a href="#十八、知道哪些-Redis-的优化操作" class="headerlink" title="十八、知道哪些 Redis 的优化操作"></a>十八、知道哪些 Redis 的优化操作</h2><h3 id="一、Linux-操作系统"><a href="#一、Linux-操作系统" class="headerlink" title="一、Linux 操作系统"></a><strong>一、Linux 操作系统</strong></h3><p>【1】<strong>ulimit 与 TCP backlog：1</strong>）、修改 ulimit：通过 ulimit 修改 open files 参数，redis 建议把 open files 至少设置成 10032，因为 maxclients 是10000  [客户端的数据是以文件的形式进行保存的] ，另外 redis 内部最多会使用 32 个文件描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n <span class="number">10032</span>  #但重启后就无效了，也可以通过配置文件limits.conf 的形式持久修改</span><br><span class="line">#修改了，重新登录后就立刻生效.可以用CentOS ulimit -a 查看确认</span><br><span class="line">[root@dev ~]<span class="meta"># ulimit -a</span></span><br><span class="line">#... 省略</span><br><span class="line"><span class="function"><span class="built_in">open</span> <span class="title">files</span>                      <span class="params">(-n)</span> 10032</span></span><br></pre></td></tr></table></figure><p> 2）、修改 TCP backlog：redis 默认的 tcp-backlog 为 511，可通过配置 tcp-backlog 进行调整，如果 Linux 的 tcp-backlog 小于 redis 的 tcp-backlog，日志里会出有 warning。此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须小于或等于 Linux 系统定义的 [/proc/sys/net/core/somaxconn] 值，而 Linux 的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建议修改为 <span class="number">2048</span> 修改somaxconn</span><br><span class="line">#该内核参数默认值一般是<span class="number">128</span>，对于负载很大的服务程序来说大大的不够。一般会将它修改为<span class="number">2048</span>或者更大。</span><br><span class="line">echo <span class="number">2048</span> &gt; /proc/sys/net/core/somaxconn #但是这样系统重启后保存不了</span><br><span class="line"></span><br><span class="line">#持久化设置: 在 /etc/sysctl.conf 中添加如下:</span><br><span class="line"><span class="meta">#net.core.somaxconn = 2048</span></span><br><span class="line"></span><br><span class="line">#然后在终端中执行:sysctl -p</span><br></pre></td></tr></table></figure><p>【2】<strong>vm.overcommit_mermory</strong>：表示内核在分配内存时候做检查的方式。<br>  1）、redis 建议将 vm.overcommit_memory 设置为1，防止极端情况下 fork 出错。<br>  2）、vm.overcommit_memory 取值说明：Linux 对大多数申请内存的回复均为 YES，以运行更多程序，因为申请后并不是立马使用，该技术叫 vm.overcommit。<br>  ■  0：内核将检查是否有足够的内存，如果足够，申请通过，否则内存申请失败把错误返回给应用进程。<br>  ■  1：表示内核容许超量使用内存直到用完为止。<br>  ■  2：内存绝不过量使用内存，既系统整个内存空间不能超过 swap+50% 的 RAM[（random access memory）即随机存储内存 ]值，50% 是 overcommit_ratio 的默认值，支持修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.overcommit_memory=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p> 【3】<strong>swappiness 参数</strong>：</p><p>1）：swappiness 参数决定操作系统使用 swap 的倾向程度，取值范围是0~100，swappiness 的值越大，说明操作系统可能使用 swap 的概率越高，swappiness 值越低，表示操作系统更加倾向于使用物理内存。 </p><p>2）、建议 Linux3.5 以上设置为1，否则建议设置为0。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.swappiness=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p> 【4】<strong>Transparent Huge Pages</strong>：支持大内存分页（2MB）分配，默认开启，redis 建议关闭此功能。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig --add disable-transparent-hugepages</span><br></pre></td></tr></table></figure><p>【5】OOM killer：会在可用内存不足时选择性杀掉用户进程，OOM killer 会为每个用户进程设置一个权重，权重越大被 kill 的可能性越大。每个进程的权重放在 [/proc/{progress_id}/oom_adj]。对于 Redis 服务器来说，可以将所有 Redis 的 oom_adj 设置为最低值或者稍小的值，降低被 OOM killer 杀掉的概率。应该设置与进程有关，无法一次性设置。</p><h3 id="二、Redis-关键参数"><a href="#二、Redis-关键参数" class="headerlink" title="二、Redis 关键参数"></a><strong>二、Redis 关键参数</strong></h3><p><strong>【1】客户端最大连接数（maxclients）：</strong></p><p>  1）、现象：如果连接数不够，或者请求返回比较慢导致连接数不足，可能会报[ max number of clients reached ]。</p><p>  2）、优化：调整 maxclients，或者优化 redis 命令处理性能。要注意该参数受到操作系统最大文件句柄的限制（ulimit -n <n>）</n></p><p><strong>【2】repl-ping-slave-period/repl-timeout：</strong></p><p>1）、说明：slave 会每隔 repl-ping-slave-period（默认10秒）ping 一次 master，如果查过 repl-timeout（默认 60秒）都没有收到响应，就会认为 Master 挂掉。</p><p>2）、优化：如果 Master 明明没挂掉但被阻塞住了也会报这个错。可以适当调大 repl-timeout</p><p> <strong>【3】client-output-buffer-limit：</strong></p><p>  1）说明：客户端输出缓冲区大小。</p><p>  2）、当使用主从复制时，性能压测下，数据量会急剧增长，导致从节点需要复制的数据很大，消耗时长增加。slave 没挂但被阻塞住了，比如正在 loading Master 发过来的 RDB，Master 的指令不能立刻发送给 slave，就会放在 output-buffer 中，在配置文件中有如下配置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-<span class="built_in">buffer</span>-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br></pre></td></tr></table></figure><p>上述配置说明：负责发送给 slave的 client，如果 buffer 超过 256m 或者连续 60秒超过 64m，就会被立刻强行关闭。所以此时应该相应调大数值，否则就会出现很悲剧的循环：Master 传输一个很大的 RDB 给 slave，slave 努力地装载，但是还没装载完，Master 对 client 的缓存存满了，关闭后再来一次。</p><h3 id="三、Redis-性能测试"><a href="#三、Redis-性能测试" class="headerlink" title="三、Redis 性能测试"></a><strong>三、Redis 性能测试</strong></h3><p> Redis 官网自动 Redis 性能测试工具 <strong>Redis-benchmark</strong>，可以有效的测试 Redis 服务的性能。 </p><p> 【1】案例一：命令如下，100个并发连接，100000个请求，检测host为127.0.0.1 端口为 6379 的 redis 服务器性能 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> -c <span class="number">100</span> -n <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">#对集合写入测试 结果如下</span><br><span class="line"><span class="number">100000</span> requests completed in <span class="number">2.38</span> seconds #<span class="number">100000</span>个请求在<span class="number">2.38</span>秒内完成</span><br><span class="line"><span class="number">20</span> parallel clients  #每次请求有<span class="number">20</span>个并发客户端</span><br><span class="line"><span class="number">3</span> bytes payload  #每次写入<span class="number">3</span>个字节的数据</span><br><span class="line">keep alive: <span class="number">1</span>  #保持一个连接，一台服务器来处理这些请求</span><br><span class="line"></span><br><span class="line"><span class="number">93.06</span>% &lt;= <span class="number">15</span> milliseconds</span><br><span class="line"><span class="number">99.96</span>% &lt;= <span class="number">31</span> milliseconds</span><br><span class="line"><span class="number">99.98</span>% &lt;= <span class="number">46</span> milliseconds</span><br><span class="line"><span class="number">99.99</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line"><span class="number">100.00</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line">#所有请求在<span class="number">62</span>毫秒内完成</span><br><span class="line"><span class="number">42105.26</span> requests per second</span><br><span class="line">#每秒处理<span class="number">42105.26</span>次请求</span><br></pre></td></tr></table></figure><p> 【2】案例二：命令如下，测试指定操作命令的性能。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -t <span class="built_in">set</span>,lpush -n <span class="number">100000</span> -q</span><br></pre></td></tr></table></figure><h3 id="四、查找慢查询语句"><a href="#四、查找慢查询语句" class="headerlink" title="四、查找慢查询语句"></a><strong>四、查找慢查询语句</strong></h3><p> Redis 提供了记录耗时操作语句的功能，当语句执行（不包括命令排队时间）超过了阈值，则被认为是慢查询。 </p><p>【1】参数设置：[ slowlog-log-slower-than ]：记录运行耗时语句的阈值，单位是微妙（1秒=1000毫秒=1000 000微妙，默认值：10000）。当值为0时，记录所有请求。当值&lt;0时，不记录任何请求。</p><p> [ slowlog-max-len ]：该参数用于设置慢查询保存的条数。</p><p>【2】功能使用：[ slowlog get ]：用于查询慢查询信息。[ slowlog len ]：显示当前 redis 有多少条慢查询</p><h2 id="十九、Reids-的主从复制机制原理"><a href="#十九、Reids-的主从复制机制原理" class="headerlink" title="十九、Reids 的主从复制机制原理"></a><strong>十九、Reids 的主从复制机制原理</strong></h2><h3 id="一、Redis-复制"><a href="#一、Redis-复制" class="headerlink" title="一、Redis 复制"></a><strong>一、Redis 复制</strong></h3><p> <strong>复制（Replication）</strong>：是 Redis 实现高可用的基础。且在复制过程中，主节点/从节点都是非阻塞的，但是从节点在执行同步时使用的是旧数据集提供查询。 </p><p> Redis 复制启动图与流程说明： </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache7.png" alt></p><p>1）、当从节点连接到主节点时，会发送 psync 命令给主节点，runId 是主节点的 ID，如果没有默认是 -1；offset 是从节点保存复制偏移量，主节点根据复制偏移量仅发送从节点所需的增量部分，如果是第一次复制则为 -1；</p><p>2）、如果主节点回复 <strong>+FULLRESYNC</strong>，那么从节点将触发全量复制流程。</p><p>3）、如果主节点回复 <strong>+CONTINUE</strong>，那么从节点触发部分复制。</p><p>4）、如果主节点回复 <strong>+ERR</strong>，说名主节点不支持该命令。</p><h3 id="二、Redis-主从全量复制"><a href="#二、Redis-主从全量复制" class="headerlink" title="二、Redis 主从全量复制"></a><strong>二、Redis 主从全量复制</strong></h3><p> <strong>主从复制：</strong>主机数据更新后根据配置和策略，自动同步到备机的 master/slaver 机制，Master以写为主，Slave以读为主。 </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache8.png" alt></p><h3 id="三、Redis-主从部分复制"><a href="#三、Redis-主从部分复制" class="headerlink" title="三、Redis 主从部分复制"></a><strong>三、Redis 主从部分复制</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache9.png" alt></p><h3 id="四、Redis-主从搭建"><a href="#四、Redis-主从搭建" class="headerlink" title="四、Redis 主从搭建"></a><strong>四、Redis 主从搭建</strong></h3><p> 【1】修改主节点 redis.conf 文件：使用[./redis-server redis.conf]启动主节点。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">Port <span class="number">7000</span></span><br><span class="line"></span><br><span class="line">#是否开启保护模式，默认为 yes 是开启。要是配置里没有指定 bind 和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。</span><br><span class="line">#要是开启了密码和 bind，可以开启。否则最好关闭，设置为no。</span><br><span class="line"><span class="keyword">protected</span>-mode no </span><br><span class="line">#修改 redis 安全密码</span><br><span class="line">requirepass <span class="string">"123456789"</span></span><br><span class="line"></span><br><span class="line">master 设置密码</span><br><span class="line"></span><br><span class="line">masterauth <span class="string">"123456789"</span></span><br><span class="line">#开启appendonly 模式后,redis 将每一次写操作请求都追加到appendonly.aof 文件中</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>  【2】新建从节点并配置复制主节点信息（配从(库)不配主(库)）每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 info replication（Redis Sentinel 还使用该信息来发现 slave 实例） </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#slaveof 主库IP 主库端口</span></span><br><span class="line"></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure><p><strong>【3】Redis 主/从复制注意点：</strong></p><p>1）、主/从节点应启用持久化：master 和 slave 中应启用持久化。当由于性能要求不能启用持久化时，应配置实例避免自动重启，因为主节点未持久化又重启时，内存数据为空，会导致从节点同步主节点空数据。<br> 2）、从节点应配置只读属性：主从复制中，从节点应配置只读属性[replica-read-only yes]。<br> 3）、从节点应配置对主节点的验证：主节点通过 requirepass 配置了密码时，从节点应使用[masterauth <password>]配置对主节点的访问密码。<br> 4）、主节点配置写查询接收条件：为了尽量保证主从一致性，主节点应配置当至少有 N 个 slave，并且滞后小于 M 秒时，才接收客户端写入命令[min-slaves-to-write &lt;slave 数量&gt; min-slaves-max-lag &lt;秒数&gt;]</password></p><h3 id="五、主从复制常用3招"><a href="#五、主从复制常用3招" class="headerlink" title="五、主从复制常用3招"></a><strong>五、主从复制常用3招</strong></h3><ol><li>一主二仆： 一个 Master 两个 Slave； </li><li>薪火相传：上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master，可以有效减轻 Master 的写压力。中途变更转向会清除之前的数据，重新建立拷贝最新的slaveof 新主库IP 新主库端口；</li><li>反客为主：SLAVEOF NO ONE。使当前数据库停止与其他数据库的同步，转成主数据库 </li></ol><h3 id="六、主从复制原理"><a href="#六、主从复制原理" class="headerlink" title="六、主从复制原理"></a><strong>六、主从复制原理</strong></h3><p> 【1】slave 启动成功连接到 master 后会发送一个 sync 命令。 </p><p> 【2】Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，以完成一次完全同步。 </p><p> 【3】全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。 </p><p> 【4】增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步。 </p><p> 【5】但是只要是重新连接 master，一次完全同步（全量复制)将被自动执行。 </p><p> <strong>复制的缺点：</strong>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。 </p><h2 id="二十、Redis-的线程模型是什么"><a href="#二十、Redis-的线程模型是什么" class="headerlink" title="二十、Redis 的线程模型是什么"></a><strong>二十、Redis 的线程模型是什么</strong></h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h3><p>【1】、Redis 是基于 Reactor 模式开发的网络事件处理器：这个处理器被称为文件事件处理器（file event handler），这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型：</p><ul><li>文件事件处理器使用 I/O 多路复用（multiplexing）机制监听多个套接字 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</li><li>当被监听的套接字准备好执行连接<strong>应答（accept）、读取（read）、写入（write）、关闭（close）</strong>等操作时。与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p>【2】、虽然文件事件处理器以单线程的方式运行，但其使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p><h3 id="二、文件事件处理器的结构"><a href="#二、文件事件处理器的结构" class="headerlink" title="二、文件事件处理器的结构"></a><strong>二、文件事件处理器的结构</strong></h3><p> 【1】、文件事件处理器的结构包含 4 个部分：</p><p>  ● 多个 socket</p><p>  ● IO 多路复用程序</p><p>  ● 文件事件分派器</p><p>  ● 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） </p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache10.png" alt></p><p>【2】、多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。<strong>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字，</strong> 如图：<br> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache11.png" alt></p><p> 文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。 </p><p>【3】、<strong>I/O 多路复用程序的实现</strong>：Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库来实现的， 每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件， 比如 ae_select.c 、 ae_epoll.c 、 ae_kqueue.c ， 诸如此类。因为 Redis 为每个 I/O 多路复用函数库都实现了相同的 API ， 所以 I/O 多路复用程序的底层实现是可以互换的， 如下图所示：</p><p> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache12.png" alt></p><p> Redis 在 I/O 多路复用程序的实现源码中用 <code>#include</code> 宏定义了相应的规则， 程序会在编译时自动选择系统中性能最高的 I/O 多路复用函数库来作为 Redis 的 I/O 多路复用程序的底层实现： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 包括此系统支持的最佳复用层</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下应按性能降序排列。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>【4】、<strong>事件的类型</strong>：I/O 多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件， 这两类事件和套接字操作之间的对应关系如下：<br>   ■  当套接字变得可读时（客户端对套接字执行 write 操作，或者执行 close 操作）， 或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 操作）， 套接字产生 AE_READABLE 事件。<br>   ■  当套接字变得可写时（客户端对套接字执行 read 操作）， 套接字产生 AE_WRITABLE 事件。</p><p><strong>I/O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 AE_READABLE 事件， 等到 AE_READABLE 事件处理完之后， 才处理 AE_WRITABLE 事件。这也就是说， 如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</strong><br> 【5】、API：ae.c/aeCreateFileEvent 函数接受一个套接字描述符、 一个事件类型、 以及一个事件处理器作为参数， 将给定套接字的给定事件加入到 I/O 多路复用程序的监听范围之内， 并对事件和事件处理器进行关联。</p><p>ae.c/aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参数， 让 I/O 多路复用程序取消对给定套接字的给定事件的监听， 并取消事件和事件处理器之间的关联。</p><p>ae.c/aeGetFileEvents 函数接受一个套接字描述符， 返回该套接字正在被监听的事件类型：</p><p>如果套接字没有任何事件被监听， 那么函数返回 AE_NONE 。<br>如果套接字的读事件正在被监听， 那么函数返回 AE_READABLE 。<br>如果套接字的写事件正在被监听， 那么函数返回 AE_WRITABLE 。<br>如果套接字的读事件和写事件正在被监听， 那么函数返回 AE_READABLE | AE_WRITABLE 。<br>ae.c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数， 在给定的时间内阻塞并等待套接字的给定类型事件产生， 当事件成功产生， 或者等待超时之后， 函数返回。</p><p>ae.c/aeApiPoll 函数接受一个 sys/time.h/struct timeval 结构为参数， 并在指定的时间內， 阻塞并等待所有被 aeCreateFileEvent 函数设置为监听状态的套接字产生文件事件， 当有至少一个事件产生， 或者等待超时后， 函数返回。</p><p>ae.c/aeProcessEvents 函数是文件事件分派器， 它先调用 aeApiPoll 函数来等待事件产生， 然后遍历所有已产生的事件， 并调用相应的事件处理器来处理这些事件。</p><p>ae.c/aeGetApiName 函数返回 I/O 多路复用程序底层所使用的 I/O 多路复用函数库的名称： 返回 “epoll” 表示底层为 epoll 函数库， 返回”select” 表示底层为 select 函数库， 诸如此类。</p><p> 【6】、<strong>文件事件的处理器</strong>：Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如：</p><p>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</p><p>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</p><p>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</p><p>当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。</p><p> <strong>在这些事件处理器里面， 服务器最常用的要数与客户端进行通信的连接应答处理器、 命令请求处理器和命令回复处理器。</strong> </p><p> 【7】、<strong>连接应答处理器</strong>：<code>networking.c/acceptTcpHandler</code> 函数是 Redis 的连接应答处理器， 这个处理器用于对连接服务器监听套接字的客户端进行应答， 具体实现为<code>sys/socket.h/accept</code> 函数的包装。 </p><p>当 Redis 服务器进行初始化的时候， 程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来， 当有客户端用sys/socket.h/connect 函数连接服务器监听套接字的时候， 套接字就会产生 AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作， 如图 IMAGE_SERVER_ACCEPT_CONNECT 所示。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache13.png" alt></p><p>【8】、<strong>命令请求处理器</strong>：networking.c/readQueryFromClient 函数是 Redis 的命令请求处理器， 这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为 unistd.h/read 函数的包装。</p><p>当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来， 当客户端向服务器发送命令请求的时候， 套接字就会产生 AE_READABLE 事件， 引发命令请求处理器执行， 并执行相应的套接字读入操作， 如图 IMAGE_SERVER_RECIVE_COMMAND_REQUEST 所示。</p><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache14.png" alt></p><p> 当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 <code>AE_WRITABLE</code> 事件之间的关联 </p><h3 id="三、客户端与-redis-的一次通信过程"><a href="#三、客户端与-redis-的一次通信过程" class="headerlink" title="三、客户端与 redis 的一次通信过程"></a><strong>三、客户端与 redis 的一次通信过程</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache15.png" alt></p><p>【1】客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p><p>【2】假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p><p>【3】如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。这样便完成了一次通信。</p><h3 id="四、为啥-redis-单线程模型也能效率这么高"><a href="#四、为啥-redis-单线程模型也能效率这么高" class="headerlink" title="四、为啥 redis 单线程模型也能效率这么高"></a><strong>四、为啥 redis 单线程模型也能效率这么高</strong></h3><p>■ 纯内存操作</p><p>■ 核心是基于非阻塞的 IO 多路复用机制</p><p>■ 单线程反而避免了多线程的频繁上下文切换问题 </p><h2 id="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"><a href="#二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点" class="headerlink" title="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"></a><strong>二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点</strong></h2><h3 id="为什么要有本地缓存？"><a href="#为什么要有本地缓存？" class="headerlink" title="为什么要有本地缓存？"></a>为什么要有本地缓存？</h3><p>在系统中，有些数据，数据量小，但是访问十分频繁（例如国家标准行政区域数据），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略。</p><h3 id="为什么是本地缓存，而不是分布式的集群缓存？"><a href="#为什么是本地缓存，而不是分布式的集群缓存？" class="headerlink" title="为什么是本地缓存，而不是分布式的集群缓存？"></a>为什么是本地缓存，而不是分布式的集群缓存？</h3><p>​     目前的数据，大多是业务无关的小数据缓存，没有必要搞分布式的集群缓存，目前涉及到订单和商品的数据，会直接走DB进行请求，再加上分布式缓存的构建，集群维护成本比较高，不太适合紧急的业务项目。</p><h3 id="本地缓存在那个区域？"><a href="#本地缓存在那个区域？" class="headerlink" title="本地缓存在那个区域？"></a>本地缓存在那个区域？</h3><p>​     目前考虑的是占用了JVM的heap区域，再细化一点的就是heap中的old区，目前的数据量来看，都是一些小数据，加起来没有几百兆，放在heap区域最快最方便。后期如果需要放置在本地缓存的数据大的时候，可以考虑在off-heap区域，但是off-heap区域的话，需要考虑对象的序列化（因为off-heap区域存储的是二进制的数据），另外一个的话就是off-heap的GC问题。其实，如果真的数据量比较大，那其实就可以考虑搞一个集中式的缓存系统，可以是单机，也可以是集群，来承担缓存的作用</p><h3 id="本地缓存和分布式缓存的比较："><a href="#本地缓存和分布式缓存的比较：" class="headerlink" title="本地缓存和分布式缓存的比较："></a>本地缓存和分布式缓存的比较：</h3><ul><li><p>分布式缓存一致性更好一点，本地缓存 每个实例都有自己的缓存，可能会存在不一致的情况。</p></li><li><p>本地缓存会占用堆内存，影响垃圾回收、影响系统性能。分布式缓存两大开销会导致其慢于本地缓存，网络延迟和对象序列化</p></li><li><p>进程内缓存适用于较小且频率可见的访问场景，尤其适用于不变对象，对于较大且不可预见的访问，最好采用分布式缓存。</p></li></ul><h2 id="二十二、本地缓存在并发使用时的注意事项"><a href="#二十二、本地缓存在并发使用时的注意事项" class="headerlink" title="二十二、本地缓存在并发使用时的注意事项"></a><strong>二十二、本地缓存在并发使用时的注意事项</strong></h2><p>使用本地缓存需要注意两个问题：</p><p>1 内存管理，及时解除无用对象的引用。防止大量无用对象进入old区，引发full gc。</p><p>2 数据同步，如果应用是一个集群，需要保持各台机器的数据一致性。</p><p>问题1的解决可以采用<strong>LRU算法</strong>( <strong><code>Least Recently Used</code></strong> )，预先定好缓存大小。达到最大值后，清除最近最少使用的对象。</p><p>问题2比较复杂，需要有一个集中的地方控制缓存一致，比如可以采用消息中间件，写时进行异步复制。这种方式成本较大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、什么是缓存？&quot;&gt;&lt;a href=&quot;#一、什么是缓存？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是缓存？&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、什么是缓存？&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;缓存就是数据交换的缓冲区（称作：Cache），
      
    
    </summary>
    
    
    
      <category term="Redis相关" scheme="https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>hashCode和equals</title>
    <link href="https://liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/"/>
    <id>https://liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/</id>
    <published>2020-03-04T07:59:33.000Z</published>
    <updated>2020-03-04T08:05:09.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p>用来判断两个对象是否相同，再Object类中是通过判断对象间的内存地址来决定是否相同 </p><p>equals() 方法用于比较两个对象是否相等，它与 == 相等比较符有着本质的不同。</p><p>在万物皆对象的 Java 体系中，系统把判断对象是否相等的权力交给程序员。具体的措施是把 equals() 方法写到 Object 类中，并让所有类继承 Object 类。 这样程序员就能在自定义的类中重写 equals() 方法, 从而实现自己的比较逻辑.</p><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p> 获取哈希码，也称为散列码，返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 </p><p>hashCode() 的意思是哈希值, 哈希值是经哈希函数运算后得到的结果，哈希函数能够保证相同的输入能够得到相同的输出(哈希值)，但是不能够保证不同的输入总是能得出不同的输出。</p><p>当输入的样本量足够大时，是会产生哈希冲突的，也就是说不同的输入产生了相同的输出。</p><p>暂且不谈冲突，就相同的输入能够产生相同的输出这点而言，是及其宝贵的。它使得系统只需要通过简单的运算，在时间复杂度O(1)的情况下就能得出数据的映射关系，根据这种特性，散列表应运而生。</p><p>一种主流的散列表实现是：用数组作为哈希函数的输出域，输入值经过哈希函数计算后得到哈希值。然后根据哈希值，在数组种找到对应的存储单元。当发生冲突时，对应的存储单元以链表的形式保存冲突的数据。</p><h1 id="hashCode-与-equals-之间的关系"><a href="#hashCode-与-equals-之间的关系" class="headerlink" title="hashCode() 与 equals() 之间的关系"></a>hashCode() 与 equals() 之间的关系</h1><p><img src="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/hashCode.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;equals&quot;&gt;&lt;a href=&quot;#equals&quot; class=&quot;headerlink&quot; title=&quot;equals()&quot;&gt;&lt;/a&gt;equals()&lt;/h2&gt;&lt;p&gt;用来判断两个对象是否相同，再Object类中是通过判断对象间的内存地址来决定是否相同 &lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>HashSet内部是如何工作的</title>
    <link href="https://liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"/>
    <id>https://liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/</id>
    <published>2020-03-04T07:47:57.000Z</published>
    <updated>2020-03-04T07:56:17.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h2><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以HashSet中所有 key 的都有一个默认 value。类似于HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p><h2 id="HashSet："><a href="#HashSet：" class="headerlink" title="HashSet："></a>HashSet：</h2><ul><li>实现了Set接口</li><li>HashSet依赖的数据结构是哈希表</li><li>因为实现的是Set接口，所以不允许有重复的值</li><li>插入到HashSet中的对象不保证与插入的顺序保持一致。对象的插入是根据它的hashcode</li><li>HashSet中允许有NULL值</li><li>HashSet也实现了Searlizable和Cloneable两个接口</li></ul><h2 id="HashSet的构造函数："><a href="#HashSet的构造函数：" class="headerlink" title="HashSet的构造函数："></a>HashSet的构造函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h = <span class="keyword">new</span> HashSet();      </span><br><span class="line">默认初始化大小是<span class="number">16</span>，默认装载因子是<span class="number">0.75</span>.</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity);  </span><br><span class="line">默认装载因子是<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor);</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(Collection C);</span><br></pre></td></tr></table></figure><h2 id="什么是初始化大小与装载因子："><a href="#什么是初始化大小与装载因子：" class="headerlink" title="什么是初始化大小与装载因子："></a>什么是初始化大小与装载因子：</h2><p>初始化尺寸就是当创建哈希表（HashSet内部用哈希表的数据结构）的时候桶（buckets）的数量。如果当前的尺寸已经满了，那么桶的数量会自动增长。</p><p>装载因子衡量的是在HashSet自动增长之前允许有多满。当哈希表中实体的数量已经超出装载因子与当前容量的积，那么哈希表就会再次进行哈希（也就是内部数据结构重建），这样哈希表大致有两倍桶的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">                    表中已经存储的元素的数量</span><br><span class="line"></span><br><span class="line">装载因子 = *-----------------------------------------*</span><br><span class="line"></span><br><span class="line">                    哈希表的大小</span><br></pre></td></tr></table></figure><p> 例如：如果内部容量为16，装载因子为0.75，那么当表中有12个元素的时候，桶的数量就会自动增长。 </p><p>性能影响：</p><p>装载因子和初始化容量是影响HashSet操作的两个主要因素。装载因子为0.75的时候可以提供关于时间和空间复杂度方面更有效的性能。如果我们加大这个装载因子，那么内存的上限就会减小（因为它减少了内部重建的操作），但是将影响哈希表中的add与查询的操作。为了减少再哈希操作，我们应该选择一个合适的初始化大小。如果初始化容量大于实体的最大数量除以装载因子，那么就不会有再哈希的动作发生了。</p><p>HashSet中的一些重要方法：</p><ul><li>boolean add(E e)：如果不存在则添加，存在则返回false。</li><li>void clear() ：移除Set中所有的元素</li><li>boolean contains(Object o)：如果这个元素在set中存在，那么返回true。</li><li>boolean remove(Object o)：如果这个元素在set中存在，那么从set中删除。</li><li>Iterator iterator()：返回set中这个元素的迭代器。</li></ul><h2 id="HashSet内部是如何工作的？"><a href="#HashSet内部是如何工作的？" class="headerlink" title="HashSet内部是如何工作的？"></a>HashSet内部是如何工作的？</h2><p> 所有Set接口的类内部都是由Map做支撑的。HashSet用HashMap对它的内部对象进行排序。你一定好奇输入一个值到HashMap，我们需要的是一个键值对，但是我们传给HashSet的是一个值。 </p><p>那么HashMap是如何排序的？</p><p>实际上我们插入到HashSet中的值在map对象中起的是键的作用，因为它的值Java用了一个常量。所以在键值对中所有的键的值都是一样的。</p><p>如果我们在Java Doc中看一下HashSet的实现，大致是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 1</span></span><br><span class="line"><span class="comment">// All the constructors are internally creating HashMap Object.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p> 如果我们看下HashSet中的add方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们可以注意到，HashSet类的add()方法内部调用的是HashMap的put()方法，通过你指定的值作为key，常量“PRESENT”作为值传过去。 </p><p> remove()也是用类似的方法工作。它内部调用的是Map接口的remove。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet操作的时间复杂度：</p><p>HashSet底层的数据结构是哈希表，所以HashSet的add，remove与查询（包括contain方法）的分摊（平均或者一般情况）时间复杂度是O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-中的-HashSet，内部是如何工作的？&quot;&gt;&lt;a href=&quot;#Java-中的-HashSet，内部是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;Java 中的 HashSet，内部是如何工作的？&quot;&gt;&lt;/a&gt;Java 中的 Has
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="https://liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>https://liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2020-03-04T07:30:28.000Z</published>
    <updated>2020-03-04T07:34:53.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：SUN提供的反射机制的类："><a href="#1：SUN提供的反射机制的类：" class="headerlink" title="1：SUN提供的反射机制的类："></a>1：SUN提供的反射机制的类：</h2><p>java.lang.Class<T></T></p><p>java.lang.reflect.Constructor<T></T></p><p>java.lang.reflect.Field</p><p>java.lang.reflect.Method</p><p>java.lang.reflect.Modifier</p><h2 id="2：什么是反射"><a href="#2：什么是反射" class="headerlink" title="2：什么是反射"></a>2：什么是反射</h2><p> JAVA反射机制是在运行状态中，对于任意一个类。都能都知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称之为java语言的反射机制； </p><h2 id="3：反射的作用"><a href="#3：反射的作用" class="headerlink" title="3：反射的作用"></a>3：反射的作用</h2><p>反编译 .class –à .java</p><p>通过反射机制可以访问java对象中的属性，方法，构造方法</p><h2 id="4：创建Class对象的三种方式"><a href="#4：创建Class对象的三种方式" class="headerlink" title="4：创建Class对象的三种方式"></a>4：创建Class对象的三种方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">China</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> String name;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">char</span> sex ;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span> ();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">super</span> ();</span><br><span class="line">           <span class="keyword">this</span> .name = name;</span><br><span class="line">           <span class="keyword">this</span> .age = age;</span><br><span class="line">           <span class="keyword">this</span> .sex = sex;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> name ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .name = name;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> age ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .age = age;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> sex ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">this</span> .sex = sex;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">          System. out .println(<span class="string">"吃了"</span> );</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayChina</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">          System. out .println(<span class="string">"作者："</span> + AUTHOR + <span class="string">"国籍："</span>+ NATIONAL );</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">char</span> sex)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           <span class="keyword">return</span> <span class="string">"姓名:"</span> + name + <span class="string">"年龄："</span>+ age + <span class="string">"性别:"</span> + sex;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          Person p1 = <span class="keyword">new</span> Person(<span class="string">"小明"</span> ,<span class="number">20</span>,<span class="string">'男'</span> );</span><br><span class="line">          Person p2 = <span class="keyword">new</span> Person(<span class="string">"小红"</span> ,<span class="number">23</span>,<span class="string">'女'</span> );</span><br><span class="line">    </span><br><span class="line">           <span class="comment">//创建Class对象的方式一：(对象.getClass())，获取person类中的字节码文件</span></span><br><span class="line">           Class class1 = p1.getClass();</span><br><span class="line">          System. out.println(p1.getClass().getName());</span><br><span class="line">           Class class2 = p2.getClass();</span><br><span class="line">          System. out.println(class1 == class2 );</span><br><span class="line">    </span><br><span class="line">          System. out.println(<span class="string">"=============================="</span> );</span><br><span class="line">           <span class="comment">//创建Class对象的方式二：(类.class:需要输入一个明确的类，任意一个类型都有一个静态的class属性)</span></span><br><span class="line">           Class class3 = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">          System. out.println(class1 == class2);</span><br><span class="line">    </span><br><span class="line">          System. out.println(<span class="string">"=============================="</span> );</span><br><span class="line">           <span class="comment">//创建Class对象的方式三：(forName():传入时只需要以字符串的方式传入即可)</span></span><br><span class="line">           <span class="comment">//通过Class类的一个forName（String className)静态方法返回一个Class对象，className必须是全路径名称；</span></span><br><span class="line">           <span class="comment">//Class.forName()有异常：ClassNotFoundException</span></span><br><span class="line">    </span><br><span class="line">           Class class4 = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">              class4 = Class.forName(<span class="string">"cn.itcast.Person"</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System. out.println(class4 == class3);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意：在开发中一般使用第三种方法，因为第三种接收的是一个字符串路径，将来可以通过配置文件获取，通用性好； </p><p> 4：newInstance()方法 —&gt; 获取class类型之后,可以创建该类型的对象 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span><span class="keyword">throws</span> InstantiationException,IllegalAccessException</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflect03</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class c1 = Class.forName(<span class="string">"com.itheima04.Test_20171106.Test_20171207.Person"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建此Class对象所表示类的一个新实例,</span></span><br><span class="line">    <span class="comment">//newInstance方法调用的是Person的空参数构造方法</span></span><br><span class="line">    Object o = c1.newInstance();</span><br><span class="line">    System.out.println(o.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：SUN提供的反射机制的类：&quot;&gt;&lt;a href=&quot;#1：SUN提供的反射机制的类：&quot; class=&quot;headerlink&quot; title=&quot;1：SUN提供的反射机制的类：&quot;&gt;&lt;/a&gt;1：SUN提供的反射机制的类：&lt;/h2&gt;&lt;p&gt;java.lang.Class&lt;T&gt;
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Map类</title>
    <link href="https://liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/"/>
    <id>https://liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/</id>
    <published>2020-03-04T06:02:37.000Z</published>
    <updated>2020-03-04T07:21:15.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map.png" alt></p><p> 下面针对各个实现类的特点做一些说明： </p><p> (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 </p><p> (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 </p><p> (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><p> 4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 </p><p> 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 </p><p> 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 </p><h1 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h1><p> 搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 </p><h2 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h2><p> 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map1.png" alt></p><p> 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ </p><p> (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 </p><p> (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</span><br></pre></td></tr></table></figure><p> 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 </p><p> 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 </p><p> 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line">   <span class="keyword">int</span> modCount;  </span><br><span class="line">   <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p> 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 </p><p> 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 </p><p> size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 </p><p> 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/liuqiyao_01/article/details/14475159">http://blog.csdn.net/liuqiyao_01/article/details/14475159</a>，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 </p><p> 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/v_july_v/article/details/6105630">http://blog.csdn.net/v_july_v/article/details/6105630</a>。 </p><h2 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h2><p> HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 </p><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><p> 不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。 </p><p> 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 </p><p> 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 </p><p> 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 </p><p> 下面举例说明下，n为table的长度。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map2.png" alt></p><h3 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h3><p> HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map3.png" alt></p><p> ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； </p><p> ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； </p><p> ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； </p><p> ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； </p><p> ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； </p><p> ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 </p><p> JDK1.8HashMap的put方法源码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 对key的hashCode()做hash</span></span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">// 步骤①：tab为空则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 步骤②：计算index，并对null做处理 </span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 步骤③：节点key存在，直接覆盖value</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 步骤④：判断该链为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 步骤⑤：该链为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key,value,<span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//链表长度大于8转换为红黑树进行处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                   <span class="comment">// key已经存在直接覆盖value</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))                                          <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 步骤⑥：超过最大容量 就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h3><p> 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 </p><p> 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line">     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line">     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line">    transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line">     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">           src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 </p><p> 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map4.png" alt></p><p> 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map5.png" alt></p><p> 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map6.png" alt></p><p> 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map7.png" alt></p><p> 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">     <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">     <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">     <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">         <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">             threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>，<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><p> 在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,String&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p><p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map8.png" alt></p><p>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p><p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。</p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map9.png" alt></p><p> e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map10.png" alt></p><p> 于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 </p><h1 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h1><p> HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 </p><h2 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h2><p>为了便于测试，我们先写一个类Key，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    Key(<span class="keyword">int</span> value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Key key = (Key) o;</span><br><span class="line">        <span class="keyword">return</span> value == key.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</span><br><span class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</span><br><span class="line">           map.put(Keys.of(i), i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</span><br><span class="line">           map.get(Keys.of(i));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">       System.out.println(endTime - beginTime);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</span><br><span class="line">           test(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map11.png" alt></p><p> 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 </p><h2 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h2><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 仍然执行main方法，得出的结果如下表所示： </p><p><img src="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/map12.png" alt></p><p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p><p>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h1><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p><p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p><p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p><p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p><p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>数组和链表数据结构描述，各自的时间复杂度</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2020-03-04T05:55:00.000Z</published>
    <updated>2020-03-04T05:57:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用"><a href="#两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用" class="headerlink" title="两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用"></a>两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用</h2><h2 id="一、各自的特点："><a href="#一、各自的特点：" class="headerlink" title="一、各自的特点："></a>一、各自的特点：</h2><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><p>数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。</p><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。</p><h2 id="二、数组和链表的区别："><a href="#二、数组和链表的区别：" class="headerlink" title="二、数组和链表的区别："></a>二、数组和链表的区别：</h2><p>1、从逻辑结构角度来看：</p><p>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。<br>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）<br>2、数组元素在栈区，链表元素在堆区；</p><p>3、从内存存储角度来看：</p><p>(静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。<br>链表从堆中分配空间, 自由度大但申请管理比较麻烦。<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot;&gt;&lt;a href=&quot;#两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot; class=&quot;headerlink&quot; title=&quot;两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用&quot;&gt;&lt;/a
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java8的新特性</title>
    <link href="https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-03-04T04:33:02.000Z</published>
    <updated>2020-03-04T05:52:32.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、接口的默认方法"><a href="#一、接口的默认方法" class="headerlink" title="一、接口的默认方法"></a><strong>一、接口的默认方法</strong></h2><p> Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);   <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);      <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure><p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p><p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p><h2 id="二、Lambda-表达式"><a href="#二、Lambda-表达式" class="headerlink" title="二、Lambda 表达式"></a>二、Lambda 表达式</h2><p> 首先看看在老版本的Java中是如何排列字符串的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</p><p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> Collections.sort(names, (String a, String b) -&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure><p> Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： </p><h2 id="三、函数式接口"><a href="#三、函数式接口" class="headerlink" title="三、函数式接口"></a>三、函数式接口</h2><p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p><p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p><p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p><h2 id="四、方法与构造函数引用"><a href="#四、方法与构造函数引用" class="headerlink" title="四、方法与构造函数引用"></a><strong>四、方法与构造函数引用</strong></h2><p> 前一节中的代码还可以通过静态方法引用来表示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p> Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);  <span class="comment">// "J"</span></span><br></pre></td></tr></table></figure><p> 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  String firstName;  </span><br><span class="line">  String lastName; </span><br><span class="line"></span><br><span class="line">  Person() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Person(String firstName, String lastName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 接下来我们指定一个用来创建Person对象的对象工厂接口： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure><p> 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 </p><h2 id="五、Lambda-作用域"><a href="#五、Lambda-作用域" class="headerlink" title="五、Lambda 作用域"></a><strong>五、Lambda 作用域</strong></h2><p> 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 </p><h2 id="六、访问局部变量"><a href="#六、访问局部变量" class="headerlink" title="六、访问局部变量"></a><strong>六、访问局部变量</strong></h2><p> 我们可以直接在lambda表达式中访问外层的局部变量： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); </span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p> 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =  (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p> 在lambda表达式中试图修改num同样是不允许的。 </p><h2 id="七、访问对象字段与静态变量"><a href="#七、访问对象字段与静态变量" class="headerlink" title="七、访问对象字段与静态变量"></a>七、访问对象字段与静态变量</h2><p> 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">   <span class="keyword">int</span> outerNum; </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">      outerNum = <span class="number">23</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">      outerStaticNum = <span class="number">72</span>;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、访问接口的默认方法"><a href="#八、访问接口的默认方法" class="headerlink" title="八、访问接口的默认方法"></a>八、访问接口的默认方法</h2><p> 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure><p> JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 </p><h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p> Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">predicate.test(<span class="string">"foo"</span>);       <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure><h3 id="Function-接口"><a href="#Function-接口" class="headerlink" title="Function 接口"></a>Function 接口</h3><p> Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line"></span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); </span><br><span class="line"></span><br><span class="line">backToString.apply(<span class="string">"123"</span>);   <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure><h3 id="Supplier-接口"><a href="#Supplier-接口" class="headerlink" title="Supplier 接口"></a>Supplier 接口</h3><p> Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();  <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure><h3 id="Consumer-接口"><a href="#Consumer-接口" class="headerlink" title="Consumer 接口"></a>Consumer 接口</h3><p> Consumer 接口表示执行在单个参数上的操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure><h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"></span><br><span class="line">comparator.compare(p1, p2);       <span class="comment">// &gt; 0</span></span><br><span class="line">comparator.reversed().compare(p1, p2); <span class="comment">// &lt; 0</span></span><br></pre></td></tr></table></figure><h3 id="Optional-接口"><a href="#Optional-接口" class="headerlink" title="Optional 接口"></a>Optional 接口</h3><p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p><p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"></span><br><span class="line">optional.isPresent();      <span class="comment">// true</span></span><br><span class="line">optional.get();         <span class="comment">// "bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);  <span class="comment">// "bam"</span></span><br><span class="line"></span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));   <span class="comment">// "b"</span></span><br></pre></td></tr></table></figure><h3 id="Stream-接口"><a href="#Stream-接口" class="headerlink" title="Stream 接口"></a>Stream 接口</h3><p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p><p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure><p> Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： </p><h3 id="Filter-过滤"><a href="#Filter-过滤" class="headerlink" title="Filter 过滤"></a><strong>Filter 过滤</strong></h3><p> 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"></span><br><span class="line"><span class="comment">// "aaa2", "aaa1"</span></span><br></pre></td></tr></table></figure><h3 id="Sort-排序"><a href="#Sort-排序" class="headerlink" title="Sort 排序"></a>Sort 排序</h3><p> 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .sorted()</span><br><span class="line">  .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "aaa1", "aaa2"</span></span><br></pre></td></tr></table></figure><p> 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> System.out.println(stringCollection);</span><br><span class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></span><br></pre></td></tr></table></figure><h3 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h3><p> 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">  .stream()</span><br><span class="line">  .map(String::toUpperCase)</span><br><span class="line">  .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">  .forEach(System.out::println); </span><br><span class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></span><br></pre></td></tr></table></figure><h3 id="Match-匹配"><a href="#Match-匹配" class="headerlink" title="Match 匹配"></a>Match 匹配</h3><p> Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> anyStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>)); </span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Count-计数"><a href="#Count-计数" class="headerlink" title="Count 计数"></a><strong>Count 计数</strong></h3><p> 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> startsWithB = </span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">    .count(); </span><br><span class="line"></span><br><span class="line">System.out.println(startsWithB);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="Reduce-规约"><a href="#Reduce-规约" class="headerlink" title="Reduce 规约"></a>Reduce 规约</h3><p> 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line"></span><br><span class="line">  stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"></span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure><h3 id="并行Streams"><a href="#并行Streams" class="headerlink" title="并行Streams"></a>并行Streams</h3><p> 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 </p><p>下面的例子展示了是如何通过并行Stream来提升性能：</p><p>首先我们创建一个没有重复元素的大表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> max = <span class="number">1000000</span>;</span><br><span class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">  UUID uuid = UUID.randomUUID();</span><br><span class="line">  values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后我们计算一下排序这个Stream要耗时多久， </p><p> 串行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 串行耗时: 899 ms </p><p> 并行排序： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure><p> // 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 </p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a><strong>Map</strong></h3><p> 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map.forEach((id, val) -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure><p> 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 </p><p> 下面的例子展示了map上的其他有用的函数： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</span><br><span class="line"></span><br><span class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</span><br><span class="line">map.containsKey(<span class="number">9</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(<span class="number">23</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p> 接下来展示如何在Map里删除一个键值全都匹配的项： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// val33 </span></span><br><span class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</span><br><span class="line">map.get(<span class="number">3</span>);       <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p> 另外一个有用的方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>); <span class="comment">// not found</span></span><br></pre></td></tr></table></figure><p>对Map的元素做合并也变得很容易了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9 </span></span><br><span class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(<span class="number">9</span>);       <span class="comment">// val9concat</span></span><br></pre></td></tr></table></figure><p> Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 </p><h2 id="九、Date-API"><a href="#九、Date-API" class="headerlink" title="九、Date API"></a><strong>九、Date API</strong></h2><p> java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： </p><h3 id="Clock-时钟"><a href="#Clock-时钟" class="headerlink" title="Clock 时钟"></a><strong>Clock 时钟</strong></h3><p> Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = clock.millis(); </span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);  <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure><h3 id="Timezones-时区"><a href="#Timezones-时区" class="headerlink" title="Timezones 时区"></a>Timezones 时区</h3><p> 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// prints all available timezone ids </span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure><h3 id="LocalTime-本地时间"><a href="#LocalTime-本地时间" class="headerlink" title="LocalTime 本地时间"></a>LocalTime 本地时间</h3><p> LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line"></span><br><span class="line"> LocalTime now2 = LocalTime.now(zone2); </span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);    <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);   <span class="comment">// -239</span></span><br></pre></td></tr></table></figure><p> LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(late);    <span class="comment">// 23:59:59 </span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">  DateTimeFormatter</span><br><span class="line">    .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">    .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);  <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure><h3 id="LocalDate-本地日期"><a href="#LocalDate-本地日期" class="headerlink" title="LocalDate 本地日期"></a><strong>LocalDate 本地日期</strong></h3><p> LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"></span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);  <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure><p>从字符串解析一个LocalDate类型和解析LocalTime一样简单： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line"></span><br><span class="line">   DateTimeFormatter</span><br><span class="line">    .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">    .withLocale(Locale.GERMAN); </span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);  <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure><p>LocalDateTime 本地日期时间</p><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。</p><p>LocalDateTime提供了一些能访问具体字段的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);   <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);     <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);  <span class="comment">// 1439</span></span><br></pre></td></tr></table></figure><p> 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">  .atZone(ZoneId.systemDefault())</span><br><span class="line">    .toInstant(); </span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);   <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure><p> 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =  DateTimeFormatter.ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>); </span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);   <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure><p> 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="noopener">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a> </p><h2 id="十、Annotation-注解"><a href="#十、Annotation-注解" class="headerlink" title="十、Annotation 注解"></a><strong>十、Annotation 注解</strong></h2><p> 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Hints &#123;</span><br><span class="line">  Hint[] value();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p><p> 例 1: 使用包装类当容器来存多个注解（老方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 例 2：使用多重注解（新方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hint hint = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hint);          <span class="comment">// null </span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hints</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotationsByType</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints2.length);     <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p> 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure><p> 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、接口的默认方法&quot;&gt;&lt;a href=&quot;#一、接口的默认方法&quot; class=&quot;headerlink&quot; title=&quot;一、接口的默认方法&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、接口的默认方法&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; Java 8允许我们给接口添加一个非抽象的方法实
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>动态代理与cglib实现的区别</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-03-04T03:54:58.000Z</published>
    <updated>2020-03-04T04:06:13.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ol><li>Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷；</li><li>Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上；</li><li>Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来。</li><li>InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。</li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul><li>JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。</li><li>JDK动态代理的基础是反射机制（method.invoke(对象，参数)）Proxy.newProxyInstance()</li></ul><h3 id="jdk动态代理代码"><a href="#jdk动态代理代码" class="headerlink" title="jdk动态代理代码"></a><strong>jdk动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; </span><br><span class="line">      <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.得到目标对象的类加载器</span></span><br><span class="line">        ClassLoader classLoader = target.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 2.得到目标对象的实现接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="comment">// 3.第三个参数需要一个实现invocationHandler接口的对象</span></span><br><span class="line">        Object newProxyInstance = Proxy.newProxyInstance(classLoader, interfaces, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个参数:代理对象.一般不使用;第二个参数:需要增强的方法;第三个参数:方法中的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        JDKProxyFactory proxy = <span class="keyword">new</span> JDKProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><p>​        原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a><strong>注意</strong>:</h3><p>​        jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。 </p><h3 id="cglib动态代理代码"><a href="#cglib动态代理代码" class="headerlink" title="cglib动态代理代码"></a><strong>cglib动态代理代码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123; </span><br><span class="line">      <span class="comment">//得到目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用构造方法传递目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyFactory</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建Enhancer</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//2.传递目标对象的class</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//3.设置回调操作</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数一:代理对象;参数二:需要增强的方法;参数三:需要增强方法的参数;参数四:需要增强的方法的代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法前......"</span>);</span><br><span class="line">        Object invoke = methodProxy.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"这是增强方法后......"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建对象</span></span><br><span class="line">        FoodServiceImpl foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">        <span class="comment">// 2.创建代理对象</span></span><br><span class="line">        CglibProxyFactory proxy = <span class="keyword">new</span> CglibProxyFactory(foodService);</span><br><span class="line">        <span class="comment">// 3.调用代理对象的增强方法,得到增强后的对象</span></span><br><span class="line">        FoodService createProxy = (FoodService) proxy.createProxy();</span><br><span class="line">        createProxy.makeChicken();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JDK动态代理&quot;&gt;&lt;a href=&quot;#JDK动态代理&quot; class=&quot;headerlink&quot; title=&quot;JDK动态代理&quot;&gt;&lt;/a&gt;JDK动态代理&lt;/h2&gt;&lt;h3 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>单例设计模式</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-03-04T02:29:37.000Z</published>
    <updated>2020-03-04T03:51:24.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、单例模式："><a href="#1、单例模式：" class="headerlink" title="1、单例模式："></a>1、单例模式：</h1><p>在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式</p><h1 id="2、单例模式的设计原则："><a href="#2、单例模式的设计原则：" class="headerlink" title="2、单例模式的设计原则："></a>2、单例模式的设计原则：</h1><p>1、构造方法私有化<br>2、在类中创建好该类对象<br>3、在类中，给外界提供获取该对象的公有方式 </p><h2 id="2-1饿汉式"><a href="#2-1饿汉式" class="headerlink" title="2.1饿汉式"></a>2.1饿汉式</h2><p>在加载类的同时，就要初始化静态成员变量，所以就同时将该类对象创建出来了<br>饿汉式：一有机会，马上就吃，不去等待。（一旦加载类型，马上创建对象） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例设计模式之饿汉式</span></span><br><span class="line"><span class="comment">//能多早创建对象就多早创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_SingtonleHunger</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SingtonHunger sh1 = SingtonHunger.getInstance();</span><br><span class="line">SingtonHunger sh2 = SingtonHunger.getInstance();</span><br><span class="line">System.out.println(sh1==sh2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonHunger</span></span>&#123;</span><br><span class="line"><span class="comment">//1.先私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonHunger</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//2.私有创建对象的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonHunger sh = <span class="keyword">new</span> SingtonHunger();</span><br><span class="line"><span class="comment">//3.通过创建对外界可见的方法来调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonHunger <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sh;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。 </p><h2 id="2-2懒汉式"><a href="#2-2懒汉式" class="headerlink" title="2.2懒汉式"></a>2.2懒汉式</h2><p>在加载类的时候，不同时创建该类对象，等到需要获取这个对象时，才去创建这个对象<br>懒汉式：不着急、能不创建的时候，就不创建，能拖就拖 </p><p>注意事项：<br>1、只有在sl == null的时候，才会创建对象<br>2、sl的判断和sl的赋值，不希望分离开，否则在多线程环境下，会出现多个对象的状态，所以sl的判断和sl的赋值，需要放到一个同步代码块中。<br>3、同步代码块的效率非常低，不是每次获取对象的时候，都需要判断锁对象，只有在sl为null的时候， 才应该判断锁对象，因此在外层需要嵌套一个if判断，判断sl是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单例模式之懒汉式</span></span><br><span class="line"><span class="comment">//能多晚创建对象就多晚创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2_SingletonLazy</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SingtonLazy sl1 = SingtonLazy.getInstance();</span><br><span class="line">SingtonLazy sl2 = SingtonLazy.getInstance();</span><br><span class="line">System.out.println(sl1==sl2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingtonLazy</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1.私有构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingtonLazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.私有创建对象的引用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingtonLazy sl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.提供对外公开的方法创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingtonLazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//最外层判断是否为空用来提高效率</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (SingtonLazy<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line"><span class="comment">//加上同步锁提高线程安全</span></span><br><span class="line"><span class="keyword">if</span> (sl == <span class="keyword">null</span>) &#123;</span><br><span class="line">sl = <span class="keyword">new</span> SingtonLazy();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种懒汉式</p><p>public class SingletonDemo2 {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo2 instance;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造器私有化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法同步，调用效率低</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonDemo2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">        instance=<span class="keyword">new</span> SingletonDemo2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种如果是多线程的，会有JVM 指令重排的机制，破坏其单例类，所以双重锁判断机制好一些</p><h2 id="2-3静态内部类实现"><a href="#2-3静态内部类实现" class="headerlink" title="2.3静态内部类实现"></a>2.3静态内部类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo3</span> </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonClassInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonDemo3 instance=<span class="keyword">new</span> SingletonDemo3();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo3</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo3 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonClassInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4枚举类"><a href="#2-4枚举类" class="headerlink" title="2.4枚举类"></a>2.4枚举类</h2><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonDemo4 &#123;</span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、单例模式：&quot;&gt;&lt;a href=&quot;#1、单例模式：&quot; class=&quot;headerlink&quot; title=&quot;1、单例模式：&quot;&gt;&lt;/a&gt;1、单例模式：&lt;/h1&gt;&lt;p&gt;在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式&lt;/p&gt;
&lt;h1 id=&quot;2、单
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="https://liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝和浅拷贝</title>
    <link href="https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-03-04T02:01:02.000Z</published>
    <updated>2020-03-04T02:20:23.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。<br> 比如说对象 A 和对象 B，二者都是 ClassC 的对象，具有成员变量 a 和 b，现在对对象 A 进行拷贝赋值给 B，也就是 B.a = A.a; B.b = A.b;</p><p>这时再去改变 B 的属性 a 或者 b 时，可能会遇到问题：假设 a 是基础数据类型，b 是引用类型。<br> 当改变 B.a 的值时，没有问题；<br> 当改变 B.b 的值时，同时也会改变 A.b 的值，因为其实上面的例子中只是把 A.b 赋值给了 B.b，因为是 b 引用类型的，所以它们是指向同一个地址的。这可能就会给我们使用埋下隐患。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。</span><br></pre></td></tr></table></figure><h1 id="拷贝分类"><a href="#拷贝分类" class="headerlink" title="拷贝分类"></a>拷贝分类</h1><p>上面的问题，其实就是因为对拷贝的不熟悉导致的。</p><p>根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种：</p><ul><li>浅拷贝 (<code>Shallow Copy</code>)</li><li>深拷贝 (<code>Deep Copy</code>)</li></ul><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><h2 id="1-浅拷贝介绍"><a href="#1-浅拷贝介绍" class="headerlink" title="1. 浅拷贝介绍"></a>1. 浅拷贝介绍</h2><p>浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</p><h2 id="2-浅拷贝特点"><a href="#2-浅拷贝特点" class="headerlink" title="2. 浅拷贝特点"></a>2. 浅拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。<br> (2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy.png" alt></p><h2 id="3-浅拷贝的实现"><a href="#3-浅拷贝的实现" class="headerlink" title="3. 浅拷贝的实现"></a>3. 浅拷贝的实现</h2><p>实现对象拷贝的类，需要实现 <code>Cloneable</code> 接口，并覆写 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//浅拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br></pre></td></tr></table></figure><p>输出的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:lishi],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject[Subject:<span class="number">1163157884</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><h2 id="1-深拷贝介绍"><a href="#1-深拷贝介绍" class="headerlink" title="1. 深拷贝介绍"></a>1. 深拷贝介绍</h2><p>通过上面的例子可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 <code>studentB</code> 的 <code>subject</code>，但是 <code>studentA</code> 的 <code>subject</code> 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。</span><br></pre></td></tr></table></figure><h2 id="2-深拷贝特点"><a href="#2-深拷贝特点" class="headerlink" title="2. 深拷贝特点"></a>2. 深拷贝特点</h2><p>(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。<br> (2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。<br> (3) 对于有多层对象的，每个对象都需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法，进而实现了对象的串行层层拷贝。<br> (4) 深拷贝相比于浅拷贝速度较慢并且花销较大。</p><p><img src="/liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/copy2.png" alt></p><h2 id="3-深拷贝的实现"><a href="#3-深拷贝的实现" class="headerlink" title="3. 深拷贝的实现"></a>3. 深拷贝的实现</h2><p>对于 <code>Student</code> 的引用类型的成员变量 <code>Subject</code> ，需要实现 <code>Cloneable</code> 并重写 <code>clone()</code> 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subject</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Subject: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",name:"</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 <code>Student</code> 的 <code>clone()</code> 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引用类型</span></span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line">    <span class="comment">//基础数据类型</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  重写clone()方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//深拷贝</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用父类的clone()方法</span></span><br><span class="line">            Student student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">            student.subject = (Subject) subject.clone();</span><br><span class="line">            <span class="keyword">return</span> student;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Student: "</span> + <span class="keyword">this</span>.hashCode() + <span class="string">",subject:"</span> + subject + <span class="string">",name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一样的使用方式 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> Subject(<span class="string">"yuwen"</span>);</span><br><span class="line">        Student studentA = <span class="keyword">new</span> Student();</span><br><span class="line">        studentA.setSubject(subject);</span><br><span class="line">        studentA.setName(<span class="string">"Lynn"</span>);</span><br><span class="line">        studentA.setAge(<span class="number">20</span>);</span><br><span class="line">        Student studentB = (Student) studentA.clone();</span><br><span class="line">        studentB.setName(<span class="string">"Lily"</span>);</span><br><span class="line">        studentB.setAge(<span class="number">18</span>);</span><br><span class="line">        Subject subjectB = studentB.getSubject();</span><br><span class="line">        subjectB.setName(<span class="string">"lishi"</span>);</span><br><span class="line">        System.out.println(<span class="string">"studentA:"</span> + studentA.toString());</span><br><span class="line">        System.out.println(<span class="string">"studentB:"</span> + studentB.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentA:[Student: <span class="number">460141958</span>,subject:[Subject:<span class="number">1163157884</span>,name:yuwen],name:Lynn,age:<span class="number">20</span>]</span><br><span class="line">studentB:[Student: <span class="number">1956725890</span>,subject:[Subject:<span class="number">356573597</span>,name:lishi],name:Lily,age:<span class="number">18</span>]</span><br></pre></td></tr></table></figure><p> 由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。&lt;br&gt; 比如说对象 A 和对象 B，二者都是 ClassC 的
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java内存溢出</title>
    <link href="https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    <id>https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/</id>
    <published>2020-03-02T02:16:07.000Z</published>
    <updated>2020-03-02T02:56:53.160Z</updated>
    
    <content type="html"><![CDATA[<p>–本文源自于《深入理解Java虚拟机》</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。</p><h2 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h2><p>​        Java堆用于储存对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象到达最大堆的容量之后，就会产生内存溢出异常。</p><p>java.lang.OutOfMem0ryError:Java  heap space</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*Vm Args:-Xms20m XMx20m -XX:+HeapDumpOnOUtOFMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; aList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">aList.add(<span class="string">"asdasdasdas"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">System.out.println(aList.size());</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决手段："><a href="#解决手段：" class="headerlink" title="解决手段："></a>解决手段：</h3><p>​        先通过内存映像分析工具（如：Eclipse Memory Analyzer）堆Dump出来的堆转储快照进行分析，重点确认内存中的对象是否是必要的，也就是药神分清楚到底是出现了内存泄漏还是内存溢出。</p><p>​        如果是内存泄漏，可以进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾回收器无法自动回收他们的。掌握了泄漏对象的类型信息，及GCRoots引用链的信息，就可以比较准确的定位出泄漏代码的 位置。</p><p>​        如果不是泄漏，就是在内存中对象还活着，应当检查虚拟机的堆参数（-Xmx与Xms）</p><h2 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h2><p>​        Java虚拟机规范中描述了两种异常</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(i++);</span><br><span class="line">a();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">JvmTest j = <span class="keyword">new</span> JvmTest();</span><br><span class="line">j.a();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><p>–待补</p><h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><p>–待补</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;–本文源自于《深入理解Java虚拟机》&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​        在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个
      
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://liudong-code.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>throw和throws的区别</title>
    <link href="https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-02-29T11:12:48.000Z</published>
    <updated>2020-02-29T11:18:05.497Z</updated>
    
    <content type="html"><![CDATA[<p><strong>抛出异常有三种形式</strong></p><ul><li>throw</li><li>throws</li><li>系统自动抛异常</li></ul><p><strong>一、系统自动抛异常</strong></p><p>当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常：（举个栗子）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b =<span class="number">0</span>; </span><br><span class="line">    System.out.println(<span class="number">5</span>/b);   <span class="comment">// 此处系统会自动抛出ArithmeticException异常</span></span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、throw</strong></p><p>throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">    String s = <span class="string">"abc"</span>; </span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123; </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      System.out.println(s); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//function(); </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>运行时，系统会抛出如下异常：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NumberFormatException at......</span><br></pre></td></tr></table></figure><p><strong>三、throws</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">当某个方法可能会抛出某种异常时用于<span class="keyword">throws</span> 声明可能抛出的异常，然后交给上层调用它的方法程序处理</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">testThrows</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> NumberFormatException </span>&#123; </span><br><span class="line">String s = <span class="string">"abc"</span>; </span><br><span class="line">System.out.println(Double.parseDouble(s)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">function(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; </span><br><span class="line">System.err.println(<span class="string">"非数据类型不能强制类型转换。"</span>); </span><br><span class="line"><span class="comment">//e.printStackTrace(); </span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 四、throw与throws的比较</p><p>throws出现在方法函数头；而throw出现在函数体。<br>throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。<br>两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p><p>五、编程习惯：</p><p>在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；<br>用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();<br>如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；<br>如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理</p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p><p>原文链接：<a href="https://blog.csdn.net/xsj_blog/article/details/83030450" target="_blank" rel="noopener">https://blog.csdn.net/xsj_blog/article/details/83030450</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;抛出异常有三种形式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;throw&lt;/li&gt;
&lt;li&gt;throws&lt;/li&gt;
&lt;li&gt;系统自动抛异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一、系统自动抛异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当程序语句出现一些逻
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>java中的异常链</title>
    <link href="https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/"/>
    <id>https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/</id>
    <published>2020-02-29T11:07:08.000Z</published>
    <updated>2020-02-29T11:11:28.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   ChainTest ct=<span class="keyword">new</span> ChainTest();<span class="comment">//创建chainTest实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     ct.test2();    </span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">  e.printStackTrace();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span><span class="keyword">throws</span> DrunkException</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> DrunkException(<span class="string">"喝车别开酒"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">     test1();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (DrunkException e)&#123;</span><br><span class="line"></span><br><span class="line">       RuntimeException newExc=<span class="keyword">new</span> RuntimeException(<span class="string">"司机一滴酒亲人两行泪"</span>)；<span class="comment">//含参构造器  </span></span><br><span class="line"></span><br><span class="line">       newExc.initCause(e);<span class="comment">//调用newExc的init方法，把捕获的DrunkException传进去</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">throw</span> newExc;<span class="comment">//抛出新异常</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;​        把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 &lt;
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java的异常体系</title>
    <link href="https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/"/>
    <id>https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/</id>
    <published>2020-02-29T10:54:18.000Z</published>
    <updated>2020-02-29T11:20:57.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java中异常的体系结构图解："><a href="#java中异常的体系结构图解：" class="headerlink" title="java中异常的体系结构图解："></a>java中异常的体系结构图解：</h3><p><img src="/liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/yichang.png" alt></p><p>​        java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。 </p><h3 id="java异常体系结构"><a href="#java异常体系结构" class="headerlink" title="java异常体系结构"></a><strong>java异常体系结构</strong></h3><p>​        Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：</p><p>1、Error与Exception<br>         Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。<br>         Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<br>2、运行时异常和非运行时异常<br>         运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>         非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p><h3 id="异常的捕获和处理"><a href="#异常的捕获和处理" class="headerlink" title="异常的捕获和处理"></a><strong>异常的捕获和处理</strong></h3><h4 id="try、catch、finally"><a href="#try、catch、finally" class="headerlink" title="try、catch、finally"></a>try、catch、finally</h4><p>  第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。<br>  第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。<br>  第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。<br>   第四：先Catch子类异常再Catch父类异常。 </p><h4 id="throw、throws关键字"><a href="#throw、throws关键字" class="headerlink" title="throw、throws关键字"></a>throw、throws关键字</h4><pre><code>throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方</code></pre><p>法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取</p><p>的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception  </span>&#123;  </span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"方法test中的Exception"</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;java中异常的体系结构图解：&quot;&gt;&lt;a href=&quot;#java中异常的体系结构图解：&quot; class=&quot;headerlink&quot; title=&quot;java中异常的体系结构图解：&quot;&gt;&lt;/a&gt;java中异常的体系结构图解：&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/liudong
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>如何格式化日期</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/</id>
    <published>2020-02-29T10:42:07.000Z</published>
    <updated>2020-02-29T11:24:29.516Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        String date = localDate.format(dateTimeFormatter);</span><br><span class="line">        System.out.println(<span class="string">"date:"</span>+date)；</span><br></pre></td></tr></table></figure><p> 补充:java的时间日期API一直以来都是被诟病的东西,为了解决这一问题,java8中引入了新的时间日期API,其中包括LocalDate,LocalTime,LocalDate,LocalDateTime,Clock,Instant等类,这些的类的设计都使用了不变模式,因此是线程安全的设计.</p><p>原文链接：<a href="https://blog.csdn.net/riju4713/article/details/88220120" target="_blank" rel="noopener">https://blog.csdn.net/riju4713/article/details/88220120</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/</id>
    <published>2020-02-29T10:35:58.000Z</published>
    <updated>2020-02-29T10:38:33.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可以被继承，代码如下"><a href="#可以被继承，代码如下" class="headerlink" title="可以被继承，代码如下"></a>可以被继承，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span></span>&#123;</span><br><span class="line"><span class="comment">//空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line">oneFn</span><br><span class="line">One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br><span class="line">one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span><br></pre></td></tr></table></figure><h3 id="不能被重写，代码如下"><a href="#不能被重写，代码如下" class="headerlink" title="不能被重写，代码如下"></a>不能被重写，代码如下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被重写？以及原因？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"one"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"oneFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> <span class="keyword">extends</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String one_1 = <span class="string">"two"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">oneFn</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"TwoFn"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">One one = <span class="keyword">new</span> Two();</span><br><span class="line">one.oneFn();</span><br><span class="line">String one_1 = One.one_1;</span><br><span class="line">System.out.println(<span class="string">"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_1);</span><br><span class="line">String one_12 = one.one_1;</span><br><span class="line">System.out.println(<span class="string">"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>+one_12);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果如下</span></span><br><span class="line"><span class="comment">//oneFn</span></span><br><span class="line"><span class="comment">//One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br><span class="line"><span class="comment">//one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one</span></span><br></pre></td></tr></table></figure><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。</p><p>注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;可以被继承，代码如下&quot;&gt;&lt;a href=&quot;#可以被继承，代码如下&quot; class=&quot;headerlink&quot; title=&quot;可以被继承，代码如下&quot;&gt;&lt;/a&gt;可以被继承，代码如下&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>string转换成integer的方式及原理</title>
    <link href="https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/"/>
    <id>https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-29T10:04:02.000Z</published>
    <updated>2020-02-29T10:23:45.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string转换成integer的方式及原理"><a href="#string转换成integer的方式及原理" class="headerlink" title="string转换成integer的方式及原理"></a>string转换成integer的方式及原理</h1><h4 id="1-Integer-parseInt（String-str）方法"><a href="#1-Integer-parseInt（String-str）方法" class="headerlink" title="1. Integer.parseInt（String str）方法"></a>1. Integer.parseInt（String str）方法</h4><p>​      源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span> <span class="keyword">throws</span> NumberFormatException </span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> parseInt(s,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Integer-parseInt（String-s-int-radix）方法"><a href="#2-Integer-parseInt（String-s-int-radix）方法" class="headerlink" title="2. Integer.parseInt（String s, int radix）方法"></a>2. Integer.parseInt（String s, int radix）方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span> <span class="keyword">throws</span> NumberFormatException</span>&#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * WARNING: This method may be invoked early during VM initialization</span></span><br><span class="line"><span class="comment">         * before IntegerCache is initialized. Care must be taken to not use</span></span><br><span class="line"><span class="comment">         * the valueOf method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//基数是否小于最小基数</span></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException(<span class="string">"radix "</span> + radix +</span><br><span class="line">                                            <span class="string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否是负数</span></span><br><span class="line">        <span class="keyword">boolean</span> negative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="comment">//最大值限制</span></span><br><span class="line">        <span class="keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> multmin;</span><br><span class="line">        <span class="keyword">int</span> digit;</span><br><span class="line"><span class="comment">//判断字符长度是否大于0，否则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//第一个字符是否是符号</span></span><br><span class="line">            <span class="keyword">char</span> firstChar = s.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//根据ascii码表看出加号(43)和负号(45)对应的</span></span><br><span class="line">            <span class="comment">//十进制数小于‘0’(48)的</span></span><br><span class="line">            <span class="keyword">if</span> (firstChar &lt; <span class="string">'0'</span>) &#123; <span class="comment">// Possible leading "+" or "-"</span></span><br><span class="line">                 <span class="comment">//是负号</span></span><br><span class="line">                <span class="keyword">if</span> (firstChar == <span class="string">'-'</span>) &#123;</span><br><span class="line">                    <span class="comment">//负号属性设置为true</span></span><br><span class="line">                    negative = <span class="keyword">true</span>;</span><br><span class="line">                    limit = Integer.MIN_VALUE;</span><br><span class="line">                    <span class="comment">//不是负号也不是加号则抛出异常</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstChar != <span class="string">'+'</span>)</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"><span class="comment">//如果有符号（加号或者减号）且字符串长度为1，则抛出异常</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            multmin = limit / radix;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">                <span class="comment">//此方法为确定数字的的十进制值</span></span><br><span class="line">                digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">                <span class="comment">//小于0，则为非数值字符串</span></span><br><span class="line">                <span class="keyword">if</span> (digit &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                 <span class="comment">//result第一次为0，第一次肯定为true</span></span><br><span class="line">                <span class="keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//result乘以基数（10）为得到位置</span></span><br><span class="line">                <span class="comment">//例如第一次的result为-1，第二次乘以10后为-10</span></span><br><span class="line">                <span class="comment">//下面再-=digit（例如：1）则得到-11</span></span><br><span class="line">                <span class="comment">//以此类推</span></span><br><span class="line">                result *= radix;</span><br><span class="line">                <span class="keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第一次result为0 -=digit则为负值的该digit</span></span><br><span class="line">                result -= digit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//根据上面得到的是否负数，返回相应的值</span></span><br><span class="line">        <span class="keyword">return</span> negative ? result : -result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-Character-digit-char-ch-int-radix-方法"><a href="#3-Character-digit-char-ch-int-radix-方法" class="headerlink" title="3.Character.digit(char ch, int radix)方法"></a>3.Character.digit(char ch, int radix)方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">digit</span><span class="params">(<span class="keyword">int</span> codePoint, <span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基数必须再最大和最小基数之间</span></span><br><span class="line">        <span class="keyword">if</span> (radix &lt; MIN_RADIX || radix &gt; MAX_RADIX) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (codePoint &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            <span class="comment">// Optimized for ASCII</span></span><br><span class="line">            <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//字符在0-9字符之间</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'0'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                result = codePoint - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符在a-z之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                result = <span class="number">10</span> + (codePoint - <span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符在A-Z之间</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= codePoint &amp;&amp; codePoint &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">                result = <span class="number">10</span> + (codePoint - <span class="string">'A'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过判断result和基数大小，输出对应值</span></span><br><span class="line">            <span class="comment">//通过我们parseInt对应的基数值为10，</span></span><br><span class="line">            <span class="comment">//所以，只能在第一个判断（字符在0-9字符之间）</span></span><br><span class="line">            <span class="comment">//中得到result值 否则后续程序会抛出异常</span></span><br><span class="line">            <span class="keyword">return</span> result &lt; radix ? result : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digitImpl(codePoint, radix);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结：integer.parseInt(string str)方法调用Integer内部的 parseInt(string str,10)方法,默认基数为10，parseInt内部首先 判断字符串是否包含符号（-或者+），则对相应的negative和limit进行 赋值，然后再循环字符串，对单个char进行数值计算Character.digit(char ch, int radix) 在这个方法中，函数肯定进入到0-9字符的判断（相对于string转换到int）， 否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;string转换成integer的方式及原理&quot;&gt;&lt;a href=&quot;#string转换成integer的方式及原理&quot; class=&quot;headerlink&quot; title=&quot;string转换成integer的方式及原理&quot;&gt;&lt;/a&gt;string转换成integer的方式及
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>序列化的方式</title>
    <link href="https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/</id>
    <published>2020-02-29T03:23:06.000Z</published>
    <updated>2020-02-29T09:53:38.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>序列化：将对象转化成一个字节序列，便于储存。</p><p>反序列化：将字节化的字节序列还原。</p><p> 优点：可以实现对象的”持久性”， 所谓持久性就是指对象的生命周期不取决于程序。 </p><h2 id="序列化的几种方式"><a href="#序列化的几种方式" class="headerlink" title="序列化的几种方式"></a>序列化的几种方式</h2><h3 id="Java原生的序列化"><a href="#Java原生的序列化" class="headerlink" title="Java原生的序列化"></a>Java原生的序列化</h3><pre><code>**序列化需要：**   所需类：ObjectInputStream和ObjectOutputStream   方法： readObject()和writeObject(); </code></pre><h4 id="隐式序列化"><a href="#隐式序列化" class="headerlink" title="隐式序列化"></a>隐式序列化</h4><p>​        实现Serializabie接口，通过实现Serializable接口，这种是隐式序列化(不需要手动)，这种是最简单的序列化方式，会自动序列化所有非static和 transient关键字修饰的成员变量。  </p><p>​        </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpConfig</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> virualAge = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String ipAdress =<span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IpConfig</span><span class="params">(String name, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=i;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"name: "</span> + name + <span class="string">"\n"</span></span><br><span class="line">                +<span class="string">"age: "</span> + age + <span class="string">"\n"</span></span><br><span class="line">                +<span class="string">"virualAge: "</span> + virualAge + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"ipAdress: "</span> + ipAdress;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建可序列化对象</span></span><br><span class="line">        System.out.println(<span class="string">"原来的对象："</span>);</span><br><span class="line">        IpConfig ipConfig = <span class="keyword">new</span> IpConfig(<span class="string">"Ming"</span>, <span class="number">16</span>);</span><br><span class="line">        System.out.println(ipConfig);</span><br><span class="line">        <span class="comment">//创建序列化输出流</span></span><br><span class="line">        ByteArrayOutputStream  outputStream=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream  objectOutputStream=<span class="keyword">new</span> ObjectOutputStream(outputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将序列化对象存入缓冲区</span></span><br><span class="line">        objectOutputStream.writeObject(ipConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//改值</span></span><br><span class="line">        ipConfig.SetAge(<span class="number">11</span>);</span><br><span class="line">        IpConfig.virualAge=<span class="number">5555</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从缓冲区取回被序列化的对象</span></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(outputStream.toByteArray()));</span><br><span class="line">        IpConfig newIpconfig = (IpConfig) in.readObject();</span><br><span class="line">        System.out.println(<span class="string">"序列化后取出的对象："</span>);</span><br><span class="line">        System.out.println(newIpconfig);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">原来的对象：</span><br><span class="line">name: Ming</span><br><span class="line">age: <span class="number">16</span></span><br><span class="line">virualAge: <span class="number">123</span></span><br><span class="line">address: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">序列化后取出的对象：</span><br><span class="line">name: Ming</span><br><span class="line">age: <span class="number">16</span></span><br><span class="line">virualAge: <span class="number">5555</span></span><br><span class="line">address: <span class="keyword">null</span></span><br></pre></td></tr></table></figure><p>​        发现ipAddress(被transient)和virualAge(被static)也没有被序列化，中途修改virualAge的值是为了以防读者误会virualAge被序列化了。因为序列化可以保存对象的状态，但是virualAge的值被改变了，说明没有被序列化。static成员不属于对象实例，可能被别的对象修改没办法序列化,序列化是序列对象。对于address被反序列化后由于没有对应的引用，所以为null。而且Serializable不会调用构造方法。</p><h4 id="显式序列化"><a href="#显式序列化" class="headerlink" title="显式序列化"></a>显式序列化</h4><p>​        实现Externalizable接口</p><p>​        Externalizable接口继承自Serializable, 我们在实现该接口时，必须实现writeExternal()和readExternal()方法，而且只能通过手动进行序列化，并且两个方法是自动调用的，因此，这个序列化过程是可控的，可以自己选择哪些部分序列化 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blip</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Blip</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Blip</span><span class="params">(String x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Blip (String x, int a)"</span>);</span><br><span class="line">s = x;</span><br><span class="line">i = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s+i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Blip.writeExternal"</span>);</span><br><span class="line">out.writeObject(s);</span><br><span class="line">out.writeInt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Blip.readExternal"</span>);</span><br><span class="line">s = (String)in.readObject();</span><br><span class="line">i = in.readInt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Constructing objects"</span>);</span><br><span class="line">Blip b = <span class="keyword">new</span> Blip(<span class="string">"A Stirng"</span>, <span class="number">47</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">ObjectOutputStream o = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"F://Demo//file1.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"保存对象"</span>);</span><br><span class="line">o.writeObject(b);</span><br><span class="line">o.close();</span><br><span class="line"><span class="comment">//获得对象</span></span><br><span class="line">System.out.println(<span class="string">"获取对象"</span>);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span>          FileInputStream(<span class="string">"F://Demo//file1.txt"</span>));</span><br><span class="line">System.out.println(<span class="string">"Recovering b"</span>);</span><br><span class="line">b = (Blip)in.readObject();</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">打印结果为：</span><br><span class="line">Constructing objects</span><br><span class="line">Blip (String x, <span class="keyword">int</span> a)</span><br><span class="line">A Stirng47</span><br><span class="line">保存对象</span><br><span class="line">Blip.writeExternal</span><br><span class="line">获取对象</span><br><span class="line">Recovering b</span><br><span class="line">Blip.readExternal</span><br><span class="line">A Stirng47</span><br><span class="line">当注释掉writeExternal和readExternal方法后打印结果为:</span><br><span class="line">Constructing objects</span><br><span class="line">Blip (String x, <span class="keyword">int</span> a)</span><br><span class="line">A Stirng47</span><br><span class="line">保存对象</span><br><span class="line">Blip.writeExternal</span><br><span class="line">获取对象</span><br><span class="line">Recovering b</span><br><span class="line">Blip.readExternal</span><br><span class="line">null0</span><br></pre></td></tr></table></figure><pre><code>说明：Externalizable类会调用public的构造函数先初始化对象，在调用所保存的内容将对象还原。假如构造方法不是public则会出现运行时错误。 </code></pre><h4 id="显式-隐式的实现"><a href="#显式-隐式的实现" class="headerlink" title="显式+隐式的实现"></a>显式+隐式的实现</h4><p>​        如果想将方式一和方式二的优点都用到的话，可以采用方式三， 先实现Serializable接口，并且添加writeObject()和readObject()方法。注意这里是添加，不是重写或者覆盖。但是添加的这两个方法必须有相应的格式。</p><p>1，方法必须要被private修饰                                —–&gt;才能被调用<br>2，第一行调用默认的defaultRead/WriteObject(); —–&gt;隐式序列化非static和transient<br>3，调用read/writeObject()将获得的值赋给相应的值  —&gt;显式序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerDemo</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">transient</span> <span class="keyword">int</span> age = <span class="number">23</span>;</span><br><span class="line"><span class="keyword">public</span> String name ;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"默认构造器。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SerDemo</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">stream.defaultWriteObject();</span><br><span class="line">stream.writeInt(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException </span>&#123;</span><br><span class="line">stream.defaultReadObject();</span><br><span class="line">age = stream.readInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"年龄"</span> + age + <span class="string">"  "</span> + name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">SerDemo stu = <span class="keyword">new</span> SerDemo(<span class="string">"Ming"</span>);</span><br><span class="line">ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">out.writeObject(stu);</span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray()));</span><br><span class="line">SerDemo stu1 = (SerDemo) in.readObject();</span><br><span class="line">System.out.println(stu1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">打印结果为：</span><br><span class="line">年龄<span class="number">23</span>  Ming</span><br><span class="line">注释掉stream.writeInt(age)和age= stream.readInt()后：</span><br><span class="line">年龄<span class="number">0</span>  Ming</span><br><span class="line">方式三结合了显式和隐式序列化，Ming被正常序列化，由于age被trancient修饰，所以需要显式序列化。</span><br></pre></td></tr></table></figure><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>​        Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonSerialize</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> JsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] writeValueAsBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            writeValueAsBytes = mapper.writeValueAsBytes(u);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"json serialize: "</span> + (System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + writeValueAsBytes.length);</span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = mapper.readValue(writeValueAsBytes, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"json deserialize: "</span> + (System.currentTimeMillis() - t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json serialize: <span class="number">55</span>ms; 总大小：<span class="number">341</span></span><br><span class="line">json deserialize: <span class="number">35</span>ms; User: User [userId=<span class="keyword">null</span>, userName=张三, passWord=<span class="number">123456</span>, userInfo=张三是一个很牛逼的人, friends=[User [userId=<span class="keyword">null</span>, userName=李四, passWord=<span class="number">123456</span>, userInfo=李四是一个很牛逼的人, friends=<span class="keyword">null</span>], User [userId=<span class="keyword">null</span>, userName=王五, passWord=<span class="number">123456</span>, userInfo=王五是一个很牛逼的人, friends=<span class="keyword">null</span>]]]</span><br></pre></td></tr></table></figure><h3 id="FastJson序列化"><a href="#FastJson序列化" class="headerlink" title="FastJson序列化"></a>FastJson序列化</h3><p>​        fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本<br>支持Android。使用时候需引入FastJson第三方jar包。FastJson序列化代码示例如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FastJsonSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化  </span></span><br><span class="line">        Long t1 = System.currentTimeMillis();</span><br><span class="line">        String text = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            text = JSON.toJSONString(u); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"fastJson serialize: "</span> +(System.currentTimeMillis() - t1) + <span class="string">"ms; 总大小："</span> + text.getBytes().length);</span><br><span class="line">        <span class="comment">//反序列化  </span></span><br><span class="line">        Long t2 = System.currentTimeMillis();</span><br><span class="line">        User user = JSON.parseObject(text, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(<span class="string">"fastJson serialize: "</span> + (System.currentTimeMillis() -t2) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ProtoBuff序列化"><a href="#ProtoBuff序列化" class="headerlink" title="ProtoBuff序列化"></a>ProtoBuff序列化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</span><br><span class="line"></span><br><span class="line">优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。</span><br><span class="line"></span><br><span class="line">缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。</span><br><span class="line"></span><br><span class="line">其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。</span><br></pre></td></tr></table></figure><p>参考地址： <a href="https://github.com/google/protobuf。" target="_blank" rel="noopener">https://github.com/google/protobuf。</a> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.FieldType;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.annotation.Protobuf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7890663945232864573L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.INT32, required = <span class="keyword">false</span>, order = <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.STRING, required = <span class="keyword">false</span>, order = <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">private</span> String userInfo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Protobuf</span>(fieldType = FieldType.OBJECT, required = <span class="keyword">false</span>, order = <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; friends;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassWord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassWord</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserInfo</span><span class="params">(String userInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userInfo = userInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getFriends</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFriends</span><span class="params">(List&lt;User&gt; friends)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.friends = friends;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName + <span class="string">", passWord="</span> + passWord + <span class="string">", userInfo="</span> + userInfo</span><br><span class="line">                + <span class="string">", friends="</span> + friends + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> jprotobuf序列化代码示例如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.Codec;</span><br><span class="line"><span class="keyword">import</span> com.baidu.bjf.remoting.protobuf.ProtobufProxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> liqqc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBuffSerialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ProtoBuffSerialize().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>)</span>;</span><br><span class="line"></span><br><span class="line">        User u2 = <span class="keyword">new</span> User();</span><br><span class="line">        List&lt;User&gt; friends = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        u2.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">        u2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        u2.setUserInfo(<span class="string">"张三是一个很牛逼的人"</span>);</span><br><span class="line">        u2.setFriends(friends);</span><br><span class="line"></span><br><span class="line">        User f1 = <span class="keyword">new</span> User();</span><br><span class="line">        f1.setUserName(<span class="string">"李四"</span>);</span><br><span class="line">        f1.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f1.setUserInfo(<span class="string">"李四是一个很牛逼的人"</span>);</span><br><span class="line"></span><br><span class="line">        User f2 = <span class="keyword">new</span> User();</span><br><span class="line">        f2.setUserName(<span class="string">"王五"</span>);</span><br><span class="line">        f2.setPassWord(<span class="string">"123456"</span>);</span><br><span class="line">        f2.setUserInfo(<span class="string">"王五是一个很牛逼的人"</span>);</span><br><span class="line">        friends.add(f1);</span><br><span class="line">        friends.add(f2);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_encode = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            bytes = studentClassCodec.encode(u2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf序列化耗时："</span> + (System.currentTimeMillis() - stime_jpb_encode) + <span class="string">"ms; 总大小："</span> + bytes.length);</span><br><span class="line"></span><br><span class="line">        Long stime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        User user = studentClassCodec.decode(bytes);</span><br><span class="line">        Long etime_jpb_decode = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"jprotobuf反序列化耗时："</span>+ (etime_jpb_decode-stime_jpb_decode) + <span class="string">"ms; User: "</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jprotobuf序列化耗时：<span class="number">9</span>ms; 总大小：<span class="number">148</span></span><br><span class="line">jprotobuf反序列化耗时：<span class="number">0</span>ms; User: User [userId=null, userName=张三, passWord=<span class="number">123456</span>, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=<span class="number">123456</span>, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=<span class="number">123456</span>, userInfo=王五是一个很牛逼的人, friends=null]]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;序列化：将对象转化成一个字节序列，便于储存。&lt;/p&gt;
&lt;p&gt;反序列化：将字节化的字节序列还原。&lt;/p&gt;
&lt;p&gt; 优点：可以实现对象的”持久性
      
    
    </summary>
    
    
    
      <category term="Java基础知识" scheme="https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用技术以及epoll实现原理</title>
    <link href="https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-28T10:57:13.000Z</published>
    <updated>2020-02-28T11:36:18.863Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么Redis中要使用I-O多路复用呢？"><a href="#为什么Redis中要使用I-O多路复用呢？" class="headerlink" title="为什么Redis中要使用I/O多路复用呢？"></a>为什么Redis中要使用I/O多路复用呢？</h3><p>​        redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。</p><p>​        redis 采用网络IO多路复用技来保证在多连接的时候， 系统的高吞吐量。</p><p>​        Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的.</p><p>​        select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。<br>​        redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。</p><h3 id="epoll实现机制"><a href="#epoll实现机制" class="headerlink" title="epoll实现机制"></a>epoll实现机制</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设想一下如下场景：</span><br><span class="line">有<span class="number">100</span>万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的</span><br><span class="line">(事实上大部分场景都是这种情况)。如何实现这样的高并发？</span><br></pre></td></tr></table></figure><p>​        select/poll是，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p><p>​        如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p><h4 id="总结：select和poll的缺点如下："><a href="#总结：select和poll的缺点如下：" class="headerlink" title="总结：select和poll的缺点如下："></a>总结：select和poll的缺点如下：</h4><ol><li>每次调用select/poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大</li><li>同时每次调用select/poll都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大</li><li>针对select支持的文件描述符数量太小了，默认是1024</li><li>select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件；</li><li>select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。</li><li>相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。</li></ol><p>​        epoll的设计和实现与select完全不同。epoll是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。</p><p>​        epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先select/poll调用分成了3个部分：</p><p>1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源)</p><p>2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字</p><p>3）调用epoll_wait收集发生的事件的连接</p><p>​        如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。</p><h4 id="总结：epoll的优点"><a href="#总结：epoll的优点" class="headerlink" title="总结：epoll的优点"></a>总结：epoll的优点</h4><ol><li>epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, <strong>一般来说这个数目和系统内存关系很大</strong> ，具体数目可以 cat /proc/sys/fs/file-max 察看。</li><li>效率提升， epoll 最大的优点就在于它<strong>只管你“活跃”的连接</strong> ，而跟连接总数无关，因此在实际的网络环境中， epoll 的效率就会远远高于 select 和 poll 。</li><li>内存拷贝， epoll 在这点上使用了“共享内存”，这个内存拷贝也省略了</li></ol><h3 id="redis-epoll底层实现"><a href="#redis-epoll底层实现" class="headerlink" title="redis epoll底层实现"></a>redis epoll底层实现</h3><p>​        当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关</p><p><strong>eventpoll结构体如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll｛</span><br><span class="line">.....</span><br><span class="line"><span class="comment">/*红黑树节点的根，存储着所有添加到epoll中的需要监控的事件*/</span></span><br><span class="line">struct rb_root  rbt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*双链表中储存着将要通过epoll_wait返回给用户满足条件的事件*/</span></span><br><span class="line">struct list_head  rdlist;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure><p>​        每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事<br>件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。</p><p>​        而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p><p>​        在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span><span class="comment">//红黑树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span><span class="comment">//双向链表节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filedfd</span> <span class="title">ffd</span>;</span><span class="comment">//句柄事件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span> ;</span><span class="comment">// 指向其所属的eventpoll对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>;</span><span class="comment">//期待发生的事件类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户</p><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><ol><li>不用重复传递。我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</li><li>在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。<br>epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</li><li>极其高效的原因：<br>这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里<br>建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</li></ol><h4 id="这个准备就绪list链表是怎么维护的呢？"><a href="#这个准备就绪list链表是怎么维护的呢？" class="headerlink" title="这个准备就绪list链表是怎么维护的呢？"></a>这个准备就绪list链表是怎么维护的呢？</h4><p>​        当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个<br>socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。（注：好好理解这句话！）</p><p>​        从上面这句可以看出，epoll的基础就是回调呀！</p><p>​        如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p><p>​        最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。关于LT，ET，有一端描述，LT和ET都是电子里面的术语，ET是边缘触发，LT是水平触发，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。</p><p>​        LT, ET这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，<br>epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么Redis中要使用I-O多路复用呢？&quot;&gt;&lt;a href=&quot;#为什么Redis中要使用I-O多路复用呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么Redis中要使用I/O多路复用呢？&quot;&gt;&lt;/a&gt;为什么Redis中要使用I/O多路复用呢？&lt;/
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="Redis相关" scheme="https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>常见的IO模型</title>
    <link href="https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/"/>
    <id>https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-28T09:35:29.000Z</published>
    <updated>2020-02-29T11:22:38.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="高性能IO模型，常见的有四种："><a href="#高性能IO模型，常见的有四种：" class="headerlink" title="高性能IO模型，常见的有四种："></a>高性能IO模型，常见的有四种：</h3><p>（1）同步阻塞IO（Blocking IO）：即传统的IO模型。</p><p>（2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。</p><p>（3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。</p><p>（4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。</p><h3 id="IO模型举例理解1"><a href="#IO模型举例理解1" class="headerlink" title="IO模型举例理解1"></a>IO模型举例理解1</h3><ol><li><p>阻塞IO, 给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不<br> 会做其他事情, 属于备胎做法.</p></li><li><p>非阻塞IO, 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会<br> 做其他事情, 属于专一做法.</p></li><li><p>IO多路复用, 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便<br>看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么? 3.1 select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子 </p></li></ol><p>3.2 poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神</p><p>3.3 epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于同步等待状态</p><ol start="4"><li>接下来是异步IO的情况 你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了,女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口. 此时属于逆袭做法</li></ol><h3 id="IO模型举例理解2"><a href="#IO模型举例理解2" class="headerlink" title="IO模型举例理解2"></a>IO模型举例理解2</h3><p>1.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。</p><p>2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。</p><p>3.I/O复用模型</p><ul><li>select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次</li><li>epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话</li></ul><p>4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话</p><p>5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话</p><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p>​        同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。</p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E4%B8%80%E8%88%ACIO.png" alt></p><ol><li>等待数据就绪（读就绪、写就绪）；</li><li>将数据从内核中拷贝到JVM进程中；</li><li>处理数据。</li></ol><p>​        <strong>整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够</strong></p><h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png" alt></p><p>​        由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程<br>需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。</p><p>伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">read</span>(socket, <span class="built_in">buffer</span>) != SUCCESS);</span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>​        IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。</p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt></p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A82.png" alt></p><p>​         用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。 </p><p>​        从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p>​        但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。</p><p>​        用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p>用户线程使用IO多路复用模型的伪代码描述为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UserEventHandler::handle_event() &#123;</span><br><span class="line">    <span class="keyword">if</span>(can_read(socket)) &#123;</span><br><span class="line">read(socket, buffer);</span><br><span class="line">        process(buffer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">Reactor.register(<span class="keyword">new</span> UserEventHandler(socket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的<br>EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reactor::handle_events() &#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">sockets = select();</span><br><span class="line"><span class="keyword">for</span>(socket in sockets) &#123;</span><br><span class="line">get_event_handler(socket).handle_event();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器<br>handle_event函数即可。<br>​        IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>​        “真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。</p><p><strong>异步IO模型使用了Proactor设计模式实现了这一机制。</strong></p><p><img src="/liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/%E5%BC%82%E6%AD%A5IO.png" alt></p><p>异步IO模型中，</p><ul><li>用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核，</li><li>然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。</li><li>最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。</li></ul><p>用户线程使用异步IO模型的伪代码描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UserCompletionHandler::handle_event</span><span class="params">(<span class="built_in">buffer</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">buffer</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">aio_read(socket, <span class="keyword">new</span> UserCompletionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。</p><p>相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;高性能IO模型，常见的有四种：&quot;&gt;&lt;a href=&quot;#高性能IO模型，常见的有四种：&quot; class=&quot;headerlink&quot; title=&quot;高性能IO模型，常见的有四种：&quot;&gt;&lt;/a&gt;高性能IO模型，常见的有四种：&lt;/h3&gt;&lt;p&gt;（1）同步阻塞IO（Blocking
      
    
    </summary>
    
    
    
      <category term="IO模型" scheme="https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
</feed>
