<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><meta name="keywords" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/liudong-code.github.io/favicon.ico"><link rel="bookmark" href="/liudong-code.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/liudong-code.github.io/atom.xml"><title>MySql数据库 | code</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySql数据库</h1><a id="logo" href="/liudong-code.github.io/.">code</a><p class="description">码总</p></div><div id="nav-menu"><a href="/liudong-code.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/liudong-code.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/liudong-code.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/liudong-code.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">MySql数据库</h1><div class="post-meta"><a href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/#comments" class="comment-count"></a><p><span class="date">Mar 07, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、数据库隔离级别（详见七）"><a href="#一、数据库隔离级别（详见七）" class="headerlink" title="一、数据库隔离级别（详见七）"></a>一、数据库隔离级别（详见七）</h2><p>四种隔离级别（SQL92标准）：<br>现在来看看MySQL数据库为我们提供的四种隔离级别（由低到高）：</p>
<p>① Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<p>② Read committed (RC，读已提交)：可避免脏读的发生。</p>
<p>③ Repeatable read (RR，可重复读)：可避免脏读、不可重复读的发生。</p>
<p>（注意事项：InnoDB的RR还可以解决幻读，主要原因是Next-Key锁，只有RR才能使用Next-Key锁）</p>
<p>④ Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。<br>（由MVCC降级为Locking-Base CC）</p>
<h2 id="二、MYSQL有哪些存储引擎，各自优缺点"><a href="#二、MYSQL有哪些存储引擎，各自优缺点" class="headerlink" title="二、MYSQL有哪些存储引擎，各自优缺点"></a>二、MYSQL有哪些存储引擎，各自优缺点</h2><table>
<thead>
<tr>
<th>MyISAM</th>
<th>高速引擎，拥有较高的插入，查询速度，但不支持事务、不支持行锁、支持3种不同的存储格式。包括静态型、动态型和压缩型。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>InnoDB</strong></td>
<td><strong>5.5版本后MySQL的默认数据库，支持事务和行级锁定，事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，比MyISAM处理速度稍慢、支持外键（FOREIGN KEY）</strong></td>
</tr>
<tr>
<td>ISAM</td>
<td>MyISAM的前身，MySQL5.0以后不再默认安装</td>
</tr>
<tr>
<td>MRG_MyISAM（MERGE）</td>
<td>将多个表联合成一个表使用，在超大规模数据存储时很有用</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td><strong>内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失</strong></td>
</tr>
<tr>
<td>Falcon</td>
<td>一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者</td>
</tr>
<tr>
<td>Archive</td>
<td>将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作</td>
</tr>
<tr>
<td>CSV</td>
<td>存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换)</td>
</tr>
</tbody></table>
<p><strong>存储引擎的选型：</strong><br><strong>InnoDB</strong>：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</p>
<p><strong>MyISAM</strong>：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</p>
<p><strong>MEMORY</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，不需要持久保存，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<p><strong>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</strong></p>
<h2 id="三、高并发下，如何做到安全的修改同一行数据"><a href="#三、高并发下，如何做到安全的修改同一行数据" class="headerlink" title="三、高并发下，如何做到安全的修改同一行数据"></a>三、高并发下，如何做到安全的修改同一行数据</h2><h3 id="1、使用悲观锁"><a href="#1、使用悲观锁" class="headerlink" title="1、使用悲观锁"></a>1、使用悲观锁</h3><p>悲观锁本质是当前只有一个线程执行操作，排斥外部请求的修改。遇到加锁的状态，就必须等待。结束了唤醒其他线程进行处理。虽然此方案的确解决了数据安全的问题，但是，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常。</p>
<h3 id="2、FIFO（First-Input-First-Output，先进先出）缓存队列思路"><a href="#2、FIFO（First-Input-First-Output，先进先出）缓存队列思路" class="headerlink" title="2、FIFO（First Input First Output，先进先出）缓存队列思路"></a><strong>2、FIFO（First Input First Output，先进先出）缓存队列思路</strong></h3><p>直接将请求放入队列中，就不会导致某些请求永远获取不到锁。</p>
<h3 id="3、使用乐观锁"><a href="#3、使用乐观锁" class="headerlink" title="3、使用乐观锁"></a><strong>3、使用乐观锁</strong></h3><p>这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号（Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。</p>
<h3 id="4、Zookeeper-锁"><a href="#4、Zookeeper-锁" class="headerlink" title="4、Zookeeper 锁"></a>4、Zookeeper 锁</h3><p> 基于异常的分布式锁（基于临时节点）<br>创建不带序号的节点， 创建成功获得锁， 创建不成功， 会抛出异常， 监听lock 节点， 当lock 删除时，再重新去创建节点 </p>
<h2 id="四、SQL执行计划"><a href="#四、SQL执行计划" class="headerlink" title="四、SQL执行计划"></a>四、SQL执行计划</h2><h3 id="一、执行计划是什么？"><a href="#一、执行计划是什么？" class="headerlink" title="一、执行计划是什么？"></a>一、执行计划是什么？</h3><p> 执行计划，简单的来说，是SQL在数据库中执行时的表现情况,通常用于SQL性能分析,优化等场景。在MySQL中使用 explain 关键字来查看 </p>
<h3 id="二、查看执行计划"><a href="#二、查看执行计划" class="headerlink" title="二、查看执行计划"></a>二、查看执行计划</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN + sql语句</span><br></pre></td></tr></table></figure>

<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql.png" alt></p>
<h3 id="三、MySQL执行计划分析"><a href="#三、MySQL执行计划分析" class="headerlink" title="三、MySQL执行计划分析"></a>三、MySQL执行计划分析</h3><ul>
<li>sql如何使用索引</li>
<li>联接查询的执行顺序</li>
<li>查询扫描的数据行数</li>
</ul>
<h3 id="四、各个字段的含义"><a href="#四、各个字段的含义" class="headerlink" title="四、各个字段的含义"></a>四、各个字段的含义</h3><p><strong>ID</strong></p>
<ul>
<li>id列中的数据为一组数字，表示执行select语句顺序</li>
<li>id值相同时，执行顺序由上至下</li>
<li>id值越大优先级越高，越先被执行</li>
</ul>
<p><strong>SELECT_TYPE</strong></p>
<p>查询的类型，主要是用于区分普通查询、联合查询、子查询等复杂的查询。</p>
<ul>
<li>SIMPLE：简单的select查询，查询中不包含子查询或者union</li>
<li>PRIMARY：查询中包含任何复杂的子部分，最外层查询则被标记为primary</li>
<li>SUBQUERY：在select 或 where列表中包含了子查询</li>
<li>DERIVED：在from列表中包含的子查询被标记为derived（衍生），mysql会递归执行这些子查询，把结果放在临时表里</li>
<li>UNION：若第二个select出现在union之后，则被标记为union；若union包含在from子句的子查询中，外层select将被标记为derived</li>
<li>UNION RESULT：从union表获取结果的select</li>
<li>DEPENDENT SUBQUERY: 依赖外部结果的子查询</li>
<li>DEPENDENT UNION: 当union作为子查询时，第二或是第二个后的查询的 select_type值<br> /article/details/91349161</li>
</ul>
<p><strong>TABLE</strong></p>
<ul>
<li>输出数据行所在的表的名称</li>
<li>如果不涉及对数据表的操作，那么这显示为null</li>
<li>如果显示为尖括号括起来的就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于<br>这个查询产生。</li>
<li>&lt; unionM,N&gt;由ID为M,N查询union产生的结果集</li>
<li>&lt; derivedN&gt;/&lt; subqueryN&gt; 由Id为n的查询产生的结果</li>
</ul>
<p><strong>PARTITIONS</strong></p>
<ul>
<li>对于分区表，显示查询的分区ID</li>
<li>对于非分区表，显示的为 NULL</li>
</ul>
<p><strong>TYPE</strong></p>
<p>访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p><strong>system</strong> 这是const联接类型的一个特例，当查询的表只有一行时使用</p>
<p><strong>const</strong>：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引。因为只需匹配一行数据，所有很快。如果将主键置于where列表中，mysql就能将该查询转换为一个const</p>
<p><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描。</p>
<p><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行。本质是也是一种索引访问，它返回所有匹配某个单独值的行，然而他可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</p>
<p><strong>ref_or_null</strong> 类似于 ref类型的查询，但是附加了对 null 值列的查询</p>
<p><strong>range</strong>：只检索给定范围的行，使用一个索引来选择行。key列显示使用了那个索引。一般就是在where语句中出现了between、&lt;、&gt;、in等的查询。这种索引列上的范围扫描比全索引扫描要好。只需要开始于某个点，结束于另一个点，不用扫描全部索引</p>
<p><strong>index：Full</strong> Index Scan，index与ALL区别为index类型只遍历索引树。这通常为ALL块，应为索引文件通常比数据文件小。（Index与ALL虽然都是读全表，但index是从索引中读取，而ALL是从硬盘读取）</p>
<p><strong>ALL：Full</strong> Table Scan，遍历全表以找到匹配的行</p>
<p><strong>index</strong>：关键字：条件是出现在索引树中的节点的。可能没有完全匹配索引</p>
<p>索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可<br>以使用索引排序或者分组的查询。</p>
<p><strong>POSSIBLE_KEYS</strong></p>
<ul>
<li>指出mysql能使用哪些索引来优化查询</li>
<li>查询列所涉及的列上的索引都会被列出来，但不一定会被使用</li>
</ul>
<p><strong>KEY</strong></p>
<ul>
<li>实际使用的索引，如果为NULL，则没有使用索引。</li>
<li>查询中如果使用了覆盖索引，则该索引仅出现在key列表中。</li>
</ul>
<p><strong>REF</strong></p>
<ul>
<li>如果是使用的常数等值查询，这里会显示const</li>
<li>如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段</li>
<li>如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</li>
</ul>
<p><strong>ROWS</strong></p>
<ul>
<li>表示msql通过索引的统计信息，估算的所需读取的行数</li>
<li>rows值的大小时个统计抽样的结果，并不十分的准确</li>
</ul>
<p><strong>extra（重要）</strong></p>
<p>distinct ：在select部分使用了distinct关键字</p>
<p>no tables used：不带from字句的查询或者From dual查询</p>
<p>使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。</p>
<p>using filesort（重要）</p>
<ul>
<li>​    排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中</li>
<li>​    说明MySQL会使用一个外部的索引排序，而不是按照索引顺序进行读取。</li>
<li>​    MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
</ul>
<p>using index（重要）</p>
<p>查询时不需要回表查询，直接通过索引就可以获取查询的数据。</p>
<p>​        表示相应的SELECT查询中使用到了覆盖索引（Covering Index），避免访问表的数据行，效率不错！<br>​        如果同时出现Using Where ，说明索引被用来执行查找索引键值<br>​        如果没有同时出现Using Where ，表明索引用来读取数据而非执行查找动作。</p>
<p>using temporary</p>
<p>​    表示使用了临时表存储中间结果。<br>​    MySQL在对查询结果order by和group by时使用临时表<br>​    临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。</p>
<p>using where（重要）</p>
<ul>
<li>表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。</li>
<li>查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了</li>
</ul>
<h2 id="五、MySQL索引"><a href="#五、MySQL索引" class="headerlink" title="五、MySQL索引"></a>五、MySQL索引</h2><h3 id="a-索引是什么"><a href="#a-索引是什么" class="headerlink" title="a.索引是什么"></a>a.索引是什么</h3><p>​        官方介绍索引是帮助MySQL高效获取数据的数据结构。更通俗的说，数据库索引好比是一本书前面的目<br>录，能加快数据库的查询速度。</p>
<h3 id="b-索引的优势和劣势"><a href="#b-索引的优势和劣势" class="headerlink" title="b.索引的优势和劣势"></a>b.索引的优势和劣势</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。 – 检索</p>
<p>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。 –排序</p>
<ul>
<li>被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。</li>
<li>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</li>
<li>where 索引列 在存储引擎层 处理</li>
<li>覆盖索引 select 字段 字段是索引</li>
</ul>
<h4 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h4><p>索引会占据磁盘空间</p>
<p><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件</p>
<h3 id="c-索引的分类"><a href="#c-索引的分类" class="headerlink" title="c.索引的分类"></a>c.索引的分类</h3><p>​    单列索引<br>​    组合索引 *<br>​    全文索引<br>​    空间索引<br>​    位图索引 Oracle</p>
<h3 id="d-索引的使用"><a href="#d-索引的使用" class="headerlink" title="d.索引的使用"></a>d.索引的使用</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><h5 id="单列索引之普通索引"><a href="#单列索引之普通索引" class="headerlink" title="单列索引之普通索引"></a>单列索引之普通索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name (<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br></pre></td></tr></table></figure>

<h5 id="单列索引之唯一索引"><a href="#单列索引之唯一索引" class="headerlink" title="单列索引之唯一索引"></a>单列索引之唯一索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name(<span class="keyword">column</span>);</span><br></pre></td></tr></table></figure>

<h5 id="单列索引之全文索引"><a href="#单列索引之全文索引" class="headerlink" title="单列索引之全文索引"></a>单列索引之全文索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> FULLTEXT <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span>(<span class="keyword">column</span>(<span class="keyword">length</span>)) ;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> fulltext index_name(<span class="keyword">column</span>)</span><br></pre></td></tr></table></figure>

<h5 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> article <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_titme_time (title(<span class="number">50</span>),<span class="built_in">time</span>(<span class="number">10</span>)) ;</span><br></pre></td></tr></table></figure>



<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> <span class="keyword">table</span></span><br></pre></td></tr></table></figure>

<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name \G</span><br></pre></td></tr></table></figure>

<h3 id="e-索引原理分析"><a href="#e-索引原理分析" class="headerlink" title="e.索引原理分析"></a>e.索引原理分析</h3><h4 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h4><ul>
<li>索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引</li>
<li>MyISAM和InnoDB存储引擎：只支持B+ TREE索引， 也就是说默认使用BTREE，不能够更换</li>
<li>MEMORY/HEAP存储引擎：支持HASH和BTREE索引</li>
</ul>
<p>B树和B+树<br>数据结构示例网站：<br><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p>
<h4 id="B树图示"><a href="#B树图示" class="headerlink" title="B树图示"></a>B树图示</h4><p>B树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个<br>分支，即多叉）平衡查找树。 多叉平衡</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql2.png" alt></p>
<p>B树的高度一般都是在2-4这个高度，树的高度直接影响IO读写的次数。</p>
<p>如果是三层树结构—支撑的数据可以达到20G，如果是四层树结构—支撑的数据可以达到几十T</p>
<h4 id="B和B-的区别"><a href="#B和B-的区别" class="headerlink" title="B和B+的区别"></a>B和B+的区别</h4><p>​    B树和B+树的最大区别在于非叶子节点是否存储数据的问题。</p>
<p>​    B树是非叶子节点和叶子节点都会存储数据。</p>
<p>​    B+树只有叶子节点才会存储数据，而且存储的数据都是在一行上，而且这些数据都是有指针指向的，也就是有顺序的。</p>
<h4 id="非聚集索引（MyISAM）"><a href="#非聚集索引（MyISAM）" class="headerlink" title="非聚集索引（MyISAM）"></a>非聚集索引（MyISAM）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql3.png" alt></p>
<p>叶子节点下面保存的是数据的地址，再由地址去找到真正的数据</p>
<h5 id="辅助索引（次要索引）"><a href="#辅助索引（次要索引）" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h5><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql4.png" alt></p>
<h4 id="聚集索引（InnoDB）"><a href="#聚集索引（InnoDB）" class="headerlink" title="聚集索引（InnoDB）"></a>聚集索引（InnoDB）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql5.png" alt></p>
<p>叶子节点上 挂着所有的数据</p>
<p>主键索引数</p>
<p>主键：<br>1、建主键<br>2、没建主键<br>找唯一字段 当主键<br>自动生成伪列 当主键<br>主键创建<br>自增整数<br>不要用大字符串比如 uuid</p>
<h4 id="辅助索引（次要索引）-1"><a href="#辅助索引（次要索引）-1" class="headerlink" title="辅助索引（次要索引）"></a>辅助索引（次要索引）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql6.png" alt></p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql7.png" alt></p>
<p>辅助索引的叶子节点下面储存的是  主键值</p>
<h4 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h4><p>select * from t where name=’Alice’ 给name做了索引，查询全部，但是在索引树上面没有全部的数据，就照成了回表。</p>
<p>解决方案：用组合索引对查询的值形成覆盖。</p>
<p>聚集索引是MyISAM采用的索引形式，B+Tree的叶子节点存储的是数据的地址</p>
<p>非聚集索引是INNODB引擎采用的索引形式，B+Tree的叶子节点存储的是字段的值</p>
<h3 id="f-索引的使用场景"><a href="#f-索引的使用场景" class="headerlink" title="f.索引的使用场景"></a>f.索引的使用场景</h3><p><strong>哪些情况需要创建索引</strong><br>1、主键自动建立唯一索引<br>2、频繁作为查询条件的字段应该创建索引<br>3、多表关联查询中，关联字段应该创建索引 on 两边都要创建索引<br>4、查询中排序的字段，应该创建索引 B + tree 有顺序<br>5、覆盖索引 好处是？ 不需要回表 组合索引<br>6、统计或者分组字段，应该创建索引</p>
<p><strong>哪些情况不需要创建索引</strong><br>1、表记录太少 索引是要有存储的开销<br>2、频繁更新 索引要维护<br>3、查询字段使用频率不高</p>
<h3 id="g-组合索引"><a href="#g-组合索引" class="headerlink" title="g.组合索引"></a>g.组合索引</h3><p>由多个字段组成的索引 使用顺序就是创建的顺序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">'table_name'</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name(col1,col2,col3）</span><br></pre></td></tr></table></figure>

<p><strong>使用：</strong><br><strong>遵循最左前缀原则</strong><br><strong>1、前缀索引</strong><br><strong>like 常量% 使用索引 like %常量 不使用索引</strong><br><strong>2、最左前缀</strong><br><strong>从左向右匹配直到遇到范围查询 &gt; &lt; between 索引失效</strong></p>
<h3 id="h-索引失效"><a href="#h-索引失效" class="headerlink" title="h.索引失效"></a>h.索引失效</h3><h4 id="1-全值匹配我最爱"><a href="#1-全值匹配我最爱" class="headerlink" title="1.全值匹配我最爱"></a>1.全值匹配我最爱</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name='zhaoyun' and age=1 and sex='1';</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_name_age_sex | idx_name_age_sex | <span class="number">312</span></span><br><span class="line">| <span class="keyword">const</span>,<span class="keyword">const</span>,<span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------------------+------+-----------------------+</span><br><span class="line">条件与索引一一对应</span><br></pre></td></tr></table></figure>

<h4 id="2-最佳左前缀法则"><a href="#2-最佳左前缀法则" class="headerlink" title="2.最佳左前缀法则"></a>2.最佳左前缀法则</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组合索引 : 带头索引不能死，中间索引不能断</span><br></pre></td></tr></table></figure>

<p>如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且不跳过索引中的列。</p>
<h4 id="3-不要在索引上做计算"><a href="#3-不要在索引上做计算" class="headerlink" title="3.不要在索引上做计算"></a>3.不要在索引上做计算</h4><h4 id="4-范围条件右边的列失效"><a href="#4-范围条件右边的列失效" class="headerlink" title="4.范围条件右边的列失效"></a>4.范围条件右边的列失效</h4><p>不能继续使用索引中范围条件（bettween、&lt;、&gt;、in等）右边的列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name='asd' and age&gt;20 and sex='1';</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | range | idx_name_age_sex | idx_name_age_sex | <span class="number">308</span></span><br><span class="line">| <span class="literal">NULL</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br></pre></td></tr></table></figure>

<h4 id="5-尽量使用覆盖索引"><a href="#5-尽量使用覆盖索引" class="headerlink" title="5.尽量使用覆盖索引"></a>5.尽量使用覆盖索引</h4><h4 id="6-索引字段上不要使用不等"><a href="#6-索引字段上不要使用不等" class="headerlink" title="6.索引字段上不要使用不等"></a>6.索引字段上不要使用不等</h4><p>索引字段上使用（！= 或者 &lt; &gt;）判断时，会导致索引失效而转向全表扫描</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where loginname!='zhy';</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows</span><br><span class="line">| Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_loginname | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="number">1</span></span><br><span class="line">| Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="7-主键索引字段上不可以判断null"><a href="#7-主键索引字段上不可以判断null" class="headerlink" title="7.主键索引字段上不可以判断null"></a>7.主键索引字段上不可以判断null</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">主键字段上不可以使用 null</span><br><span class="line">索引字段上使用 is null 判断时，可使用索引</span><br><span class="line">mysql&gt; explain select * from tuser where name is null;</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_name_age_sex | idx_name_age_sex | <span class="number">303</span></span><br><span class="line">| <span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+------------------+------------------+-------</span><br><span class="line">--+-------+------+-----------------------+</span><br><span class="line"><span class="number">1</span> <span class="function">row in <span class="title">set</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">mysql&gt; explain select * from tuser where loginname is null</span>;</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len |</span><br><span class="line">ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ref | idx_loginname | idx_loginname | <span class="number">303</span> |</span><br><span class="line"><span class="keyword">const</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+---</span><br><span class="line">----+------+-----------------------+</span><br></pre></td></tr></table></figure>

<h4 id="8-索引字段使用like不以通配符开头"><a href="#8-索引字段使用like不以通配符开头" class="headerlink" title="8.索引字段使用like不以通配符开头"></a>8.索引字段使用like不以通配符开头</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">索引字段使用like以通配符开头（‘%字符串’）时，会导致索引失效而转向全表扫描</span><br><span class="line">mysql&gt; explain select * from tuser where name like 'a%';</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key |</span><br><span class="line">key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | range | idx_name_age_sex | idx_name_age_sex | <span class="number">303</span></span><br><span class="line">| <span class="literal">NULL</span> | <span class="number">1</span> | Using index condition |</span><br><span class="line">+----+-------------+-------+-------+------------------+------------------+------</span><br><span class="line">---+------+------+-----------------------+</span><br><span class="line">mysql&gt; explain select * from tuser where name like '%a';</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref | rows</span><br><span class="line">| Extra |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="number">2</span></span><br><span class="line">| Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+-----</span><br><span class="line">-+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="9-索引字段字符串要加单引号"><a href="#9-索引字段字符串要加单引号" class="headerlink" title="9.索引字段字符串要加单引号"></a>9.索引字段字符串要加单引号</h4><p>索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from tuser where name=<span class="number">123</span>;</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref |</span><br><span class="line">rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_name_age_sex | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"><span class="number">2</span> | Using where |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="10-索引字段不要使用or"><a href="#10-索引字段不要使用or" class="headerlink" title="10.索引字段不要使用or"></a>10.索引字段不要使用or</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">索引字段使用 <span class="keyword">or</span> 时，会导致索引失效而转向全表扫描</span><br><span class="line">mysql&gt; explain select * from tuser where name='asd' or age=23;</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key | key_len | ref |</span><br><span class="line">rows | Extra |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br><span class="line">| <span class="number">1</span> | SIMPLE | tuser | ALL | idx_name_age_sex | <span class="literal">NULL</span> | <span class="literal">NULL</span> | <span class="literal">NULL</span> |</span><br><span class="line"><span class="number">2</span> | Using where |</span><br><span class="line">+----+-------------+-------+------+------------------+------+---------+------+--</span><br><span class="line">----+-------------+</span><br></pre></td></tr></table></figure>

<h4 id="11-口诀"><a href="#11-口诀" class="headerlink" title="11.口诀"></a>11.口诀</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">全值匹配我最爱，最左前缀要遵守 </span><br><span class="line">带头大哥不能死，中间兄弟不能断 </span><br><span class="line">索引列上少计算，范围之后全失效 </span><br><span class="line">LIKE符号写最右，覆盖索引不写星 </span><br><span class="line">不等空值还有or，索引失效要少用 </span><br><span class="line">var引号不能丢，SQL高级也不难 </span><br><span class="line">分组之前必排序，一定要上索引啊</span><br></pre></td></tr></table></figure>



<h2 id="六、数据库MySQL锁"><a href="#六、数据库MySQL锁" class="headerlink" title="六、数据库MySQL锁"></a>六、数据库MySQL锁</h2><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql1.png" alt></p>
<h3 id="一-表级锁介绍"><a href="#一-表级锁介绍" class="headerlink" title="一.表级锁介绍"></a>一.表级锁介绍</h3><p>由MySQL SQL layer层实现</p>
<h4 id="1-MySQL的表级锁有两种："><a href="#1-MySQL的表级锁有两种：" class="headerlink" title="1.MySQL的表级锁有两种："></a>1.MySQL的表级锁有两种：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一种是表锁。</span><br><span class="line">一种是元数据锁（meta data lock，MDL)</span><br></pre></td></tr></table></figure>

<h4 id="2-表锁介绍"><a href="#2-表锁介绍" class="headerlink" title="2.表锁介绍"></a>2.表锁介绍</h4><p>表锁有两种表现形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表共享读锁（Table Read Lock）</span><br><span class="line">表独占写锁（Table Write Lock）</span><br></pre></td></tr></table></figure>

<p>手动增加表锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock table 表名称 read(write),表名称2 read(write)，其他;</span><br></pre></td></tr></table></figure>

<p>删除表锁</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<h4 id="3-元数据锁介绍"><a href="#3-元数据锁介绍" class="headerlink" title="3.元数据锁介绍"></a>3.元数据锁介绍</h4><p>MDL (metaDataLock) 元数据：表结构</p>
<p>在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<h3 id="二、行级锁"><a href="#二、行级锁" class="headerlink" title="二、行级锁"></a>二、行级锁</h3><h4 id="行级锁介绍"><a href="#行级锁介绍" class="headerlink" title="行级锁介绍"></a>行级锁介绍</h4><pre><code>InnoDB存储引擎实现</code></pre><p>InnoDB的行级锁，按照锁定范围来说，分为三种：</p>
<ul>
<li>记录锁（Record Locks）:锁定索引中一条记录。 主键指定 where id=3</li>
<li>间隙锁（Gap Locks）: 锁定记录前、记录中、记录后的行 RR隔离级 （可重复读）</li>
<li>Next-Key 锁: 记录锁 + 间隙锁</li>
</ul>
<h4 id="行级锁分类"><a href="#行级锁分类" class="headerlink" title="行级锁分类"></a>行级锁分类</h4><p>按照功能来说，分为两种：</p>
<h5 id="共享读锁（S）："><a href="#共享读锁（S）：" class="headerlink" title="共享读锁（S）："></a>共享读锁（S）：</h5><p>​    允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> <span class="comment">-- 共享读锁 手动添加</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="comment">-- 无锁</span></span><br></pre></td></tr></table></figure>

<h5 id="排他写锁（X）："><a href="#排他写锁（X）：" class="headerlink" title="排他写锁（X）："></a>排他写锁（X）：</h5><pre><code>允许获得排他写锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁（不是读）和排他写锁。</code></pre><h6 id="1、自动加-DML"><a href="#1、自动加-DML" class="headerlink" title="1、自动加 DML"></a>1、自动加 DML</h6><p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p>
<h6 id="2、手动加"><a href="#2、手动加" class="headerlink" title="2、手动加"></a>2、手动加</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>



<p>InnoDB也实现了表级锁，也就是意向锁，意向锁是mysql内部使用的，不需要用户干预。</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<p>意向锁的主要作用是为了【全表更新数据】时的性能提升。否则在全表更新数据时，需要先检索该表是否某些记录上面有行锁。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql8.png" alt></p>
<h4 id="两阶段锁（2PL）"><a href="#两阶段锁（2PL）" class="headerlink" title="两阶段锁（2PL）"></a>两阶段锁（2PL）</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql9.png" alt></p>
<p>锁操作分为两个阶段：加锁阶段与解锁阶段，</p>
<p>加锁阶段与解锁阶段不相交。</p>
<p>加锁阶段：只加锁，不放锁。</p>
<p>解锁阶段：只放锁，不加锁</p>
<h3 id="三，行锁演示"><a href="#三，行锁演示" class="headerlink" title="三，行锁演示"></a>三，行锁演示</h3><p><strong>InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索的数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</strong></p>
<h4 id="行读锁"><a href="#行读锁" class="headerlink" title="行读锁"></a>行读锁</h4><p>session1（Navicat）、session2（mysql）<br>Innodb_row_lock_current_waits：当前正在等待锁定的数量；</p>
<p>Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</p>
<p>Innodb_row_lock_time_avg：每次等待所花平均时间；</p>
<p>Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</p>
<p>Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查看行锁状态 show STATUS like 'innodb_row_lock%';</span><br><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">select * from mylock where ID=<span class="number">1</span> lock in share mode; --手动加id=<span class="number">1</span>的行读</span><br><span class="line">锁,使用索引</span><br><span class="line"><span class="number">2</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; -- 未锁定该行可以修改</span><br><span class="line"><span class="number">3</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">1</span>; -- 锁定该行修改阻塞</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; <span class="keyword">try</span> restarting transaction</span><br><span class="line">-- 锁定超时</span><br><span class="line"><span class="number">4</span>、session1: commit; --提交事务 或者 rollback 释放读锁</span><br><span class="line"><span class="number">5</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">1</span>; --修改成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1 Changed: 1 Warnings: 0</span></span><br><span class="line">注：使用索引加行锁 ，未锁定的行可以访问</span><br></pre></td></tr></table></figure>

<h4 id="行读锁升级为表锁"><a href="#行读锁升级为表锁" class="headerlink" title="行读锁升级为表锁"></a>行读锁升级为表锁</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">--手动加name=<span class="string">'c'</span>的行读锁,未使用索引</span><br><span class="line">select * from mylock where name=<span class="string">'c'</span> lock in share mode;</span><br><span class="line"><span class="number">2</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; -- 修改阻塞 未用索引行锁升级为表锁</span><br><span class="line"><span class="number">3</span>、session1: commit; --提交事务 或者 rollback 释放读锁</span><br><span class="line"><span class="number">4</span>、session2：update mylock <span class="built_in">set</span> name=<span class="string">'y'</span> where id=<span class="number">2</span>; --修改成功</span><br><span class="line">Query OK, <span class="number">1</span> <span class="function">row <span class="title">affected</span> <span class="params">(<span class="number">0.00</span> sec)</span></span></span><br><span class="line"><span class="function">Rows matched: 1 Changed: 1 Warnings: 0</span></span><br><span class="line">注：未使用索引行锁升级为表锁</span><br></pre></td></tr></table></figure>

<h4 id="行写锁"><a href="#行写锁" class="headerlink" title="行写锁"></a>行写锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、session1: <span class="built_in">begin</span>;--开启事务未提交</span><br><span class="line">--手动加id=<span class="number">1</span>的行写锁,</span><br><span class="line">select * from mylock where id=<span class="number">1</span> <span class="keyword">for</span> update;</span><br><span class="line"><span class="number">2</span>、session2：select * from mylock where id=<span class="number">2</span> ; -- 可以访问</span><br><span class="line"><span class="number">3</span>、session2: select * from mylock where id=<span class="number">1</span> ; -- 可以读 不加锁</span><br><span class="line"><span class="number">4</span>、session2: select * from mylock where id=<span class="number">1</span> lock in share mode ; -- 加读锁</span><br><span class="line">被阻塞</span><br><span class="line"><span class="number">5</span>、session1：commit; -- 提交事务 或者 rollback 释放写锁</span><br><span class="line"><span class="number">5</span>、session2：执行成功</span><br><span class="line">主键索引产生记录锁</span><br></pre></td></tr></table></figure>

<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">案例演示：</span><br><span class="line">mysql&gt; create table news (id int, number int,primary key (id));</span><br><span class="line">mysql&gt; insert into news values(1,2);</span><br><span class="line">......</span><br><span class="line"><span class="comment">--加非唯一索引</span></span><br><span class="line">mysql&gt; alter table news add index idx_num(number);</span><br><span class="line"><span class="comment">-- 非唯一索引的等值</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"></span><br><span class="line">注：id和number都在间隙内则阻塞。</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 主键索引的范围</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">id</span> &lt; <span class="number">4</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">2</span>,<span class="number">2</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">4</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">4</span>,<span class="number">5</span>);<span class="comment">#（阻塞）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">9</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#（执行成功）</span></span><br><span class="line">````</span><br><span class="line">注：id和number都在间隙内则阻塞。</span><br><span class="line">    </span><br><span class="line"><span class="comment">--无穷大</span></span><br><span class="line">session 1:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> news <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">13</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br><span class="line"><span class="keyword">update</span> news <span class="keyword">set</span> xx <span class="keyword">where</span> <span class="built_in">number</span>=<span class="number">13</span> ;</span><br><span class="line">session 2:</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span> ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">11</span>,<span class="number">5</span>);<span class="comment">#(执行成功)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">12</span>,<span class="number">11</span>);<span class="comment">#(执行成功)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">14</span>,<span class="number">11</span>);<span class="comment">#(阻塞)</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> news <span class="keyword">value</span>(<span class="number">15</span>,<span class="number">12</span>);<span class="comment">#(阻塞)</span></span><br><span class="line">检索条件number=13,向左取得最靠近的值11作为左区间，向右由于没有记录因此取得无穷大作为右区间，因</span><br><span class="line">此，session 1的间隙锁的范围（11，无穷大）</span><br><span class="line">注：非主键索引产生间隙锁，主键范围产生间隙锁</span><br></pre></td></tr></table></figure>

<h3 id="四，死锁"><a href="#四，死锁" class="headerlink" title="四，死锁"></a>四，死锁</h3><p>两个 session 互相等等待对方的资源释放之后，才能释放自己的资源,造成了死锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1、session1: <span class="keyword">begin</span>;<span class="comment">--开启事务未提交</span></span><br><span class="line"><span class="comment">--手动加行写锁 id=1 ，使用索引</span></span><br><span class="line"><span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'m'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line">2、session2：<span class="keyword">begin</span>;<span class="comment">--开启事务未提交</span></span><br><span class="line"><span class="comment">--手动加行写锁 id=2 ，使用索引</span></span><br><span class="line"><span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'m'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>;</span><br><span class="line">3、session1: <span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'nn'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">2</span>; <span class="comment">-- 加写锁被阻塞</span></span><br><span class="line">4、session2：<span class="keyword">update</span> mylock <span class="keyword">set</span> <span class="keyword">name</span>=<span class="string">'nn'</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; <span class="comment">-- 加写锁会死锁，不允许操作</span></span><br><span class="line">ERROR 1213 (40001): Deadlock found when trying to get <span class="keyword">lock</span>; try restarting</span><br><span class="line">transaction</span><br></pre></td></tr></table></figure>



<h2 id="七、MySQL事务"><a href="#七、MySQL事务" class="headerlink" title="七、MySQL事务"></a>七、MySQL事务</h2><h4 id="事务介绍"><a href="#事务介绍" class="headerlink" title="事务介绍"></a>事务介绍</h4><p>在MySQL中的事务是由存储引擎实现的，而且支持事务的存储引擎不多，我们主要讲解InnoDB存储引擎中的事务。</p>
<p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p>
<p>事务用来管理DDL、DML、DCL 操作，比如 insert,update,delete 语句，默认是自动提交的。</p>
<h4 id="事务开启"><a href="#事务开启" class="headerlink" title="事务开启"></a>事务开启</h4><p>BEGIN 或START TRANSACTION<code>；显式地开启一个事务；</code></p>
<p><code>COMMIT 也可以使用COMMIT WORK ，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；</code></p>
<p><code>ROLLBACK 有可以使用ROLLBACK WORK</code>，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；</p>
<h4 id="事务四大特性-ACID"><a href="#事务四大特性-ACID" class="headerlink" title="事务四大特性(ACID)"></a>事务四大特性(ACID)</h4><p>Atomicity（原子性）：构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。</p>
<p>Consistency（一致性）：数据库在事务执行前后状态都必须是稳定的或者是一致的。</p>
<p>Isolation（隔离性）：事务之间不会相互影响。</p>
<p>​        由锁机制和MVCC机制来实现的</p>
<p>​        MVCC(多版本并发控制)：优化读写性能（读不加锁、读写不冲突）</p>
<p>Durability（持久性）：事务执行成功后必须全部写入磁盘。</p>
<p><strong>总结来说，事务的隔离性</strong><br>        由多版本控制机制和锁实现，而原子性、一致性和持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现。</p>
<h4 id="RedoLog"><a href="#RedoLog" class="headerlink" title="RedoLog"></a>RedoLog</h4><p>数据库日志和数据落盘机制，如下图所示:</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql15.png" alt></p>
<p>redo log写入磁盘时，必须进行一次操作系统的fsync操作，防止redo log只是写入了操作系统的磁盘缓存中。参数innodb_flush_log_at_trx_commit可以控制redo log日志刷新到磁盘的策略</p>
<h4 id="UndoLog"><a href="#UndoLog" class="headerlink" title="UndoLog"></a>UndoLog</h4><p><strong>数据库崩溃重启后需要从redo log中把未落盘的脏页数据恢复出来，重新写入磁盘，保证用户的数据不丢失。当然，在崩溃恢复中还需要回滚没有提交的事务。由于回滚操作需要undo日志的支持，undo日志的完整性和可靠性需要redo日志来保证，所以崩溃恢复先做redo恢复数据，然后做undo回滚。</strong></p>
<p>在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql16.png" alt></p>
<p>数据和回滚日志的逻辑存储结构</p>
<p><strong>undo log的存储不同于redo log，它存放在数据库内部的一个特殊的段(segment)中，这个段称为回滚段。回滚段位于共享表空间中。undo段中的以undo page为更小的组织单位。undo page和存储数据库数据和索引的页类似。因为redo log是物理日志，记录的是数据库页的物理修改操作。所以undolog（也看成数据库数据）的写入也会产生redo log，也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。如上图所示，表空间中有回滚段和叶节点段和非叶节点段，而三者都有对应的页结构。</strong></p>
<p>我们再来总结一下数据库事务的整个流程，如下图所示</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql14.png" alt></p>
<p><strong>事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如果此时发生了崩溃，则只使用redo log恢复数据。</strong></p>
<h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h4><p>事务并发问题</p>
<p>在事务的并发操作中可能会出现一些问题：</p>
<ul>
<li>丢失更新：两个事务针对同一数据都发生修改操作时，会存在丢失更新问题。</li>
<li>脏读：一个事务读取到另一个事务未提交的数据。</li>
<li>不可重复读：一个事务因读取到另一个事务已提交的update或者delete数据。导致对同一条记录读取两次以上的结果不一致。</li>
<li>幻读：一个事务因读取到另一个事务已提交的insert数据。导致对同一张表读取两次以上的结果不一致。</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>现在来看看MySQL数据库为我们提供的四种隔离级别（由低到高）：<br>① Read uncommitted (读未提交)：最低级别，任何情况都无法保证。<br>② Read committed (RC，读已提交)：可避免脏读的发生。<br>③ Repeatable read (RR，可重复读)：可避免脏读、不可重复读的发生。<br>（注意事项：InnoDB的RR还可以解决幻读，主要原因是Next-Key锁，只有RR才能使用Next-Key锁）<br>④ Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。（由MVCC降级为Locking-Base CC）</p>
<h4 id="InnoDB的MVCC实现"><a href="#InnoDB的MVCC实现" class="headerlink" title="InnoDB的MVCC实现"></a>InnoDB的MVCC实现</h4><p>我们首先来看一下wiki上对MVCC的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiversion concurrency control (MCC or MVCC), is a concurrency control method</span><br><span class="line">commonly used by database management systems to provide concurrent access to the</span><br><span class="line">database and in programming languages to implement transactional memory.</span><br></pre></td></tr></table></figure>

<h5 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h5><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。</p>
<ul>
<li>快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。</li>
<li>当前读，读取的是记录的最新版本，并且当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这<br>条记录。</li>
</ul>
<p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？<br>以MySQL InnoDB为例：</p>
<ul>
<li>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析) 不加读锁 读历史版本</li>
<li>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。 加行写锁 读当前版本</li>
</ul>
<h5 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h5><ul>
<li>一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数据库中行数据的方式。</li>
<li>如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个最新可见快照。</li>
</ul>
<p>MVCC 在mysql 中的实现依赖的是 undo log 与 read view 。</p>
<h5 id="Undo-Log-结构"><a href="#Undo-Log-结构" class="headerlink" title="Undo Log 结构"></a>Undo Log 结构</h5><p>InnoDB行记录有三个隐藏字段：分别对应该<strong>行的rowid、事务号db_trx_id和回滚指针db_roll_ptr，</strong></p>
<p>其中 <strong>db_trx_id表示最近修改的事务的id，db_roll_ptr指向回滚段中的undo log。</strong></p>
<p>根据行为的不同，undo log分为两种：insert undo log和update undo log</p>
<h6 id="insert-undo-log："><a href="#insert-undo-log：" class="headerlink" title="insert undo log："></a>insert undo log：</h6><p>是在 insert 操作中产生的 undo log。因为 insert 操作的记录只对事务本身可见，</p>
<p>rollback 在该事务中直接删除 ，不需要进行 purge 操作</p>
<h6 id="update-undo-log-："><a href="#update-undo-log-：" class="headerlink" title="update undo log ："></a>update undo log ：</h6><p>是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，</p>
<p>rollback MVCC机制会找他的历史版本进行恢复</p>
<p>是 update 或 delete 操作中产生的 undo log，因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此 update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql17.png" alt></p>
<p>如下图所示（初始状态）：</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql19.png" alt></p>
<p>当事务2使用UPDATE语句修改该行数据时，会首先使用排他锁锁定改行，将该行当前的值复制到undolog中，然后再真正地修改当前行的值，最后填写事务ID，使用回滚指针指向undo log中修改前的行。</p>
<p>如下图所示（第一次修改）：</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql20.png" alt></p>
<p>当事务3进行修改与事务2的处理过程类似，如下图所示（第二次修改）</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql21.png" alt></p>
<h5 id="事务链表"><a href="#事务链表" class="headerlink" title="事务链表"></a>事务链表</h5><p>MySQL中的事务在开始到提交这段过程中，都会被保存到一个叫trx_sys的事务链表中，这是一个基本的链表结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-trx --&gt; trx11 --&gt; trx9 --&gt; trx6 --&gt; trx5 --&gt; trx3;</span><br></pre></td></tr></table></figure>

<p>事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除</p>
<p>RR隔离级别下，在每个事务开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)</p>
<p>RC隔离级别下，在每个语句开始的时候，会将当前系统中的所有的活跃事务拷贝到一个列表中(readview)</p>
<p><strong>show engine innodb status ,就能够看到事务列表。</strong></p>
<h5 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h5><p>当前事务（读）能读哪个历史版本？</p>
<p><strong>Read View是事务开启时当前所有事务的一个集合，这个类中存储了当前Read View中最大事务ID及最小事务ID。</strong></p>
<p>这就是当前活跃的事务列表。如下所示，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ct-trx --&gt; trx11 --&gt; trx9 --&gt; trx6 --&gt; trx5 --&gt; trx3;</span><br></pre></td></tr></table></figure>

<p>ct-trx 表示当前事务的id，对应上面的read_view数据结构如下，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read_view-&gt;creator_trx_id = ct-trx;</span><br><span class="line">read_view-&gt;up_limit_id = trx3; 低水位</span><br><span class="line">read_view-&gt;low_limit_id = trx11; 高水位</span><br><span class="line">read_view-&gt;trx_ids = [trx11, trx9, trx6, trx5, trx3];</span><br></pre></td></tr></table></figure>

<p><strong>low_limit_id是“高水位”，即当时活跃事务的最大id，如果读到row的db_trx_id&gt;=low_limit_id，说明这些id在此之前的数据都没有提交，如注释中的描述，这些数据都不可见。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (trx_id &gt;= view-&gt;low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(FALSE);</span><br><span class="line">&#125;</span><br><span class="line">注：readview 部分源码</span><br></pre></td></tr></table></figure>

<p><strong>up_limit_id是“低水位”，即当时活跃事务列表的最小事务id，如果row的db_trx_id&lt;up_limit_id,说明这些数据在事务创建的id时都已经提交，如注释中的描述，这些数据均可见。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (trx_id &lt; view-&gt;up_limit_id) &#123;</span><br><span class="line">	<span class="keyword">return</span>(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>row的db_trx_id在low_limit_id和up_limit_id之间，则查找该记录的db_trx_id是否在自己事务的read_view-&gt;trx_ids列表中，如果在则该记录的当前版本不可见，否则该记录的当前版本可见。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql18.png" alt></p>
<h5 id="不同隔离级别ReadView实现方式"><a href="#不同隔离级别ReadView实现方式" class="headerlink" title="不同隔离级别ReadView实现方式"></a>不同隔离级别ReadView实现方式</h5><ol>
<li><h6 id="read-commited"><a href="#read-commited" class="headerlink" title="read-commited:"></a>read-commited:</h6></li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">函数：ha_innobase::external_lock</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (trx-&gt;isolation_level &lt;= TRX_ISO_READ_COMMITTED</span><br><span class="line">        </span><br><span class="line">&amp;&amp; trx-&gt;global_read_view) &#123;</span><br><span class="line">        </span><br><span class="line">/ At low transaction isolation levels we let</span><br><span class="line">        each consistent <span class="built_in">read</span> set its own snapshot /</span><br><span class="line">        </span><br><span class="line">read_view_close_for_mysql(trx);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h6 id="repeatable-read："><a href="#repeatable-read：" class="headerlink" title="repeatable read："></a>repeatable read：</h6></li>
</ol>
<p>在repeatable read的隔离级别下，创建事务trx结构的时候，就生成了当前的global read view。使用trx_assign_read_view函数创建，一直维持到事务结束。在事务结束这段时间内 每一次查询都不会重新重建Read View ， 从而实现了可重复读。</p>
<h2 id="八、MySQL-落盘"><a href="#八、MySQL-落盘" class="headerlink" title="八、MySQL 落盘"></a>八、MySQL 落盘</h2><h4 id="InnoDB架构图"><a href="#InnoDB架构图" class="headerlink" title="InnoDB架构图"></a>InnoDB架构图</h4><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql10.png" alt></p>
<h4 id="InnoDB磁盘文件"><a href="#InnoDB磁盘文件" class="headerlink" title="InnoDB磁盘文件"></a>InnoDB磁盘文件</h4><p>InnoDB的主要的磁盘文件主要分为三大块：一是系统表空间，二是用户表空间，三是redo日志文件和<br>归档文件。二进制文件(binlog)等文件是MySQL Server层维护的文件，所以未列入InnoDB的磁盘文件中。</p>
<h5 id="系统表空间和用户表空间"><a href="#系统表空间和用户表空间" class="headerlink" title="系统表空间和用户表空间"></a>系统表空间和用户表空间</h5><ul>
<li>InnoDB系统表空间包含InnoDB数据字典(元数据以及相关对象)并且double write buffer,change buffer,undo logs的存储区域。</li>
<li>系统表空间也默认包含任何用户在系统表空间创建的表数据和索引数据。系统表空间是一个共享的表空间因为它是被多个表共享的。</li>
</ul>
<p>系统表空间是由一个或者多个数据文件组成。默认情况下,1个初始大小为10MB，名为ibdata1的系统数据文件在MySQL的data目录下被创建。用户可以使用innodb_data_file_path 对数据文件的大小和数量进行配置。</p>
<p>innodb_data_file_path 的格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path=datafile1[,datafile2]...</span><br></pre></td></tr></table></figure>

<p>用户可以通过多个文件组成一个表空间，同时制定文件的属性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_data_file_path = /db/ibdata1:<span class="number">1000</span>M;/dr2/db/ibdata2:<span class="number">1000</span>M:autoextend</span><br></pre></td></tr></table></figure>

<p>设置innodb_data_file_path参数之后，所有基于InnoDB存储引擎的表的数据都会记录到该系统表空间中，如果设置了参数innodb_file_per_table，则用户可以将每个基于InnoDB存储引擎的表产生一个独立的用户表空间。用户表空间的命名规则为：表名.ibd。通过这种方式，用户不用将所有数据都存放于默认的系统表空间中，但是用户表空间只存储该表的数据、索引和插入缓冲BITMAP等信息，其余信息还是存放在默认的系统表空间中。</p>
<p>下图显示InnoDB存储引擎对于文件的存储方式，其中frm文件是表结构定义文件，记录每个表的表结构定义。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql11.png" alt></p>
<p>系统表空间（共享表空间）<br>1、数据字典(data dictionary)：记录数据库相关信息<br>2、doublewrite write buffer：解决部分写失败（页断裂）<br>3、insert buffer：内存insert buffer数据，周期写入共享表空间，防止意外宕机<br>4、回滚段(rollback segments)<br>5、undo空间：undo页</p>
<p>用户表空间<br>1、每个表的数据和索引都会存在自已的表空间中<br>2、undo空间：undo页 （需要设置）</p>
<h5 id="重做日志文件和归档文件"><a href="#重做日志文件和归档文件" class="headerlink" title="重做日志文件和归档文件"></a>重做日志文件和归档文件</h5><ul>
<li>默认情况下，在InnoDB存储引擎的数据目录下会有两个名为ib_logfile0和ib_logfile1的文件，这就是InnoDB的重做日志文件(redo log file)，它记录了对于InnoDB存储引擎的事务日志。</li>
<li>当InnoDB的数据存储文件发生错误时，重做日志文件就能派上用场。InnoDB存储引擎可以使用重做日志文件将数据恢复为正确状态，以此来保证数据的正确性和完整性。</li>
<li>每个InnoDB存储引擎至少有1个重做日志文件组(group)，每个文件组下至少有2个重做日志文件，如默认的ib_logfile0和ib_logfile1。</li>
<li>为了得到更高的可靠性，用户可以设置多个镜像日志组，将不同的文件组放在不同的磁盘上，以此来提高重做日志的高可用性。</li>
<li>在日志组中每个重做日志文件的大小一致，并以【循环写入】的方式运行。InnoDB存储引擎先写入重做日志文件1，当文件被写满时，会切换到重做日志文件2，再当重做日志文件2也被写满时，再切换到重做日志文件1。</li>
<li>用户可以使用innodb_log_file_size来设置重做日志文件的大小，这对InnoDB存储引擎的性能有着非常大的影响。</li>
<li>如果重做日志文件设置的太大，数据丢失时，恢复时可能需要很长的时间；另一方面，如果设置的太小，重做日志文件太小会导致依据checkpoint的检查需要频繁刷新脏页到磁盘中，导致性能的抖动。</li>
</ul>
<h5 id="重做日志的落盘机制"><a href="#重做日志的落盘机制" class="headerlink" title="重做日志的落盘机制"></a>重做日志的落盘机制</h5><p>InnoDB对于数据文件和日志文件的刷盘遵守WAL(Write ahead redo log) 和Force-log-at-commit两种规则，二者保证了事务的持久性。WAL要求数据的变更写入到磁盘前，首先必须将内存中的日志写入到磁盘；Force-log-at-commit要求当一 个事务提交时，所有产生的日志都必须刷新到磁盘上，如果日志刷新成功后，缓冲池中的数据刷新到磁盘前数据库发生了宕机，那么重启时，数据库可以从日志中恢复数据。</p>
<p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql12.png" alt></p>
<ul>
<li>如上图所示，InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。</li>
<li>在checkpoint择时机制中，就有重做日志文件写满的判断，所以，如前文所述，如果重做日志文件太小，经常被写满，就会频繁导致checkpoint将更改的数据写入磁盘，导致性能抖动。</li>
<li>操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。</li>
<li>InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。</li>
</ul>
<h5 id="日志的刷盘机制如下图所示："><a href="#日志的刷盘机制如下图所示：" class="headerlink" title="日志的刷盘机制如下图所示："></a>日志的刷盘机制如下图所示：</h5><p><img src="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql13.png" alt></p>
<p>innodb_flush_log_at_commit是InnoDB性能调优的一个基础参数，涉及InnoDB的写入效率和数据安全。</p>
<ul>
<li>当参数值为0时，写入效率最高，但是数据安全最低；</li>
<li>参数值为1时，写入效率最低，但是数据安全最高；</li>
<li>参数值为2时，二者都是中等水平。</li>
<li>一般建议将该属性值设置为1，以获得较高的数据安全性，而且也只有设置为1，才能保证事务的持久性。</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: Liu Dong</p><p>原文链接: <a href="https://liudong-code.github.io/2020/03/07/MySql数据库/">https://liudong-code.github.io/2020/03/07/MySql数据库/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/" class="next">缓存</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、数据库隔离级别（详见七）"><span class="toc-text">一、数据库隔离级别（详见七）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、MYSQL有哪些存储引擎，各自优缺点"><span class="toc-text">二、MYSQL有哪些存储引擎，各自优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、高并发下，如何做到安全的修改同一行数据"><span class="toc-text">三、高并发下，如何做到安全的修改同一行数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、使用悲观锁"><span class="toc-text">1、使用悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、FIFO（First-Input-First-Output，先进先出）缓存队列思路"><span class="toc-text">2、FIFO（First Input First Output，先进先出）缓存队列思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、使用乐观锁"><span class="toc-text">3、使用乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、Zookeeper-锁"><span class="toc-text">4、Zookeeper 锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、SQL执行计划"><span class="toc-text">四、SQL执行计划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、执行计划是什么？"><span class="toc-text">一、执行计划是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、查看执行计划"><span class="toc-text">二、查看执行计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、MySQL执行计划分析"><span class="toc-text">三、MySQL执行计划分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、各个字段的含义"><span class="toc-text">四、各个字段的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、MySQL索引"><span class="toc-text">五、MySQL索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-索引是什么"><span class="toc-text">a.索引是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-索引的优势和劣势"><span class="toc-text">b.索引的优势和劣势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优势："><span class="toc-text">优势：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#劣势："><span class="toc-text">劣势：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-索引的分类"><span class="toc-text">c.索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-索引的使用"><span class="toc-text">d.索引的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建索引"><span class="toc-text">创建索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单列索引之普通索引"><span class="toc-text">单列索引之普通索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#单列索引之唯一索引"><span class="toc-text">单列索引之唯一索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#单列索引之全文索引"><span class="toc-text">单列索引之全文索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#组合索引"><span class="toc-text">组合索引</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除索引"><span class="toc-text">删除索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查看索引"><span class="toc-text">查看索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-索引原理分析"><span class="toc-text">e.索引原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引存储结构"><span class="toc-text">索引存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B树图示"><span class="toc-text">B树图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B和B-的区别"><span class="toc-text">B和B+的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非聚集索引（MyISAM）"><span class="toc-text">非聚集索引（MyISAM）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#辅助索引（次要索引）"><span class="toc-text">辅助索引（次要索引）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#聚集索引（InnoDB）"><span class="toc-text">聚集索引（InnoDB）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#辅助索引（次要索引）-1"><span class="toc-text">辅助索引（次要索引）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#回表"><span class="toc-text">回表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f-索引的使用场景"><span class="toc-text">f.索引的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#g-组合索引"><span class="toc-text">g.组合索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#h-索引失效"><span class="toc-text">h.索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-全值匹配我最爱"><span class="toc-text">1.全值匹配我最爱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-最佳左前缀法则"><span class="toc-text">2.最佳左前缀法则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-不要在索引上做计算"><span class="toc-text">3.不要在索引上做计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-范围条件右边的列失效"><span class="toc-text">4.范围条件右边的列失效</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-尽量使用覆盖索引"><span class="toc-text">5.尽量使用覆盖索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-索引字段上不要使用不等"><span class="toc-text">6.索引字段上不要使用不等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-主键索引字段上不可以判断null"><span class="toc-text">7.主键索引字段上不可以判断null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-索引字段使用like不以通配符开头"><span class="toc-text">8.索引字段使用like不以通配符开头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-索引字段字符串要加单引号"><span class="toc-text">9.索引字段字符串要加单引号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-索引字段不要使用or"><span class="toc-text">10.索引字段不要使用or</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-口诀"><span class="toc-text">11.口诀</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、数据库MySQL锁"><span class="toc-text">六、数据库MySQL锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一-表级锁介绍"><span class="toc-text">一.表级锁介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-MySQL的表级锁有两种："><span class="toc-text">1.MySQL的表级锁有两种：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-表锁介绍"><span class="toc-text">2.表锁介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-元数据锁介绍"><span class="toc-text">3.元数据锁介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、行级锁"><span class="toc-text">二、行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#行级锁介绍"><span class="toc-text">行级锁介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行级锁分类"><span class="toc-text">行级锁分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#共享读锁（S）："><span class="toc-text">共享读锁（S）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#排他写锁（X）："><span class="toc-text">排他写锁（X）：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1、自动加-DML"><span class="toc-text">1、自动加 DML</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2、手动加"><span class="toc-text">2、手动加</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两阶段锁（2PL）"><span class="toc-text">两阶段锁（2PL）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三，行锁演示"><span class="toc-text">三，行锁演示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#行读锁"><span class="toc-text">行读锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行读锁升级为表锁"><span class="toc-text">行读锁升级为表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#行写锁"><span class="toc-text">行写锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#间隙锁"><span class="toc-text">间隙锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四，死锁"><span class="toc-text">四，死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、MySQL事务"><span class="toc-text">七、MySQL事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事务介绍"><span class="toc-text">事务介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务开启"><span class="toc-text">事务开启</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务四大特性-ACID"><span class="toc-text">事务四大特性(ACID)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedoLog"><span class="toc-text">RedoLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UndoLog"><span class="toc-text">UndoLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隔离性"><span class="toc-text">隔离性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务隔离级别"><span class="toc-text">事务隔离级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB的MVCC实现"><span class="toc-text">InnoDB的MVCC实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#当前读和快照读"><span class="toc-text">当前读和快照读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一致性非锁定读"><span class="toc-text">一致性非锁定读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Undo-Log-结构"><span class="toc-text">Undo Log 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#insert-undo-log："><span class="toc-text">insert undo log：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#update-undo-log-："><span class="toc-text">update undo log ：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务链表"><span class="toc-text">事务链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReadView"><span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不同隔离级别ReadView实现方式"><span class="toc-text">不同隔离级别ReadView实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#read-commited"><span class="toc-text">read-commited:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#repeatable-read："><span class="toc-text">repeatable read：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、MySQL-落盘"><span class="toc-text">八、MySQL 落盘</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB架构图"><span class="toc-text">InnoDB架构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB磁盘文件"><span class="toc-text">InnoDB磁盘文件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#系统表空间和用户表空间"><span class="toc-text">系统表空间和用户表空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重做日志文件和归档文件"><span class="toc-text">重做日志文件和归档文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重做日志的落盘机制"><span class="toc-text">重做日志的落盘机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#日志的刷盘机制如下图所示："><span class="toc-text">日志的刷盘机制如下图所示：</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/">MySql数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/">hashCode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/">HashSet内部是如何工作的</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/">Map类</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">数组和链表数据结构描述，各自的时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">java8的新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/">动态代理与cglib实现的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">单例设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">IO模型</a> <a href="/liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/" style="font-size: 15px;">Redis相关</a> <a href="/liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">日常随笔</a> <a href="/liudong-code.github.io/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/liudong-code.github.io/archives/2020/">2020</a><span class="archive-list-count">39</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/liudong-code.github.io/baidusitemap.xml">网站地图</a> |  <a href="/liudong-code.github.io/atom.xml">订阅本站</a> |  <a href="/liudong-code.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/liudong-code.github.io/." rel="nofollow">Liu Dong.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/liudong-code.github.io/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/liudong-code.github.io/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/liudong-code.github.io/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/share/css/share.css"><script type="text/javascript" src="/liudong-code.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/liudong-code.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>