<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><meta name="keywords" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/liudong-code.github.io/favicon.ico"><link rel="bookmark" href="/liudong-code.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/liudong-code.github.io/atom.xml"><title>JVM虚拟机 | code</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JVM虚拟机</h1><a id="logo" href="/liudong-code.github.io/.">code</a><p class="description">码总</p></div><div id="nav-menu"><a href="/liudong-code.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/liudong-code.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/liudong-code.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/liudong-code.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">JVM虚拟机</h1><div class="post-meta"><a href="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/#comments" class="comment-count"></a><p><span class="date">Mar 10, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p> JVM是Java Virtual Machine（Java虚拟机）的缩写，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 </p>
<p> 有两个概念和JVM息息相关并且很容易搞混，那就是JRE和JDK。 </p>
<ul>
<li>JRE(JavaRuntimeEnvironment，Java运行环境)，指的是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户运行已开发好的java程序，只要安装JRE即可。 </li>
<li>JDK(JavaDevelopmentKit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。 </li>
</ul>
<p>为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。而JVM是JRE的一部分。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p>
<p> 下面这张图是java程序的一个总执行流程： </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm1.png" alt></p>
<h1 id="二、类加载机制"><a href="#二、类加载机制" class="headerlink" title="二、类加载机制"></a>二、类加载机制</h1><p> 从上图可以看到，我们写的源程序通过编译后生成的class文件，在运行的时候首先会通过类加载器系统。这边来简要说一下类加载机制。 </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm2.png" alt></p>
<p> 上面是一个类从最初加载到最后卸载的整个流程。我们对其中几个过程进行梳理。 </p>
<h2 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h2><p>加载过程是将class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。这个过程需要类加载器参与。</p>
<h2 id="2-2-链接"><a href="#2-2-链接" class="headerlink" title="2.2 链接"></a>2.2 链接</h2><p>链接是将java类的二进制代码合并到JVM的运行状态之中的过程。可以再细分为如下3步：</p>
<p><strong>① 验证</strong>：确保加载的类信息符合JVM规范，没有安全方面的问题。</p>
<p><strong>② 准备</strong>：正式为变量(static)分配内存并设置类变量默认值，这些内存都将在方法区中进行分配。</p>
<p><strong>③ 解析</strong>：虚拟机常量池内的符号引用替换为直接引用的过程。</p>
<h2 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h2><p>初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块（static块）中的语句合并产生的。</clinit></clinit></p>
<p>当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类。虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁同步。</clinit></p>
<p>当访问一个java类的静态域时，只有真正声明这个域的类才会被初始化。</p>
<p> 下面是一个例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"运行main"</span>);</span><br><span class="line"></span><br><span class="line">            A testa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"a:"</span>+testa.a);</span><br><span class="line"></span><br><span class="line">            testa = <span class="keyword">new</span> A();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"初始化A静态块"</span>);</span><br><span class="line"></span><br><span class="line">            a = <span class="number">300</span>；</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"创建A对象"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出结果如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">运行main</span><br><span class="line"></span><br><span class="line">初始化A静态块</span><br><span class="line"></span><br><span class="line">创建A对象</span><br><span class="line"></span><br><span class="line">a:<span class="number">300</span></span><br><span class="line"></span><br><span class="line">创建A对象</span><br></pre></td></tr></table></figure>

<p> 从上面可以看出，如果类还没加载进来，会先加载类，并初始化static，其中static 加载顺序是在代码中从上到下的顺序来执行的。 </p>
<h3 id="2-3-1-类的主动引用"><a href="#2-3-1-类的主动引用" class="headerlink" title="2.3.1 类的主动引用"></a>2.3.1 类的主动引用</h3><p>对于类的主动引用操作，则一定会发生类的初始化。下面罗列了一些类的主动引用：</p>
<p>① New一个类的对象。</p>
<p>② 调用类的静态成员（除了final常量）和静态方法。</p>
<p>③ 使用java.lang.reflect包的方法对类进行反射调用。</p>
<p>④ 当虚拟机启动，java 会先启动main方法所在的类。</p>
<p>⑤ 当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类。</p>
<h3 id="2-3-2-类的被动引用"><a href="#2-3-2-类的被动引用" class="headerlink" title="2.3.2 类的被动引用"></a>2.3.2 类的被动引用</h3><p>① 当访问一个静态域时，只有真正声明这个域的类才会被初始化，通过子类引用父类的静态变量，不会导致子类初始化。</p>
<p>② 通过数组定义类引用，不会触发此类的初始化。</p>
<p>③ 引用常量不会触发此类的初始化。</p>
<h2 id="2-4-类加载器"><a href="#2-4-类加载器" class="headerlink" title="2.4 类加载器"></a>2.4 类加载器</h2><p>加载类必然离不开类加载器，类加载器是将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class 对象，作为方法区的访问入口。</p>
<p> 关于类加载有一个很有名的机制——双亲委托机制： （后续的博客仔细做讨论）</p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm3.png" alt></p>
<p> 这个机制采用代理模式，某个特定的类加载器在接到加载类的请求时，先将代理任务传到最高一辈，加载不了再逐级往下传，直到能加载。 </p>
<p> 这个机制的作用是为了保证Java核心库的类型安全。比如说如果用户自定义了一个String类，在该机制下，类加载器还是会去加载系统自带的String类，而不是加载用户自定义的这个String类。 </p>
<h1 id="三、JVM运行时数据区"><a href="#三、JVM运行时数据区" class="headerlink" title="三、JVM运行时数据区"></a>三、JVM运行时数据区</h1><p> 讲完类加载系统，来说一下JVM的运行时数据区，先看如下图： </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm4.png" alt></p>
<p> 运行的程序是内容是放在运行时数据区中的，如上图蓝色那块依次来说明一下： </p>
<h2 id="3-1-堆"><a href="#3-1-堆" class="headerlink" title="3.1 堆"></a>3.1 堆</h2><p> 保存所有引用数据类型的真实信息（线程共享）。也就是说那些new出来的对象都是放在这块区域的。 </p>
<h2 id="3-2-虚拟机栈"><a href="#3-2-虚拟机栈" class="headerlink" title="3.2 虚拟机栈"></a>3.2 虚拟机栈</h2><p> 基本数据、运算、指向堆内存的引用（线程私有）。 </p>
<p>在栈里面是由一个个栈帧组成的，每个正在执行的方法对应一个栈帧。</p>
<p>当一个方法运行到一半需要调用另一个方法时，就创建一个新的栈帧表示新调用的方法，将原来那个方法压入栈中。</p>
<p>当方法运行完毕，栈帧出栈，原来方法处于栈顶接着运行。</p>
<p>和栈这一数据结构一样，虚拟机栈里面的栈帧遵循后进先出的原则。</p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm5.png" alt></p>
<p> 常见的一个错误栈溢出 StackOverflowError 就是由于方法递归层数太多，导致栈空间满了。看如下一个例子: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        fun();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        fun();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面fun()函数无限递归调用自己，最终会造成栈溢出： </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm6.png" alt></p>
<h2 id="3-3-方法区"><a href="#3-3-方法区" class="headerlink" title="3.3 方法区"></a>3.3 方法区</h2><p>又叫静态区，跟堆一样，被所有的线程共享。</p>
<p>方法区包含所有的class和static变量。方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。</p>
<p>同时方法区里面还有一个叫常量池的地方，String的字符串等常量存储就存储在那边。</p>
<h2 id="3-4-程序计数器"><a href="#3-4-程序计数器" class="headerlink" title="3.4 程序计数器"></a>3.4 程序计数器</h2><p> 一个非常小的内存空间，用来保存程序执行到的位置（线程私有）。下面是一个程序计数器的演示： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        str.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面程序会报空指针异常，如下图，在报的这个异常中，有一行日志 at TestDemo,main(TestDemo.java:4)  代表程序运行到TestDemo 中main()函数第四行的时候发生的错误，就是通过程序计数器来记录这个程序运行的位置的。</p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm7.png" alt></p>
<h2 id="3-5-本地方法栈"><a href="#3-5-本地方法栈" class="headerlink" title="3.5 本地方法栈"></a>3.5 本地方法栈</h2><p> 和虚拟机栈类似，不过本地方法栈里面运行的方法不是用java写的，一般是用c或c++写的方法，也有类似栈帧的的概念。 </p>
<h1 id="四、内存模型和垃圾回收"><a href="#四、内存模型和垃圾回收" class="headerlink" title="四、内存模型和垃圾回收"></a>四、内存模型和垃圾回收</h1><h2 id="4-1-内存模型"><a href="#4-1-内存模型" class="headerlink" title="4.1 内存模型"></a>4.1 内存模型</h2><p> JVM对于运行时对于共享数据的部分，即堆和方法区做了一个内存划分的规范。以JDK1.8为分界线，稍微有些不同，先看如下图： </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm8.png" alt></p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm9.png" alt></p>
<p>两者变化不大，只是将永久带变成了元空间。</p>
<p><strong>一般来说新生代和老年代对应着上一节所讲的堆部分，而永久带或者元空间对应着上一节所说方法区。</strong></p>
<p>这边的内存模型和上一节里面的JVM运行时数据区，可以理解为从不同的角度阐述了同一个物理实物。 </p>
<h3 id="4-1-1-年轻代"><a href="#4-1-1-年轻代" class="headerlink" title="4.1.1 年轻代"></a>4.1.1 年轻代</h3><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生  命周期短的对象。年轻代分三个区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个 Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p>
<h3 id="4-1-2-老年代"><a href="#4-1-2-老年代" class="headerlink" title="4.1.2 老年代"></a>4.1.2 老年代</h3><p> 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。 </p>
<h3 id="4-1-3-永久带"><a href="#4-1-3-永久带" class="headerlink" title="4.1.3 永久带"></a>4.1.3 永久带</h3><p> 用于存放静态文件，如Java类、方法等。永久带对垃圾回收没有显著影响，一般不做垃圾回收，在JVM内存中划分空间。 </p>
<h3 id="4-1-4-元空间"><a href="#4-1-4-元空间" class="headerlink" title="4.1.4 元空间"></a>4.1.4 元空间</h3><p> 类似于永久带，不过它是直接使用物理内存而不占用JVM堆内存。 </p>
<h2 id="4-2-垃圾回收机制"><a href="#4-2-垃圾回收机制" class="headerlink" title="4.2 垃圾回收机制"></a>4.2 垃圾回收机制</h2><p> 垃圾回收是JVM中非常重要的部分，也正是由于这一机制的存在，使得Java语言不用像c++一样需要开发者自己去释放内存。而是通过垃圾回收器GC来进行内存的回收释放，下面来看下这个流程是怎么样的： </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm10.png" alt></p>
<p> GC主要处理的是年轻代与老年代的内存清理操作，元空间,永久代一般很少用GC。整个流程图如上图所示总的来说如下流程： </p>
<p> ① 当一个新对象产生，需要内存空间，为该对象进行内存空间申请。 </p>
<p> ② 首先判断伊甸园区是否有有内存空间，有的话直接将新对象保存在伊甸园区。 </p>
<p> ③ 如果此时伊甸园区内存空间不足，会自动触发MinorGC，将伊甸园区不用的内存空间进行清理，清理之后判断伊甸园区内存空间是否充足，充足的话在伊甸园区分配内存空间。 </p>
<p> ⑤ 如果此时存活区也没空间了，继续判断老年区，如果老年区空间充足，则将存活区中活跃对象保存到老年代，而后存活区有空余空间，随后伊甸园区将活跃对象保存在存活区之中，在伊甸园区为新对象开辟空间。 </p>
<p> ⑥ 如果老年代满了，此时将产生MajorGC进行老年代内存清理，进行完全垃圾回收。 </p>
<p> ⑦ 如果老年代执行MajorGC发现依然无法进行对象保存，此时会进行OOM异常（OutOfMemoryError）。 </p>
<p> 上面流程就是整个垃圾回收机制流程，总的来说，新创建的对象一般都会在伊甸园区生成，除非这个创建对象太大，那有可能直接在老年区生成。 </p>
<h3 id="4-3-垃圾回收算法"><a href="#4-3-垃圾回收算法" class="headerlink" title="4.3 垃圾回收算法"></a>4.3 垃圾回收算法</h3><h4 id="4-3-1-BTP和TLAB算法"><a href="#4-3-1-BTP和TLAB算法" class="headerlink" title="4.3.1 BTP和TLAB算法"></a>4.3.1 BTP和TLAB算法</h4><p> <strong>① BTP</strong>:Bump-the-Pointer,该算法的主要特点是跟踪在Eden区保存的最后一个对象，类似栈的形式，每次创建新空间时只要判断最后保存的对象是否有足够空间，可极大提高内存分配速度。 </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm11.png" alt></p>
<p> <strong>② TLAB</strong>：Thread-Local Allocation Buffers BTP不适合多线程，TLAB将Eden区分为多个数据块，每个数据块分别采用BTP进行分配。 </p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm12.png" alt></p>
<p>这两种算法都在伊甸园区使用，他们的优点在于速度快，由于伊甸园区里面的对象往往是小往往立刻就回收的，很适合这种算法。但这种算法有一个缺点就是当对象回收后会产生许多碎片。对于这个问题就需要下面一种算法来进行弥补了。</p>
<h3 id="4-3-2-复制算法"><a href="#4-3-2-复制算法" class="headerlink" title="4.3.2 复制算法"></a>4.3.2 复制算法</h3><p>这个算法在新生代的GC中使用，从根集合扫描出存活对象，并将找到的存活对象复制到一块空的空间中，然后清空伊甸园和前面一块有对象的存活区，这块清空的存活区就变成了空的空间供下次复制。这个算法的优点是能整合出大块连续的空间，缺点就是需要有一块空空间来存放复制后的对象，相对来说比较浪费空间。所以这个算法在存活区中使用，存活区也是相对来说最小的一块区域，两个存活区必定有一个区域是空的。</p>
<h3 id="4-3-2-标记压缩算法"><a href="#4-3-2-标记压缩算法" class="headerlink" title="4.3.2 标记压缩算法"></a>4.3.2 标记压缩算法</h3><p>改算法是老年代里面所采用的垃圾回收算法，采用的方式为从根集合开始扫描，对存活的对象进行标记，标记完毕后，回收不存活对象所占用的内存空间并且会将其他所存活对象都往左端空闲空间进行移动，并更新引用其对象的指针。这个算法不会产生碎片，也不需要存在一块空的空间，而其缺点就是速度慢。所以比较适合回收频率相对较低的老年区。</p>
<p><img src="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/jvm14.png" alt></p>
</div><div class="post-copyright"><blockquote><p>原文作者: Liu Dong</p><p>原文链接: <a href="https://liudong-code.github.io/2020/03/10/JVM虚拟机/">https://liudong-code.github.io/2020/03/10/JVM虚拟机/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/liudong-code.github.io/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/" class="next">MySql数据库</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、概述"><span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、类加载机制"><span class="toc-text">二、类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-加载"><span class="toc-text">2.1 加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-链接"><span class="toc-text">2.2 链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-初始化"><span class="toc-text">2.3 初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-类的主动引用"><span class="toc-text">2.3.1 类的主动引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-类的被动引用"><span class="toc-text">2.3.2 类的被动引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-类加载器"><span class="toc-text">2.4 类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、JVM运行时数据区"><span class="toc-text">三、JVM运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-堆"><span class="toc-text">3.1 堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-虚拟机栈"><span class="toc-text">3.2 虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-方法区"><span class="toc-text">3.3 方法区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-程序计数器"><span class="toc-text">3.4 程序计数器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-本地方法栈"><span class="toc-text">3.5 本地方法栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、内存模型和垃圾回收"><span class="toc-text">四、内存模型和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-内存模型"><span class="toc-text">4.1 内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-年轻代"><span class="toc-text">4.1.1 年轻代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-老年代"><span class="toc-text">4.1.2 老年代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-永久带"><span class="toc-text">4.1.3 永久带</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-元空间"><span class="toc-text">4.1.4 元空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-垃圾回收机制"><span class="toc-text">4.2 垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-垃圾回收算法"><span class="toc-text">4.3 垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-BTP和TLAB算法"><span class="toc-text">4.3.1 BTP和TLAB算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-复制算法"><span class="toc-text">4.3.2 复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-标记压缩算法"><span class="toc-text">4.3.2 标记压缩算法</span></a></li></ol></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/">MySql数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/">hashCode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/">HashSet内部是如何工作的</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/">Map类</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">数组和链表数据结构描述，各自的时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">java8的新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/">动态代理与cglib实现的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">IO模型</a> <a href="/liudong-code.github.io/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/" style="font-size: 15px;">Redis相关</a> <a href="/liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">日常随笔</a> <a href="/liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/liudong-code.github.io/archives/2020/">2020</a><span class="archive-list-count">40</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/liudong-code.github.io/baidusitemap.xml">网站地图</a> |  <a href="/liudong-code.github.io/atom.xml">订阅本站</a> |  <a href="/liudong-code.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/liudong-code.github.io/." rel="nofollow">Liu Dong.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/liudong-code.github.io/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/liudong-code.github.io/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/liudong-code.github.io/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/share/css/share.css"><script type="text/javascript" src="/liudong-code.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/liudong-code.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>