<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><meta name="keywords" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/liudong-code.github.io/favicon.ico"><link rel="bookmark" href="/liudong-code.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/liudong-code.github.io/atom.xml"><title>HashSet内部是如何工作的 | code</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">HashSet内部是如何工作的</h1><a id="logo" href="/liudong-code.github.io/.">code</a><p class="description">码总</p></div><div id="nav-menu"><a href="/liudong-code.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/liudong-code.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/liudong-code.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/liudong-code.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">HashSet内部是如何工作的</h1><div class="post-meta"><a href="/liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/#comments" class="comment-count"></a><p><span class="date">Mar 04, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Java-中的-HashSet，内部是如何工作的？"><a href="#Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="Java 中的 HashSet，内部是如何工作的？"></a>Java 中的 HashSet，内部是如何工作的？</h2><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以HashSet中所有 key 的都有一个默认 value。类似于HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。</p>
<h2 id="HashSet："><a href="#HashSet：" class="headerlink" title="HashSet："></a>HashSet：</h2><ul>
<li>实现了Set接口</li>
<li>HashSet依赖的数据结构是哈希表</li>
<li>因为实现的是Set接口，所以不允许有重复的值</li>
<li>插入到HashSet中的对象不保证与插入的顺序保持一致。对象的插入是根据它的hashcode</li>
<li>HashSet中允许有NULL值</li>
<li>HashSet也实现了Searlizable和Cloneable两个接口</li>
</ul>
<h2 id="HashSet的构造函数："><a href="#HashSet的构造函数：" class="headerlink" title="HashSet的构造函数："></a>HashSet的构造函数：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HashSet h = <span class="keyword">new</span> HashSet();      </span><br><span class="line">默认初始化大小是<span class="number">16</span>，默认装载因子是<span class="number">0.75</span>.</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity);  </span><br><span class="line">默认装载因子是<span class="number">0.75</span></span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor);</span><br><span class="line"></span><br><span class="line">HashSet h = <span class="keyword">new</span> HashSet(Collection C);</span><br></pre></td></tr></table></figure>

<h2 id="什么是初始化大小与装载因子："><a href="#什么是初始化大小与装载因子：" class="headerlink" title="什么是初始化大小与装载因子："></a>什么是初始化大小与装载因子：</h2><p>初始化尺寸就是当创建哈希表（HashSet内部用哈希表的数据结构）的时候桶（buckets）的数量。如果当前的尺寸已经满了，那么桶的数量会自动增长。</p>
<p>装载因子衡量的是在HashSet自动增长之前允许有多满。当哈希表中实体的数量已经超出装载因子与当前容量的积，那么哈希表就会再次进行哈希（也就是内部数据结构重建），这样哈希表大致有两倍桶的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">                    表中已经存储的元素的数量</span><br><span class="line"></span><br><span class="line">装载因子 = *-----------------------------------------*</span><br><span class="line"></span><br><span class="line">                    哈希表的大小</span><br></pre></td></tr></table></figure>

<p> 例如：如果内部容量为16，装载因子为0.75，那么当表中有12个元素的时候，桶的数量就会自动增长。 </p>
<p>性能影响：</p>
<p>装载因子和初始化容量是影响HashSet操作的两个主要因素。装载因子为0.75的时候可以提供关于时间和空间复杂度方面更有效的性能。如果我们加大这个装载因子，那么内存的上限就会减小（因为它减少了内部重建的操作），但是将影响哈希表中的add与查询的操作。为了减少再哈希操作，我们应该选择一个合适的初始化大小。如果初始化容量大于实体的最大数量除以装载因子，那么就不会有再哈希的动作发生了。</p>
<p>HashSet中的一些重要方法：</p>
<ul>
<li>boolean add(E e)：如果不存在则添加，存在则返回false。</li>
<li>void clear() ：移除Set中所有的元素</li>
<li>boolean contains(Object o)：如果这个元素在set中存在，那么返回true。</li>
<li>boolean remove(Object o)：如果这个元素在set中存在，那么从set中删除。</li>
<li>Iterator iterator()：返回set中这个元素的迭代器。</li>
</ul>
<h2 id="HashSet内部是如何工作的？"><a href="#HashSet内部是如何工作的？" class="headerlink" title="HashSet内部是如何工作的？"></a>HashSet内部是如何工作的？</h2><p> 所有Set接口的类内部都是由Map做支撑的。HashSet用HashMap对它的内部对象进行排序。你一定好奇输入一个值到HashMap，我们需要的是一个键值对，但是我们传给HashSet的是一个值。 </p>
<p>那么HashMap是如何排序的？</p>
<p>实际上我们插入到HashSet中的值在map对象中起的是键的作用，因为它的值Java用了一个常量。所以在键值对中所有的键的值都是一样的。</p>
<p>如果我们在Java Doc中看一下HashSet的实现，大致是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 1</span></span><br><span class="line"><span class="comment">// All the constructors are internally creating HashMap Object.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor - 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Creating internally backing HashMap object</span></span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p> 如果我们看下HashSet中的add方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> map.put(e, PRESENT) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 我们可以注意到，HashSet类的add()方法内部调用的是HashMap的put()方法，通过你指定的值作为key，常量“PRESENT”作为值传过去。 </p>
<p> remove()也是用类似的方法工作。它内部调用的是Map接口的remove。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> map.remove(o) == PRESENT;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet操作的时间复杂度：</p>
<p>HashSet底层的数据结构是哈希表，所以HashSet的add，remove与查询（包括contain方法）的分摊（平均或者一般情况）时间复杂度是O(1)。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Liu Dong</p><p>原文链接: <a href="https://liudong-code.github.io/2020/03/04/HashSet内部是如何工作的/">https://liudong-code.github.io/2020/03/04/HashSet内部是如何工作的/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">Java基础知识</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/" class="pre">hashCode和equals</a><a href="/liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" class="next">Java反射机制</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-中的-HashSet，内部是如何工作的？"><span class="toc-text">Java 中的 HashSet，内部是如何工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#概述："><span class="toc-text">概述：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet："><span class="toc-text">HashSet：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet的构造函数："><span class="toc-text">HashSet的构造函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是初始化大小与装载因子："><span class="toc-text">什么是初始化大小与装载因子：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet内部是如何工作的？"><span class="toc-text">HashSet内部是如何工作的？</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/">MySql数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/">hashCode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/">HashSet内部是如何工作的</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/">Map类</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">数组和链表数据结构描述，各自的时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">java8的新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/">动态代理与cglib实现的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">IO模型</a> <a href="/liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/" style="font-size: 15px;">Redis相关</a> <a href="/liudong-code.github.io/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a> <a href="/liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">日常随笔</a> <a href="/liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/liudong-code.github.io/archives/2020/">2020</a><span class="archive-list-count">40</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/liudong-code.github.io/baidusitemap.xml">网站地图</a> |  <a href="/liudong-code.github.io/atom.xml">订阅本站</a> |  <a href="/liudong-code.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/liudong-code.github.io/." rel="nofollow">Liu Dong.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/liudong-code.github.io/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/liudong-code.github.io/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/liudong-code.github.io/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/share/css/share.css"><script type="text/javascript" src="/liudong-code.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/liudong-code.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>