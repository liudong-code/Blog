<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><meta name="keywords" content="JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/style.css?v=2.0.5"><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/css/highlight.css?v=2.0.5"><link rel="Shortcut Icon" href="/liudong-code.github.io/favicon.ico"><link rel="bookmark" href="/liudong-code.github.io/favicon.ico"><link rel="apple-touch-icon" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/liudong-code.github.io/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/liudong-code.github.io/atom.xml"><title>缓存 | code</title><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">缓存</h1><a id="logo" href="/liudong-code.github.io/.">code</a><p class="description">码总</p></div><div id="nav-menu"><a href="/liudong-code.github.io/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/liudong-code.github.io/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/liudong-code.github.io/about/"><i class="fa fa-user"> 关于</i></a><a href="/liudong-code.github.io/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">缓存</h1><div class="post-meta"><a href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/#comments" class="comment-count"></a><p><span class="date">Mar 05, 2020</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="一、什么是缓存？"><a href="#一、什么是缓存？" class="headerlink" title="一、什么是缓存？"></a><strong>一、什么是缓存？</strong></h2><ul>
<li>缓存就是数据交换的缓冲区（称作：Cache），当某一硬件要读取数据时，会首先从缓存汇总查询数据，有则直接执行，不存在时从内存中获取。由于缓存的数据比内存快的多，所以缓存的作用就是帮助硬件更快的运行。</li>
<li>缓存往往使用的是RAM（断电既掉的非永久存储），所以在用完后还是会把文件送到硬盘等存储器中永久存储。电脑中最大缓存就是内存条，硬盘上也有16M或者32M的缓存。</li>
<li>高速缓存是用来协调CPU与主存之间存取速度的差异而设置的。一般CPU工作速度高，但内存的工作速度相对较低，为了解决这个问题，通常使用高速缓存，高速缓存的存取速度介于CPU与主存之间。系统将一些CPU在最近几个时间段经常访问的内容存在高速缓存，这样就在一定程度上缓解了由于主存速度低造成的CPU“停工待料”的情况。</li>
<li>缓存就是把一些外存上的数据保存在内存上而已，为什么保存在内存上，我们运行的所有程序里面的变量都是存放在内存中的，所以如果想将值放入内存上，可以通过变量的方式存储。在JAVA中一些缓存一般都是通过Map集合来实现的。</li>
</ul>
<p>缓存在不同的场景下，作用是不一样的具体举例说明：</p>
<ul>
<li>操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。</li>
<li>数据库缓存——&gt;减少文件系统IO。</li>
<li>应用程序缓存——&gt;减少对数据库的查询。</li>
<li>Web服务器缓存——&gt;减少应用服务器请求。</li>
<li>客户端浏览器缓存——&gt;减少对网站的访问。</li>
</ul>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache.png" alt></p>
<h2 id="二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"><a href="#二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。" class="headerlink" title="二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"></a>二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。</h2><p> 【1】由于不同系统的数据访问模式不同，同一种缓存策略很难在不同的数据访问模式下取得满意的性能，研究人员提出不同缓存策略以适应不同的需求。缓存策略的分类： </p>
<p>  1）、基于访问的时间：此类算法按各缓存项被访问时间来组织缓存队列，决定替换对象。如 LRU；<br>   2）、基于访问频率：此类算法用缓存项的被访问频率来组织缓存。如 LFU、LRU2、2Q、LIRS；<br>   3）、访问时间与频率兼顾：通过兼顾访问时间和频率。使得数据模式在变化时缓存策略仍有较好性能。如 FBR、LRUF、ALRFU。多数此类算法具有一个可调或自适应参数，通过该参数的调节使缓存策略在基于访问时间与频率间取得一个平衡；<br>   4）、基于访问模式：某些应用有较明确的数据访问特点，进而产生与其相适应的缓存策略。如专用的 VoD 系统设计的A&amp;L缓存策略，同时适应随机、顺序两种访问模式的 SARC策略；</p>
<p> 【2】、数据不一致性产生的原因： </p>
<p> 1）、先操作缓存，再写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。在分布式环境下，数据的读写都是并发的，一个服务多机器部署，对同一个数据进行读写，在数据库层面并不能保证完成顺序，就有可能后读的操作先完成（读取到的是脏数据），如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>【解决办法】：</p>
<ul>
<li>可采用更新前后双删除缓存策略；</li>
<li>可以通过“串行化”解决，保证同一个数据的读写落在同一个后端服务上；</li>
</ul>
<p>  2）、先操作数据库，再清除缓存。如果删缓存失败了，就会出现数据不一致问题。<br>【解决办法】：①、将删除失败的 key 值存入队列中重复删除</p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache1.png" alt></p>
<p> （1）更新数据库数据。<br>  （2）缓存因为种种问题删除失败。<br>  （3）将需要删除的key发送至消息队列。<br>  （4）自己消费消息，获得需要删除的key。<br>  （5）继续重试删除操作，直到成功。<br>  <strong>缺点</strong>：对业务线代码造成大量的侵入。于是有了方案二。 </p>
<p> ②、方案二：通过订阅 binlog 获取需要重新删除的 Key 值数据。在应用程序中，另起一段程序，获得这个订阅程序传来的消息，进行删除缓存操作 </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache2.png" alt></p>
<p>​    （1）更新数据库数据<br>​    （2）数据库会将操作信息写入binlog日志当中<br>​    （3）订阅程序提取出所需要的数据以及key<br>​    （4）另起一段非业务代码，获得该信息<br>​    （5）尝试删除缓存操作，发现删除失败<br>​    （6）将这些信息发送至消息队列<br>​    （7）重新从消息队列中获得该数据，重试操作。</p>
<h2 id="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"><a href="#三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。" class="headerlink" title="三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"></a><strong>三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。</strong></h2><p> <strong>【</strong>1】、缓存穿透：缓存穿透是说收到一个请求，但是该请求缓存中不存在，只能去数据库中查询，然后放进缓存。但当有好多请求同时访问同一个数据时，业务系统把这些请求全发到了数据库；或者恶意构造一个逻辑上不存在的数据，然后大量发送这个请求，这样每次都会被发送到数据库，最总导致数据库挂掉。 </p>
<p> 【<strong>解决的办法</strong>】：对于恶意访问，一种思路是先做校验，对恶意数据直接过滤掉，不要发送至数据库层；第二种思路是缓存空结果，就是对查询不存在的数据也记录在缓存中，这样就可以有效的减少查询数据库的次数。非恶意访问，结合缓存击穿说明。 </p>
<p> 【2】、缓存击穿：上面提到的某个数据没有，然后好多请求查询数据库，可以归为缓存击穿的范畴：对于<strong>热点数据</strong>，当缓存失效的一瞬间，所有的请求都被下放到数据库去请求更新缓存，数据库被压垮。 </p>
<p>【解决的办法】：防范此类问题，一种思路是加<strong>全局锁</strong>，就是所有访问某个数据的请求都共享一个锁，获得锁的那个才有资格去访问数据库，其他线程必须等待。但现在大部分系统都是分布式的，本地锁无法控制其他服务器也等待，所以要用到全局锁，比如Redis的setnx实现全局锁。另一种思想是对<strong>即将过期的数据进行主动刷新</strong>，比如新起一个线程轮询数据，或者比如把所有的数据划分为不同的缓存区间，定期分区间刷新数据。第二个思路与缓存雪崩有点关系。</p>
<p> 【3】、缓存雪崩：缓存雪崩是指当我们给所有的缓存设置了同样的过期时间，当某一时刻，整个缓存的数据全部过期了，然后瞬间所有的请求都被抛向了数据库，数据库就崩掉了。 </p>
<p> 【<strong>解决的办法</strong>】：解决思路要么是分治，<strong>划分更小的缓存区间</strong>，按区间过期；要么<strong>给每个key的过期时间加一个随机值</strong>，避免同时过期，达到错峰刷新缓存的目的。  </p>
<p>对于 Redis 挂掉了，请求全部走数据库，也属于缓存雪崩，我们可以有以下思路进行解决：</p>
<ul>
<li><p>事发前：实现 Redis 的高可用（主从架构+Sentinel 或者 Redis Cluster），尽可能避免 Redis 挂掉这种情况。</p>
</li>
<li><p>事发中：万一 Redis 真的挂了，我们可以设置本地缓存（ehcache）+ 限流（hystrix），尽量避免我们的数据库被干掉。</p>
</li>
<li><p>事发后：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。</p>
</li>
</ul>
<h2 id="四、Redis内存用完会发生什么？"><a href="#四、Redis内存用完会发生什么？" class="headerlink" title="四、Redis内存用完会发生什么？"></a><strong>四、Redis内存用完会发生什么？</strong></h2><p> 如果达到设置的上限，Redis 的<strong>写命令会返回错误信息</strong>（但是读命令还是可以正常返回），或者将 Redis 当缓存使用，<strong>配置缓存淘汰机制</strong>，当 Redis 达到内存的上线时会冲掉旧的数据。 </p>
<h2 id="五、Redis-的-List-结构相关的操作"><a href="#五、Redis-的-List-结构相关的操作" class="headerlink" title="五、Redis 的 List 结构相关的操作"></a><strong>五、Redis 的 List 结构相关的操作</strong></h2><p> 【1】、PUSH操作：是从队列头部和尾部增加节点的操作。 </p>
<ul>
<li>RPUSH KEY VALUE [VALUE …] ：从队列的右端入队一个或者多个数据，如果key值不存在，会自动创建一个空的列表。如果对应的key不是一个List，则会返回一个错误。</li>
<li>LPUSH KEY VALUE [VALUE…] ：从队列的左边入队一个或多个元素。复杂度O(1)。</li>
<li>RPUSHX KEY VALUE：从队列的右边入队一个元素，仅队列存在时有效，当队列不存在时，不进行任何操作。</li>
<li>LPUSHX KEY VALUE：从队列的左边入队一个元素，仅队列存在时有效。当队列不存在时，不进行任何操作。</li>
</ul>
<p> 【2】、POP操作：获取并删除头尾节点的操作。 </p>
<ul>
<li>LPOP KEY：从队列左边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li>
<li>RPOP KEY：从队列的右边出队一个元素，复杂度O(1)。如果list为空，则返回nil。</li>
<li>BLPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最左边的第一个元素，当队列为空时，阻塞TIMEOUT时间，单位是秒（这个时间内尝试获取KEY中的数据），超过TIMEOUT后如果仍未数据则返回(nil)。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; BLPOP <span class="built_in">queue</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> (nil)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> (<span class="number">1.10</span>s)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>BRPOP KEY[KEY…] TIMEOUT：删除&amp;获取KEY中最后一个元素，或阻塞TIMEOUT。如上↑ </p>
<p>【4】、其他 </p>
</li>
<li><p>LLEN KEY：获取队列（List）的长度。</p>
</li>
<li><p>LRANG KEY START STOP：从列表中获取指定（START-STOP）长度的元素。负数表示从右向左数。需要注意的是，超出范围的下标不会产生错误：如果start&gt;end，会得到空列表，如果end超过队尾，则Redis会将其当做列表的最后一个元素。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> redis&gt; rpush q1 a b c d f e g</span><br><span class="line"></span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q1 <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"f"</span></span><br><span class="line"></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"e"</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>LINDEX KEY INDEX：获取一个元素，通过其索引列表。我们之前介绍的操作都是对list的两端进行的，所以算法复杂度都只有O(1)。而这个操作是指定位置来进行的，每次操作，list都得找到对应的位置，因此算法复杂度为O(N)。list的下表是从0开始的，index为负的时候是从右向左数。-1表示最后一个元素。当下标超出的时候，会返回nul。所以不用像操作数组一样担心范围越界的情况。</p>
</li>
<li><p>LSET KEY INDEX：重置队列中INDEX位置的值。当index越界的时候，这里会报异常。 </p>
</li>
<li><p>LREM KEY COUNT VALUE：从列表中删除COUNT个VALUE元素。COUNT参数有三种情况： </p>
<p>​      count &gt; 0: 表示从头向尾（左到右）移除值为value的元素。<br>​      count &lt; 0: 表示从尾向头（右向左）移除值为value的元素。<br>​      count = 0: 表示移除所有值为value的元素。 </p>
</li>
<li><p>LTRIM KEY START STOP：修剪到指定范围内的清单，相当与截取，只保留START-STOP之间的数据。 </p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> redis&gt; rpush q a b c d e f g</span><br><span class="line"> <span class="number">2</span> (integer) <span class="number">7</span></span><br><span class="line"> <span class="number">3</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"> <span class="number">4</span> <span class="number">1</span>) <span class="string">"a"</span></span><br><span class="line"> <span class="number">5</span> <span class="number">2</span>) <span class="string">"b"</span></span><br><span class="line"> <span class="number">6</span> <span class="number">3</span>) <span class="string">"c"</span></span><br><span class="line"> <span class="number">7</span> <span class="number">4</span>) <span class="string">"d"</span></span><br><span class="line"> <span class="number">8</span> <span class="number">5</span>) <span class="string">"e"</span></span><br><span class="line"> <span class="number">9</span> <span class="number">6</span>) <span class="string">"f"</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span>) <span class="string">"g"</span></span><br><span class="line"><span class="number">11</span> redis&gt; ltrim q <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">12</span> OK</span><br><span class="line"><span class="number">13</span> redis&gt; lrange q <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">14</span> <span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">15</span> <span class="number">2</span>) <span class="string">"c"</span></span><br><span class="line"><span class="number">16</span> <span class="number">3</span>) <span class="string">"d"</span></span><br><span class="line"><span class="number">17</span> <span class="number">4</span>) <span class="string">"e"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LINSERT KEY BEFORE|AFTER 元素 VALUE：在列表中的另一个元素之前或之后插入VAULE。当 key 不存在时，这个List被视为空列表，任何操作都不会发生。当key存在，但保存的不是 List，则会报 error。该命令会返回修改之后的 List的长度，如果找不到元素，则会返回 -1。</li>
</ul>
<h2 id="六、Redis的数据结构都有哪些"><a href="#六、Redis的数据结构都有哪些" class="headerlink" title="六、Redis的数据结构都有哪些"></a><strong>六、Redis的数据结构都有哪些</strong></h2><p>【1】、String：可以是字符串，整数或者浮点数，对整个字符串或者字符串中的一部分执行操作，对整个整数或者浮点执行自增(increment)或者自减(decrement)操作。<br>【2】、List：一个链表，链表上的每个节点都包含了一个字符串，链表的两端推入或者弹出元素，根据偏移量对链表进行修剪(trim)，读取单个或者多个元素，根据值查找或者移除元素。可参考5<br>【3】、Set：包含字符串的无序收集器(unordered collection)、并且被包含的每个字符串都是独一无二的。添加，获取，移除单个元素，检查一个元素是否存在于集合中，计算交集（sinter），并集（suion），差集（sdiff），从集合里面随机获取元素。<br>【4】、SortSet：是一个排好序的 Set，它在 Set 的基础上增加了一个顺序属性 score，这个属性在添加修改元素时可以指定，每次指定后，SortSet 会自动重新按新的值排序。sorted set 的内部使用 HashMap 和跳跃表(SkipList)来保证数据的存储和有序，HashMap 里放的是成员到 score 的映射，而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 score。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; zadd myzset <span class="number">1</span> <span class="string">"one"</span> <span class="number">2</span> <span class="string">"two"</span> <span class="number">3</span> <span class="string">"three"</span> #添加元素</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"one"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"1"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrem myzset one   <span class="comment">//删除元素</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.129</span>:<span class="number">6379</span>&gt; zrange myzset <span class="number">0</span> <span class="number">-1</span> withscores</span><br><span class="line"><span class="number">1</span>) <span class="string">"two"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"three"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"3"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure>

<p>【 5】、hash：Hash 是一个 String 类型的 field 和 value 之间的映射表，即 redis 的 Hash 数据类型的 key（hash表名称）对应的 value 实际的内部存储结构为一个 HashMap，因此 Hash 特别适合存储对象。相对于把一个对象的每个属性存储为 String 类型，将整个对象存储在 Hash 类型中会占用更少内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hset myhash age <span class="number">20</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash name</span><br><span class="line"><span class="string">"zhangsan"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt; hget myhash age</span><br><span class="line"><span class="string">"20"</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.2</span><span class="number">.124</span>:<span class="number">6379</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"><a href="#七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。" class="headerlink" title="七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"></a><strong>七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</strong></h2><p>使用阶段我们从数据存储和数据获取两个方面来说明开发时的注意事项：<br>【1】数据存储：因为内存空间的局限性，注定了能存储的数据量有限，如何在有限的空间内存储更多的数据信息是我们应该关注的。Redis内存储的都是键值对，那么如何减小键值对所占据的内存空间就是空间优化的本质。在能清晰表达业务含义的基础上尽可能缩减Key的字符长度，比如一个键是user:{id}:logintime ，可以使用业务属性的简写来u:{id}:lgt,只要能清晰表达业务意义，使用简写形式是有其必要性的。在不影响使用的情况下，缩减Value的数据大小。如果Value是较大的数据信息，比如图片，大文本等，可以使用压缩工具压缩过后再存入Redis；如果Value是对象序列化或者gson信息，可以考虑去除非必要的业务属性。<br>减少键值对的数量，对于大量的String类型的小对象，可以尝试使用Hash的形式组合他们，在Hash对象内Field数量少于1000，且Value的字符长度小于40时，内部使用ziplist的编码形式，能够极大的降低小对象占据的内存空间。<br>Redis内维护了一个[0-9999]的整数对象池，类似Java内的运行时常量池，只创建一个常量，使用时都去引用这个常量，所以当存储的value是这个范围内的数字时均是引用向都一个内存地址，所以能够降低一些内存空间耗费。但是共享对象池和maxmemory+LRU的内存回收策略冲突，因为共享Value对象的lru值也共享，难以通过lru知道哪个Key的最后引用时间，所以永远也不能回收内存。如果多次数据操作要求原子性，可使用Multi来实现Redis的事务。<br>【2】数据查询：Redis 是一种数据库，和其他数据库一样，操作时也需要有连接对象，连接对象的创建和销毁也需要耗费资源，复用连接对象很有必要，所以推荐使用连接池来管理连接。Redis数据存储在内存中，查询很快，但不代表连接也很快。一次Redis查询可能IO部分占据了请求时间的绝大部分比例，缩短IO时间是开发过程中很需要注意的一点。对于一个业务内的多次查询，考虑使用Pipeline，将多次查询合并为一次查询，命令会被执行多次，但是只有一个IO传输，能够有效的提高响应速度。<br>对于多次String类型的查询，使用mget，将多次请求合并为一次，同时命令和会被合并为一次，能有效提高响应速度，对于Hash内多个Field查询，使用hmget，起到和mget同样的效果。Redis是单线程执行的，也就是说同一时间只能执行一条命令，如果一条命令执行的时间较长，其他线程在此期间均会被阻塞，所以在操作Redis时要注意操作指令的涉及的数据量，尽量降低单次操作的执行时间。<br>【持久化方式】：RDB 时间点快照 AOF 记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。可参考14深度解析<br>【内存设置】：maxmemory used_memory<br>【虚拟内存】： vm-enabled yes<br>【集群的应用和优劣势】：参考9<br>【内存优化】：<a href="http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/tq-redis-memory-usage-optimization-storage</a><br>【淘汰策略】：<a href="http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/redis/data-elimination-mechanism.html</a></p>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用 的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数 据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据 淘汰</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-enviction（驱逐）：禁止驱逐数据</li>
</ol>
<h2 id="八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制"><a href="#八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制" class="headerlink" title="八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制"></a><strong>八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制</strong></h2><p>集群方式的区别：Redis3 采用Cluster，Redis2 采用客户端分区方案和代理方案；<br>通信过程说明：<br>  1） 集群中的每个节点都会单独开辟一个TCP通道， 用于节点之间彼此通信， 通信端口号在基础端口上加10000。<br>  2） 每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息。<br>  3） 接收到 ping 消息的节点用 pong 消息作为响应。</p>
<h2 id="九、当前-Redis-集群有哪些玩法，各自优缺点，场景。"><a href="#九、当前-Redis-集群有哪些玩法，各自优缺点，场景。" class="headerlink" title="九、当前 Redis 集群有哪些玩法，各自优缺点，场景。"></a><strong>九、当前 Redis 集群有哪些玩法，各自优缺点，场景。</strong></h2><p>【1】数据共享：Redis 提供多个节点实例间的数据共享，也就是 Redis A,B,C,D彼此之间的数据是同步的，同样彼此之间也可以通信，而对于客户端操作的 keys 是由 Redis 系统自行分配到各个节点中。<br>【2】主从复制：Redis 的多个实例间通信时，一旦其中的一个节点故障，那么 Redis 集群就不能继续正常工作，所以需要一种复制机制（Master-Slave）机制，做到一旦节点A故障了，那么其从节点A1和A2就可以接管并继续提供与A同样的工作服务，当然如果节点A,A1,A2节点都出现问题，那么同样这个集群不会继续保持工作，但是这种情况比较罕见，即使出现了，也会及时发现并修复使用。建议：部署主从复制机制（Master-Slave）。<br>【3】哈希槽值：Redis 集群中使用哈希槽来存储客户端的 keys，而在 Redis 中，目前存在16384个哈希槽，它们被全部分配给所有的节点，正如上图所示，所有的哈希槽值被节点A，B，C分配完成了。<br>参考：<a href="https://www.cnblogs.com/RENQIWEI1995/p/8931678.html" target="_blank" rel="noopener">https://www.cnblogs.com/RENQIWEI1995/p/8931678.html</a></p>
<h2 id="十、Memcache-的原理，哪些数据适合放在缓存中。"><a href="#十、Memcache-的原理，哪些数据适合放在缓存中。" class="headerlink" title="十、Memcache 的原理，哪些数据适合放在缓存中。"></a><strong>十、Memcache 的原理，哪些数据适合放在缓存中。</strong></h2><p> 首先要说明一点，MemCache 的数据存放在内存中，存放在内存中个人认为意味着几点： </p>
<p> 【1】访问数据的速度比传统的关系型数据库要快，因为 Oracle、MySQL 这些传统的关系型数据库为了保持数据的持久性，数据存放在硬盘中，IO操作速度慢； </p>
<p> 【2】MemCache 的数据存放在内存中同时意味着只要 MemCache 重启了，数据就会消失； </p>
<p> 【3】既然 MemCache 的数据存放在内存中，那么势必受到机器位数的限制，这个之前的文章写过很多次了，32位机器最多只能使用2GB的内存空间，64位机器可以认为没有上限。</p>
<p>  然后我们来看一下 MemCache 的原理，MemCache 最重要的莫不是内存分配的内容了，MemCache 采用的内存分配方式是固定空间分配，一张图说明： </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache3.png" alt></p>
<p>这张图片里面涉及了slab_class、slab、page、chunk四个概念，它们之间的关系是：<br>【1】、MemCache将内存空间分为一组slab<br>【2】、每个slab下又有若干个page，每个page默认是1M，如果一个slab占用100M内存的话，那么这个slab下应该有100个page<br>【3】、每个page里面包含一组chunk，chunk是真正存放数据的地方，同一个slab里面的chunk的大小是固定的<br>【4】、有相同大小chunk的slab被组织在一起，称为slab_class<br>MemCache内存分配的方式称为allocator，slab的数量是有限的，几个、十几个或者几十个，这个和启动参数的配置相关。<br>MemCache中的value过来存放的地方是由value的大小决定的，value总是会被存放到与chunk大小最接近的一个slab中，比如slab[1]的chunk大小为80字节、slab[2]的chunk大小为100字节、slab[3]的chunk大小为128字节（相邻slab内的chunk基本以1.25为比例进行增长，MemCache启动时可以用-f指定这个比例），那么过来一个88字节的value，这个value将被放到2号slab中。放slab的时候，首先slab要申请内存，申请内存是以page为单位的，所以在放入第一个数据的时候，无论大小为多少，都会有1M大小的page被分配给该slab。申请到page后，slab会将这个page的内存按chunk的大小进行切分，这样就变成了一个chunk数组，最后从这个chunk数组中选择一个用于存储数据。<br>如果这个slab中没有chunk可以分配了怎么办，如果MemCache启动没有追加-M（禁止LRU，这种情况下内存不够会报Out Of Memory错误），那么MemCache会把这个slab中最近最少使用的chunk中的数据清理掉，然后放上最新的数据。针对MemCache的内存分配及回收算法，总结三点：</p>
<p> 【1】、MemCache的内存分配chunk里面会有内存浪费，88字节的value分配在128字节（紧接着大的用）的chunk中，就损失了30字节，但是这也避免了管理内存碎片的问题 </p>
<p> 【2】、MemCache的LRU算法不是针对全局的，是针对slab的 </p>
<p> 【3】、应该可以理解为什么MemCache存放的value大小是限制的，因为一个新数据过来，slab会先以page为单位申请一块内存，申请的内存最多就只有1M，所以value大小自然不能大于1M了。 </p>
<p> <strong>再总结 MemCache 的特性和限制：</strong> </p>
<p>上面已经对于MemCache做了一个比较详细的解读，这里再次总结MemCache的限制和特性：<br>1】、MemCache中可以保存的item数据量是没有限制的，只要内存足够<br>2】、MemCache单进程在32位机中最大使用内存为2G，这个之前的文章提了多次了，64位机则没有限制<br>3】、Key最大为250个字节，超过该长度无法存储<br>4】、单个item最大数据是1MB，超过1MB的数据不予存储<br>5】、MemCache服务端是不安全的，比如已知某个MemCache节点，可以直接telnet过去，并通过flush_all让已经存在的键值对立即失效<br>6】、不能够遍历MemCache中所有的item，因为这个操作的速度相对缓慢且会阻塞其他的操作<br>7】、MemCache的高性能源自于两阶段哈希结构：第一阶段在客户端，通过Hash算法根据Key值算出一个节点；第二阶段在服务端，通过一个内部的Hash算法，查找真正的item并返回给客户端。从实现的角度看，MemCache是一个非阻塞的、基于事件的服务器程序<br>8】、MemCache设置添加某一个Key值的时候，传入expiry为0表示这个Key值永久有效，这个Key值也会在30天之后失效。</p>
<p> <strong>MemCache适合存储：</strong> </p>
<p>变化频繁，具有不稳定性的数据,不需要实时入库, (比如用户在线状态、在线人数..)门户网站的新闻等，觉得页面静态化仍不能满足要求，可以放入到memcache中.(配合jquey的ajax请求)。 </p>
<h2 id="十一、Redis-和-Memcached-的内存管理的区别"><a href="#十一、Redis-和-Memcached-的内存管理的区别" class="headerlink" title="十一、Redis 和 Memcached 的内存管理的区别"></a><strong>十一、Redis 和 Memcached 的内存管理的区别</strong></h2><p>可参考博客1：<a href="http://lib.csdn.net/article/redis/55323" target="_blank" rel="noopener">http://lib.csdn.net/article/redis/55323</a><br>可参考博客2：<a href="https://www.cnblogs.com/work115/p/5584646.html" target="_blank" rel="noopener">https://www.cnblogs.com/work115/p/5584646.html</a> </p>
<h2 id="十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？"><a href="#十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？" class="headerlink" title="十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？"></a>十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？</h2><p>Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 本身没有锁的概念，Redis 对于多个客户端连接并不存在竞争，但是在 Jedis 客户端对 Redis 进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：<br>【1】客户端角度，为保证每个客户端间正常有序与 Redis 进行通信，对连接进行池化，同时对客户端读写 Redis 操作采用内部锁 synchronized。<br>【2】服务器角度，利用 setnx 实现锁</p>
<p> MULTI，EXEC，DISCARD，WATCH 四个命令是 Redis 事务的四个基础命令。其中：<br>   ☆ MULTI，告诉 Redis 服务器开启一个事务。注意，只是开启，而不是执行<br>   ☆ EXEC，告诉 Redis 开始执行事务<br>   ☆ DISCARD，告诉 Redis 取消事务<br>   ☆ WATCH，监视某一个键值对，它的作用是在事务执行之前如果监视的键值被修改，事务会被取消。</p>
<p>【<strong>Redis 事务机制</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a><br>【<strong>CAS 操作</strong>】：<a href="https://www.jianshu.com/p/d777eb9f27df" target="_blank" rel="noopener">https://www.jianshu.com/p/d777eb9f27df</a> </p>
<h2 id="十三、Redis-的选举算法和流程是怎样的"><a href="#十三、Redis-的选举算法和流程是怎样的" class="headerlink" title="十三、Redis 的选举算法和流程是怎样的"></a><strong>十三、Redis 的选举算法和流程是怎样的</strong></h2><p><strong>Raft</strong> 采用心跳机制触发 Leader 选举。系统启动后，全部节点初始化为 Follower，term 为0。节点如果收到了 RequestVote 或者AppendEntries，就会保持自己的 Follower 身份。如果一段时间内没收到 AppendEntries 消息直到选举超时，说明在该节点的超时时间内还没发现 Leader，Follower 就会转换成 Candidate，自己开始竞选 Leader。一旦转化为 Candidate，该节点立即开始下面几件事情：<br> 1）、增加自己的term。<br> 2）、启动一个新的定时器。<br> 3）、给自己投一票。<br> 4）、向所有其他节点发送RequestVote，并等待其他节点的回复。<br>✔ 如果在这过程中收到了其他节点发送的AppendEntries，就说明已经有Leader产生，自己就转换成Follower，选举结束。<br>✔ 如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时向所有其他节点发送AppendEntries，告知自己成为了Leader。<br>✔ 每个节点在一个term内只能投一票，采取先到先得的策略，Candidate前面说到已经投给了自己，Follower会投给第一个收到RequestVote的节点。每个Follower有一个计时器，在计时器超时时仍然没有接受到来自Leader的心跳RPC, 则自己转换为Candidate, 开始请求投票，就是上面的的竞选Leader步骤。<br>✔ 如果多个Candidate发起投票，每个Candidate都没拿到多数的投票（Split Vote），那么就会等到计时器超时后重新成为Candidate，重复前面竞选Leader步骤。<br>✔ Raft协议的定时器采取随机超时时间，这是选举Leader的关键。每个节点定时器的超时时间随机设置，随机选取配置时间的1倍到2倍之间。由于随机配置，所以各个Follower同时转成Candidate的时间一般不一样，在同一个term内，先转为Candidate的节点会先发起投票，从而获得多数票。多个节点同时转换为Candidate的可能性很小。即使几个Candidate同时发起投票，在该term内有几个节点获得一样高的票数，只是这个term无法选出Leader。由于各个节点定时器的超时时间随机生成，那么最先进入下一个term的节点，将更有机会成为Leader。连续多次发生在一个term内节点获得一样高票数在理论上几率很小，实际上可以认为完全不可能发生。一般1-2个term类，Leader就会被选出来。</p>
<p><strong>【Sentinel 的选举流程】</strong>：Sentinel 集群正常运行的时候每个节点 epoch 相同，当需要故障转移的时候会在集群中选出 Leader执行故障转移操作。Sentinel采 用了Raft 协议实现了 Sentinel 间选举 Leader 的算法，不过也不完全跟论文描述的步骤一致。Sentinel 集群运行过程中故障转移完成，所有 Sentinel 又会恢复平等。Leader 仅仅是故障转移操作出现的角色。</p>
<p>【选举流程】：1）、某个 Sentinel 认定 master 客观下线的节点后，该 Sentinel 会先看看自己有没有投过票，如果自己已经投过票给其他 Sentinel 了，在2倍故障转移的超时时间自己就不会成为 Leader。相当于它是一个 Follower。<br>  2）、如果该 Sentinel 还没投过票，那么它就成为 Candidate。<br>  3）、和 Raft 协议描述的一样，成为 Candidate，Sentinel 需要完成几件事情。<br>   【1】更新故障转移状态为start<br>   【2】当前epoch加1，相当于进入一个新term，在Sentinel中epoch就是Raft协议中的term。<br>   【3】更新自己的超时时间为当前时间随机加上一段时间，随机时间为1s内的随机毫秒数。<br>   【4】向其他节点发送is-master-down-by-addr命令请求投票。命令会带上自己的epoch。<br>   【5】给自己投一票，在 Sentinel 中，投票的方式是把自己 master 结构体里的 leader 和 leader_epoch 改成投给的 Sentinel 和它的 epoch。<br>   4）、其他Sentinel会收到Candidate的is-master-down-by-addr命令。如果Sentinel当前epoch和Candidate传给他的epoch一样，说明他已经把自己master结构体里的leader和leader_epoch改成其他Candidate，相当于把票投给了其他Candidate。投过票给别的Sentinel后，在当前epoch内自己就只能成为Follower。<br>   5）、Candidate会不断的统计自己的票数，直到他发现认同他成为Leader的票数超过一半而且超过它配置的quorum（quorum可以参考《redis sentinel设计与实现》）。Sentinel比Raft协议增加了quorum，这样一个Sentinel能否当选Leader还取决于它配置的quorum。<br>   6）、如果在一个选举时间内，Candidate没有获得超过一半且超过它配置的quorum的票数，自己的这次选举就失败了。<br>   7）、如果在一个epoch内，没有一个Candidate获得更多的票数。那么等待超过2倍故障转移的超时时间后，Candidate增加epoch重新投票。<br>   8）、如果某个Candidate获得超过一半且超过它配置的quorum的票数，那么它就成为了Leader。<br>   9）、与Raft协议不同，Leader并不会把自己成为Leader的消息发给其他Sentinel。其他Sentinel等待Leader从slave选出master后，检测到新的master正常工作后，就会去掉客观下线的标识，从而不需要进入故障转移流程。</p>
<h2 id="十四、Redis-的持久化的机制，AOF和RDB的区别。"><a href="#十四、Redis-的持久化的机制，AOF和RDB的区别。" class="headerlink" title="十四、Redis 的持久化的机制，AOF和RDB的区别。"></a>十四、Redis 的持久化的机制，AOF和RDB的区别。</h2><p><strong>Redis的持久化机制</strong>：Redis 提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。<br> <strong>AOF和RDB的区别</strong>：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache4.png" alt></p>
<p> AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache5.png" alt></p>
<p>【二者优缺点】：RDB存在哪些优势：<br>【1】一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。<br>【2】对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。<br>【3】性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。<br>【4】相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<p>【RDB又存在哪些劣势】：<br>【1】如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。<br>【2】由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<p>【AOF 的优势有哪些】：<br>【1】该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。<br>【2】由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。<br>【3】如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。<br>【4】AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p>
<p>【AOF 的劣势有哪些】：<br>【1】对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。<br>【2】根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
<p> <strong>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</strong> </p>
<h2 id="十五、缓存预热"><a href="#十五、缓存预热" class="headerlink" title="十五、缓存预热"></a><strong>十五、缓存预热</strong></h2><p> 新的缓存系统没有任何数据，在缓存重建数据的过程中，系统性能和数据负载都不太好，所以最好在系统上线之前就把缓存的热点数据加载到缓存中，这种缓存预加载手段就是缓存预热。 </p>
<h2 id="十六、缓存热备"><a href="#十六、缓存热备" class="headerlink" title="十六、缓存热备"></a><strong>十六、缓存热备</strong></h2><p> 缓存热备既当一个缓存服务器不可用时能实时切换到备用缓存服务器，不影响缓存使用。集群模式下，每个主节点都会有一个或多个从节点备用，一旦主节点挂掉，从节点会被哨兵提升为主节点使用。 </p>
<h2 id="十七、Redis-的集群怎么同步的数据的"><a href="#十七、Redis-的集群怎么同步的数据的" class="headerlink" title="十七、Redis 的集群怎么同步的数据的"></a><strong>十七、Redis 的集群怎么同步的数据的</strong></h2><p>Redis 集群没有使用一致性hash, 而是引入了哈希槽的概念。</p>
<p>Reds 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽。这种结构很容易添加或者删除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。</p>
<p>使用哈希槽的好处就在于可以方便的添加或移除节点。</p>
<p>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</p>
<p>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；</p>
<p>在这一点上，我们以后新增或移除节点的时候不用先停掉所有的 redis 服务</p>
<p><strong>Redis集群的主从架构：</strong></p>
<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品。</p>
<p>例如有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少B节点所承担的哈希槽这个范围的槽而不可用。</p>
<p>然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了。当然如果B和B1都down了，那集群还是不可用的，不过这种情况微乎其妙，基本不用考虑，出发你交换机挂了吧，或者机房断电。</p>
<p> <strong>Redis 集群搭建</strong>的方式有很多种，但从 redis 3.0 版本之后，支持 redis-cluster 集群，它是 Redis 官方提供的解决方案，Redis Cluster 采用的是 无中心架构 ，每个节点保存数据和整个集群状态，每个节点都和其他节点有所连接。其架构如下： </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache6.png" alt></p>
<p>客户端与 redis 节点直连，不需要中间件 proxy 层，客户端不需要连接集群所有节点，连接集群汇中任何一个节点即可。所有的 redis 节点彼此互联（PING-PONG 机制），内部使用二进制协议优化传输速度和带宽。 </p>
<p> <strong>分布式存储机制-槽</strong> </p>
<p>【1】、redis_cluster 把所有的节点映射到 [0-16383] slot 槽上，cluster 负责维护 node&lt;-&gt;slot&lt;-&gt;value 三者之间的关系。<br>【2】、Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先将 key 使用 CRC16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点上。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如，当有三个节点时，槽分布的值如下：</span><br><span class="line">节点1：   0-5460</span><br><span class="line">节点2：   5461-10921</span><br><span class="line">节点3:    10922-16383</span><br></pre></td></tr></table></figure>

<h2 id="十八、知道哪些-Redis-的优化操作"><a href="#十八、知道哪些-Redis-的优化操作" class="headerlink" title="十八、知道哪些 Redis 的优化操作"></a>十八、知道哪些 Redis 的优化操作</h2><h3 id="一、Linux-操作系统"><a href="#一、Linux-操作系统" class="headerlink" title="一、Linux 操作系统"></a><strong>一、Linux 操作系统</strong></h3><p>【1】<strong>ulimit 与 TCP backlog：1</strong>）、修改 ulimit：通过 ulimit 修改 open files 参数，redis 建议把 open files 至少设置成 10032，因为 maxclients 是10000  [客户端的数据是以文件的形式进行保存的] ，另外 redis 内部最多会使用 32 个文件描述符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n <span class="number">10032</span>  #但重启后就无效了，也可以通过配置文件limits.conf 的形式持久修改</span><br><span class="line">#修改了，重新登录后就立刻生效.可以用CentOS ulimit -a 查看确认</span><br><span class="line">[root@dev ~]<span class="meta"># ulimit -a</span></span><br><span class="line">#... 省略</span><br><span class="line"><span class="function"><span class="built_in">open</span> <span class="title">files</span>                      <span class="params">(-n)</span> 10032</span></span><br></pre></td></tr></table></figure>

<p> 2）、修改 TCP backlog：redis 默认的 tcp-backlog 为 511，可通过配置 tcp-backlog 进行调整，如果 Linux 的 tcp-backlog 小于 redis 的 tcp-backlog，日志里会出有 warning。此参数确定了 TCP 连接中已完成队列(完成三次握手之后)的长度， 当然此值必须小于或等于 Linux 系统定义的 [/proc/sys/net/core/somaxconn] 值，而 Linux 的默认参数值是128。当系统并发量大并且客户端速度缓慢的时候，可以将这二个参数一起参考设定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建议修改为 <span class="number">2048</span> 修改somaxconn</span><br><span class="line">#该内核参数默认值一般是<span class="number">128</span>，对于负载很大的服务程序来说大大的不够。一般会将它修改为<span class="number">2048</span>或者更大。</span><br><span class="line">echo <span class="number">2048</span> &gt; /proc/sys/net/core/somaxconn #但是这样系统重启后保存不了</span><br><span class="line"></span><br><span class="line">#持久化设置: 在 /etc/sysctl.conf 中添加如下:</span><br><span class="line"><span class="meta">#net.core.somaxconn = 2048</span></span><br><span class="line"></span><br><span class="line">#然后在终端中执行:sysctl -p</span><br></pre></td></tr></table></figure>

<p>【2】<strong>vm.overcommit_mermory</strong>：表示内核在分配内存时候做检查的方式。<br>  1）、redis 建议将 vm.overcommit_memory 设置为1，防止极端情况下 fork 出错。<br>  2）、vm.overcommit_memory 取值说明：Linux 对大多数申请内存的回复均为 YES，以运行更多程序，因为申请后并不是立马使用，该技术叫 vm.overcommit。<br>  ■  0：内核将检查是否有足够的内存，如果足够，申请通过，否则内存申请失败把错误返回给应用进程。<br>  ■  1：表示内核容许超量使用内存直到用完为止。<br>  ■  2：内存绝不过量使用内存，既系统整个内存空间不能超过 swap+50% 的 RAM[（random access memory）即随机存储内存 ]值，50% 是 overcommit_ratio 的默认值，支持修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.overcommit_memory=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>



<p> 【3】<strong>swappiness 参数</strong>：</p>
<p>1）：swappiness 参数决定操作系统使用 swap 的倾向程度，取值范围是0~100，swappiness 的值越大，说明操作系统可能使用 swap 的概率越高，swappiness 值越低，表示操作系统更加倾向于使用物理内存。 </p>
<p>2）、建议 Linux3.5 以上设置为1，否则建议设置为0。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"vm.swappiness=1"</span> &gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>

<p> 【4】<strong>Transparent Huge Pages</strong>：支持大内存分页（2MB）分配，默认开启，redis 建议关闭此功能。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chkconfig --add disable-transparent-hugepages</span><br></pre></td></tr></table></figure>

<p>【5】OOM killer：会在可用内存不足时选择性杀掉用户进程，OOM killer 会为每个用户进程设置一个权重，权重越大被 kill 的可能性越大。每个进程的权重放在 [/proc/{progress_id}/oom_adj]。对于 Redis 服务器来说，可以将所有 Redis 的 oom_adj 设置为最低值或者稍小的值，降低被 OOM killer 杀掉的概率。应该设置与进程有关，无法一次性设置。</p>
<h3 id="二、Redis-关键参数"><a href="#二、Redis-关键参数" class="headerlink" title="二、Redis 关键参数"></a><strong>二、Redis 关键参数</strong></h3><p><strong>【1】客户端最大连接数（maxclients）：</strong></p>
<p>  1）、现象：如果连接数不够，或者请求返回比较慢导致连接数不足，可能会报[ max number of clients reached ]。</p>
<p>  2）、优化：调整 maxclients，或者优化 redis 命令处理性能。要注意该参数受到操作系统最大文件句柄的限制（ulimit -n <n>）</n></p>
<p><strong>【2】repl-ping-slave-period/repl-timeout：</strong></p>
<p>1）、说明：slave 会每隔 repl-ping-slave-period（默认10秒）ping 一次 master，如果查过 repl-timeout（默认 60秒）都没有收到响应，就会认为 Master 挂掉。</p>
<p>2）、优化：如果 Master 明明没挂掉但被阻塞住了也会报这个错。可以适当调大 repl-timeout</p>
<p> <strong>【3】client-output-buffer-limit：</strong></p>
<p>  1）说明：客户端输出缓冲区大小。</p>
<p>  2）、当使用主从复制时，性能压测下，数据量会急剧增长，导致从节点需要复制的数据很大，消耗时长增加。slave 没挂但被阻塞住了，比如正在 loading Master 发过来的 RDB，Master 的指令不能立刻发送给 slave，就会放在 output-buffer 中，在配置文件中有如下配置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-<span class="built_in">buffer</span>-limit slave <span class="number">256</span>mb <span class="number">64</span>mb <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>上述配置说明：负责发送给 slave的 client，如果 buffer 超过 256m 或者连续 60秒超过 64m，就会被立刻强行关闭。所以此时应该相应调大数值，否则就会出现很悲剧的循环：Master 传输一个很大的 RDB 给 slave，slave 努力地装载，但是还没装载完，Master 对 client 的缓存存满了，关闭后再来一次。</p>
<h3 id="三、Redis-性能测试"><a href="#三、Redis-性能测试" class="headerlink" title="三、Redis 性能测试"></a><strong>三、Redis 性能测试</strong></h3><p> Redis 官网自动 Redis 性能测试工具 <strong>Redis-benchmark</strong>，可以有效的测试 Redis 服务的性能。 </p>
<p> 【1】案例一：命令如下，100个并发连接，100000个请求，检测host为127.0.0.1 端口为 6379 的 redis 服务器性能 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span> -c <span class="number">100</span> -n <span class="number">100000</span></span><br><span class="line"></span><br><span class="line">#对集合写入测试 结果如下</span><br><span class="line"><span class="number">100000</span> requests completed in <span class="number">2.38</span> seconds #<span class="number">100000</span>个请求在<span class="number">2.38</span>秒内完成</span><br><span class="line"><span class="number">20</span> parallel clients  #每次请求有<span class="number">20</span>个并发客户端</span><br><span class="line"><span class="number">3</span> bytes payload  #每次写入<span class="number">3</span>个字节的数据</span><br><span class="line">keep alive: <span class="number">1</span>  #保持一个连接，一台服务器来处理这些请求</span><br><span class="line"></span><br><span class="line"><span class="number">93.06</span>% &lt;= <span class="number">15</span> milliseconds</span><br><span class="line"><span class="number">99.96</span>% &lt;= <span class="number">31</span> milliseconds</span><br><span class="line"><span class="number">99.98</span>% &lt;= <span class="number">46</span> milliseconds</span><br><span class="line"><span class="number">99.99</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line"><span class="number">100.00</span>% &lt;= <span class="number">62</span> milliseconds</span><br><span class="line">#所有请求在<span class="number">62</span>毫秒内完成</span><br><span class="line"><span class="number">42105.26</span> requests per second</span><br><span class="line">#每秒处理<span class="number">42105.26</span>次请求</span><br></pre></td></tr></table></figure>

<p> 【2】案例二：命令如下，测试指定操作命令的性能。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-benchmark -t <span class="built_in">set</span>,lpush -n <span class="number">100000</span> -q</span><br></pre></td></tr></table></figure>

<h3 id="四、查找慢查询语句"><a href="#四、查找慢查询语句" class="headerlink" title="四、查找慢查询语句"></a><strong>四、查找慢查询语句</strong></h3><p> Redis 提供了记录耗时操作语句的功能，当语句执行（不包括命令排队时间）超过了阈值，则被认为是慢查询。 </p>
<p>【1】参数设置：[ slowlog-log-slower-than ]：记录运行耗时语句的阈值，单位是微妙（1秒=1000毫秒=1000 000微妙，默认值：10000）。当值为0时，记录所有请求。当值&lt;0时，不记录任何请求。</p>
<p> [ slowlog-max-len ]：该参数用于设置慢查询保存的条数。</p>
<p>【2】功能使用：[ slowlog get ]：用于查询慢查询信息。[ slowlog len ]：显示当前 redis 有多少条慢查询</p>
<h2 id="十九、Reids-的主从复制机制原理"><a href="#十九、Reids-的主从复制机制原理" class="headerlink" title="十九、Reids 的主从复制机制原理"></a><strong>十九、Reids 的主从复制机制原理</strong></h2><h3 id="一、Redis-复制"><a href="#一、Redis-复制" class="headerlink" title="一、Redis 复制"></a><strong>一、Redis 复制</strong></h3><p> <strong>复制（Replication）</strong>：是 Redis 实现高可用的基础。且在复制过程中，主节点/从节点都是非阻塞的，但是从节点在执行同步时使用的是旧数据集提供查询。 </p>
<p> Redis 复制启动图与流程说明： </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache7.png" alt></p>
<p>1）、当从节点连接到主节点时，会发送 psync 命令给主节点，runId 是主节点的 ID，如果没有默认是 -1；offset 是从节点保存复制偏移量，主节点根据复制偏移量仅发送从节点所需的增量部分，如果是第一次复制则为 -1；</p>
<p>2）、如果主节点回复 <strong>+FULLRESYNC</strong>，那么从节点将触发全量复制流程。</p>
<p>3）、如果主节点回复 <strong>+CONTINUE</strong>，那么从节点触发部分复制。</p>
<p>4）、如果主节点回复 <strong>+ERR</strong>，说名主节点不支持该命令。</p>
<h3 id="二、Redis-主从全量复制"><a href="#二、Redis-主从全量复制" class="headerlink" title="二、Redis 主从全量复制"></a><strong>二、Redis 主从全量复制</strong></h3><p> <strong>主从复制：</strong>主机数据更新后根据配置和策略，自动同步到备机的 master/slaver 机制，Master以写为主，Slave以读为主。 </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache8.png" alt></p>
<h3 id="三、Redis-主从部分复制"><a href="#三、Redis-主从部分复制" class="headerlink" title="三、Redis 主从部分复制"></a><strong>三、Redis 主从部分复制</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache9.png" alt></p>
<h3 id="四、Redis-主从搭建"><a href="#四、Redis-主从搭建" class="headerlink" title="四、Redis 主从搭建"></a><strong>四、Redis 主从搭建</strong></h3><p> 【1】修改主节点 redis.conf 文件：使用[./redis-server redis.conf]启动主节点。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bind <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">Port <span class="number">7000</span></span><br><span class="line"></span><br><span class="line">#是否开启保护模式，默认为 yes 是开启。要是配置里没有指定 bind 和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。</span><br><span class="line">#要是开启了密码和 bind，可以开启。否则最好关闭，设置为no。</span><br><span class="line"><span class="keyword">protected</span>-mode no </span><br><span class="line">#修改 redis 安全密码</span><br><span class="line">requirepass <span class="string">"123456789"</span></span><br><span class="line"></span><br><span class="line">master 设置密码</span><br><span class="line"></span><br><span class="line">masterauth <span class="string">"123456789"</span></span><br><span class="line">#开启appendonly 模式后,redis 将每一次写操作请求都追加到appendonly.aof 文件中</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>  【2】新建从节点并配置复制主节点信息（配从(库)不配主(库)）每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件 info replication（Redis Sentinel 还使用该信息来发现 slave 实例） </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#slaveof 主库IP 主库端口</span></span><br><span class="line"></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span> <span class="number">7000</span></span><br></pre></td></tr></table></figure>

<p><strong>【3】Redis 主/从复制注意点：</strong></p>
<p>1）、主/从节点应启用持久化：master 和 slave 中应启用持久化。当由于性能要求不能启用持久化时，应配置实例避免自动重启，因为主节点未持久化又重启时，内存数据为空，会导致从节点同步主节点空数据。<br> 2）、从节点应配置只读属性：主从复制中，从节点应配置只读属性[replica-read-only yes]。<br> 3）、从节点应配置对主节点的验证：主节点通过 requirepass 配置了密码时，从节点应使用[masterauth <password>]配置对主节点的访问密码。<br> 4）、主节点配置写查询接收条件：为了尽量保证主从一致性，主节点应配置当至少有 N 个 slave，并且滞后小于 M 秒时，才接收客户端写入命令[min-slaves-to-write &lt;slave 数量&gt; min-slaves-max-lag &lt;秒数&gt;]</password></p>
<h3 id="五、主从复制常用3招"><a href="#五、主从复制常用3招" class="headerlink" title="五、主从复制常用3招"></a><strong>五、主从复制常用3招</strong></h3><ol>
<li>一主二仆： 一个 Master 两个 Slave； </li>
<li>薪火相传：上一个 Slave 可以是下一个 Slave 的 Master，Slave 同样可以接收其他 Slaves 的连接和同步请求，那么该 Slave 作为了链条中下一个的 Master，可以有效减轻 Master 的写压力。中途变更转向会清除之前的数据，重新建立拷贝最新的slaveof 新主库IP 新主库端口；</li>
<li>反客为主：SLAVEOF NO ONE。使当前数据库停止与其他数据库的同步，转成主数据库 </li>
</ol>
<h3 id="六、主从复制原理"><a href="#六、主从复制原理" class="headerlink" title="六、主从复制原理"></a><strong>六、主从复制原理</strong></h3><p> 【1】slave 启动成功连接到 master 后会发送一个 sync 命令。 </p>
<p> 【2】Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件到 slave，以完成一次完全同步。 </p>
<p> 【3】全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。 </p>
<p> 【4】增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave，完成同步。 </p>
<p> 【5】但是只要是重新连接 master，一次完全同步（全量复制)将被自动执行。 </p>
<p> <strong>复制的缺点：</strong>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。 </p>
<h2 id="二十、Redis-的线程模型是什么"><a href="#二十、Redis-的线程模型是什么" class="headerlink" title="二十、Redis 的线程模型是什么"></a><strong>二十、Redis 的线程模型是什么</strong></h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a><strong>一、概述</strong></h3><p>【1】、Redis 是基于 Reactor 模式开发的网络事件处理器：这个处理器被称为文件事件处理器（file event handler），这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型：</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）机制监听多个套接字 Socket，根据 Socket 上的事件来选择对应的事件处理器进行处理。</li>
<li>当被监听的套接字准备好执行连接<strong>应答（accept）、读取（read）、写入（write）、关闭（close）</strong>等操作时。与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>【2】、虽然文件事件处理器以单线程的方式运行，但其使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
<h3 id="二、文件事件处理器的结构"><a href="#二、文件事件处理器的结构" class="headerlink" title="二、文件事件处理器的结构"></a><strong>二、文件事件处理器的结构</strong></h3><p> 【1】、文件事件处理器的结构包含 4 个部分：</p>
<p>  ● 多个 socket</p>
<p>  ● IO 多路复用程序</p>
<p>  ● 文件事件分派器</p>
<p>  ● 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） </p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache10.png" alt></p>
<p>【2】、多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字。<strong>当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字，</strong> 如图：<br> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache11.png" alt></p>
<p> 文件事件分派器接收 I/O 多路复用程序传来的套接字， 并根据套接字产生的事件的类型， 调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器， 这些处理器是一个个函数， 它们定义了某个事件发生时， 服务器应该执行的动作。 </p>
<p>【3】、<strong>I/O 多路复用程序的实现</strong>：Redis 的 I/O 多路复用程序的所有功能都是通过包装常见的select 、 epoll 、 evport 和 kqueue 这些 I/O 多路复用函数库来实现的， 每个 I/O 多路复用函数库在 Redis 源码中都对应一个单独的文件， 比如 ae_select.c 、 ae_epoll.c 、 ae_kqueue.c ， 诸如此类。因为 Redis 为每个 I/O 多路复用函数库都实现了相同的 API ， 所以 I/O 多路复用程序的底层实现是可以互换的， 如下图所示：</p>
<p> <img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache12.png" alt></p>
<p> Redis 在 I/O 多路复用程序的实现源码中用 <code>#include</code> 宏定义了相应的规则， 程序会在编译时自动选择系统中性能最高的 I/O 多路复用函数库来作为 Redis 的 I/O 多路复用程序的底层实现： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 包括此系统支持的最佳复用层</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下应按性能降序排列。 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_evport.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_epoll.c"</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_kqueue.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ae_select.c"</span></span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>【4】、<strong>事件的类型</strong>：I/O 多路复用程序可以监听多个套接字的 ae.h/AE_READABLE 事件和 ae.h/AE_WRITABLE 事件， 这两类事件和套接字操作之间的对应关系如下：<br>   ■  当套接字变得可读时（客户端对套接字执行 write 操作，或者执行 close 操作）， 或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行 connect 操作）， 套接字产生 AE_READABLE 事件。<br>   ■  当套接字变得可写时（客户端对套接字执行 read 操作）， 套接字产生 AE_WRITABLE 事件。</p>
<p><strong>I/O 多路复用程序允许服务器同时监听套接字的 AE_READABLE 事件和 AE_WRITABLE 事件， 如果一个套接字同时产生了这两种事件， 那么文件事件分派器会优先处理 AE_READABLE 事件， 等到 AE_READABLE 事件处理完之后， 才处理 AE_WRITABLE 事件。这也就是说， 如果一个套接字又可读又可写的话， 那么服务器将先读套接字， 后写套接字。</strong><br> 【5】、API：ae.c/aeCreateFileEvent 函数接受一个套接字描述符、 一个事件类型、 以及一个事件处理器作为参数， 将给定套接字的给定事件加入到 I/O 多路复用程序的监听范围之内， 并对事件和事件处理器进行关联。</p>
<p>ae.c/aeDeleteFileEvent 函数接受一个套接字描述符和一个监听事件类型作为参数， 让 I/O 多路复用程序取消对给定套接字的给定事件的监听， 并取消事件和事件处理器之间的关联。</p>
<p>ae.c/aeGetFileEvents 函数接受一个套接字描述符， 返回该套接字正在被监听的事件类型：</p>
<p>如果套接字没有任何事件被监听， 那么函数返回 AE_NONE 。<br>如果套接字的读事件正在被监听， 那么函数返回 AE_READABLE 。<br>如果套接字的写事件正在被监听， 那么函数返回 AE_WRITABLE 。<br>如果套接字的读事件和写事件正在被监听， 那么函数返回 AE_READABLE | AE_WRITABLE 。<br>ae.c/aeWait 函数接受一个套接字描述符、一个事件类型和一个毫秒数为参数， 在给定的时间内阻塞并等待套接字的给定类型事件产生， 当事件成功产生， 或者等待超时之后， 函数返回。</p>
<p>ae.c/aeApiPoll 函数接受一个 sys/time.h/struct timeval 结构为参数， 并在指定的时间內， 阻塞并等待所有被 aeCreateFileEvent 函数设置为监听状态的套接字产生文件事件， 当有至少一个事件产生， 或者等待超时后， 函数返回。</p>
<p>ae.c/aeProcessEvents 函数是文件事件分派器， 它先调用 aeApiPoll 函数来等待事件产生， 然后遍历所有已产生的事件， 并调用相应的事件处理器来处理这些事件。</p>
<p>ae.c/aeGetApiName 函数返回 I/O 多路复用程序底层所使用的 I/O 多路复用函数库的名称： 返回 “epoll” 表示底层为 epoll 函数库， 返回”select” 表示底层为 select 函数库， 诸如此类。</p>
<p> 【6】、<strong>文件事件的处理器</strong>：Redis 为文件事件编写了多个处理器， 这些事件处理器分别用于实现不同的网络通讯需求， 比如：</p>
<p>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联连接应答处理器。</p>
<p>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联命令请求处理器。</p>
<p>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联命令回复处理器。</p>
<p>当主服务器和从服务器进行复制操作时， 主从服务器都需要关联特别为复制功能编写的复制处理器。</p>
<p> <strong>在这些事件处理器里面， 服务器最常用的要数与客户端进行通信的连接应答处理器、 命令请求处理器和命令回复处理器。</strong> </p>
<p> 【7】、<strong>连接应答处理器</strong>：<code>networking.c/acceptTcpHandler</code> 函数是 Redis 的连接应答处理器， 这个处理器用于对连接服务器监听套接字的客户端进行应答， 具体实现为<code>sys/socket.h/accept</code> 函数的包装。 </p>
<p>当 Redis 服务器进行初始化的时候， 程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来， 当有客户端用sys/socket.h/connect 函数连接服务器监听套接字的时候， 套接字就会产生 AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作， 如图 IMAGE_SERVER_ACCEPT_CONNECT 所示。</p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache13.png" alt></p>
<p>【8】、<strong>命令请求处理器</strong>：networking.c/readQueryFromClient 函数是 Redis 的命令请求处理器， 这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为 unistd.h/read 函数的包装。</p>
<p>当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来， 当客户端向服务器发送命令请求的时候， 套接字就会产生 AE_READABLE 事件， 引发命令请求处理器执行， 并执行相应的套接字读入操作， 如图 IMAGE_SERVER_RECIVE_COMMAND_REQUEST 所示。</p>
<p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache14.png" alt></p>
<p> 当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 <code>AE_WRITABLE</code> 事件之间的关联 </p>
<h3 id="三、客户端与-redis-的一次通信过程"><a href="#三、客户端与-redis-的一次通信过程" class="headerlink" title="三、客户端与 redis 的一次通信过程"></a><strong>三、客户端与 redis 的一次通信过程</strong></h3><p><img src="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/cache15.png" alt></p>
<p>【1】客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p>
<p>【2】假设此时客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p>
<p>【3】如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。这样便完成了一次通信。</p>
<h3 id="四、为啥-redis-单线程模型也能效率这么高"><a href="#四、为啥-redis-单线程模型也能效率这么高" class="headerlink" title="四、为啥 redis 单线程模型也能效率这么高"></a><strong>四、为啥 redis 单线程模型也能效率这么高</strong></h3><p>■ 纯内存操作</p>
<p>■ 核心是基于非阻塞的 IO 多路复用机制</p>
<p>■ 单线程反而避免了多线程的频繁上下文切换问题 </p>
<h2 id="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"><a href="#二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点" class="headerlink" title="二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"></a><strong>二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点</strong></h2><h3 id="为什么要有本地缓存？"><a href="#为什么要有本地缓存？" class="headerlink" title="为什么要有本地缓存？"></a>为什么要有本地缓存？</h3><p>在系统中，有些数据，数据量小，但是访问十分频繁（例如国家标准行政区域数据），针对这种场景，需要将数据搞到应用的本地缓存中，以提升系统的访问效率，减少无谓的数据库访问（数据库访问占用数据库连接，同时网络消耗比较大），但是有一点需要注意，就是缓存的占用空间以及缓存的失效策略。</p>
<h3 id="为什么是本地缓存，而不是分布式的集群缓存？"><a href="#为什么是本地缓存，而不是分布式的集群缓存？" class="headerlink" title="为什么是本地缓存，而不是分布式的集群缓存？"></a>为什么是本地缓存，而不是分布式的集群缓存？</h3><p>​     目前的数据，大多是业务无关的小数据缓存，没有必要搞分布式的集群缓存，目前涉及到订单和商品的数据，会直接走DB进行请求，再加上分布式缓存的构建，集群维护成本比较高，不太适合紧急的业务项目。</p>
<h3 id="本地缓存在那个区域？"><a href="#本地缓存在那个区域？" class="headerlink" title="本地缓存在那个区域？"></a>本地缓存在那个区域？</h3><p>​     目前考虑的是占用了JVM的heap区域，再细化一点的就是heap中的old区，目前的数据量来看，都是一些小数据，加起来没有几百兆，放在heap区域最快最方便。后期如果需要放置在本地缓存的数据大的时候，可以考虑在off-heap区域，但是off-heap区域的话，需要考虑对象的序列化（因为off-heap区域存储的是二进制的数据），另外一个的话就是off-heap的GC问题。其实，如果真的数据量比较大，那其实就可以考虑搞一个集中式的缓存系统，可以是单机，也可以是集群，来承担缓存的作用</p>
<h3 id="本地缓存和分布式缓存的比较："><a href="#本地缓存和分布式缓存的比较：" class="headerlink" title="本地缓存和分布式缓存的比较："></a>本地缓存和分布式缓存的比较：</h3><ul>
<li><p>分布式缓存一致性更好一点，本地缓存 每个实例都有自己的缓存，可能会存在不一致的情况。</p>
</li>
<li><p>本地缓存会占用堆内存，影响垃圾回收、影响系统性能。分布式缓存两大开销会导致其慢于本地缓存，网络延迟和对象序列化</p>
</li>
<li><p>进程内缓存适用于较小且频率可见的访问场景，尤其适用于不变对象，对于较大且不可预见的访问，最好采用分布式缓存。</p>
</li>
</ul>
<h2 id="二十二、本地缓存在并发使用时的注意事项"><a href="#二十二、本地缓存在并发使用时的注意事项" class="headerlink" title="二十二、本地缓存在并发使用时的注意事项"></a><strong>二十二、本地缓存在并发使用时的注意事项</strong></h2><p>使用本地缓存需要注意两个问题：</p>
<p>1 内存管理，及时解除无用对象的引用。防止大量无用对象进入old区，引发full gc。</p>
<p>2 数据同步，如果应用是一个集群，需要保持各台机器的数据一致性。</p>
<p>问题1的解决可以采用<strong>LRU算法</strong>( <strong><code>Least Recently Used</code></strong> )，预先定好缓存大小。达到最大值后，清除最近最少使用的对象。</p>
<p>问题2比较复杂，需要有一个集中的地方控制缓存一致，比如可以采用消息中间件，写时进行异步复制。这种方式成本较大。</p>
</div><div class="post-copyright"><blockquote><p>原文作者: Liu Dong</p><p>原文链接: <a href="https://liudong-code.github.io/2020/03/05/缓存/">https://liudong-code.github.io/2020/03/05/缓存/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"><a href="/liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/">Redis相关</a></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/" class="pre">MySql数据库</a><a href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/" class="next">hashCode和equals</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、什么是缓存？"><span class="toc-text">一、什么是缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、常见的缓存策略有哪些，如何做到缓存-比如redis-与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。"><span class="toc-text">二、常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。"><span class="toc-text">三、如何防止缓存穿透、缓存击穿、缓存雪崩和缓存刷新。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、Redis内存用完会发生什么？"><span class="toc-text">四、Redis内存用完会发生什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、Redis-的-List-结构相关的操作"><span class="toc-text">五、Redis 的 List 结构相关的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、Redis的数据结构都有哪些"><span class="toc-text">六、Redis的数据结构都有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、Redis-的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。"><span class="toc-text">七、Redis 的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、Redis2-和-Redis3-的区别，Redis3-内部通讯机制"><span class="toc-text">八、Redis2 和 Redis3 的区别，Redis3 内部通讯机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、当前-Redis-集群有哪些玩法，各自优缺点，场景。"><span class="toc-text">九、当前 Redis 集群有哪些玩法，各自优缺点，场景。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、Memcache-的原理，哪些数据适合放在缓存中。"><span class="toc-text">十、Memcache 的原理，哪些数据适合放在缓存中。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、Redis-和-Memcached-的内存管理的区别"><span class="toc-text">十一、Redis 和 Memcached 的内存管理的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十二、Redis-的并发竞争问题如何解决，了解-Redis-事务的-CAS-操作吗？"><span class="toc-text">十二、Redis 的并发竞争问题如何解决，了解 Redis 事务的 CAS 操作吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十三、Redis-的选举算法和流程是怎样的"><span class="toc-text">十三、Redis 的选举算法和流程是怎样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十四、Redis-的持久化的机制，AOF和RDB的区别。"><span class="toc-text">十四、Redis 的持久化的机制，AOF和RDB的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十五、缓存预热"><span class="toc-text">十五、缓存预热</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十六、缓存热备"><span class="toc-text">十六、缓存热备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十七、Redis-的集群怎么同步的数据的"><span class="toc-text">十七、Redis 的集群怎么同步的数据的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十八、知道哪些-Redis-的优化操作"><span class="toc-text">十八、知道哪些 Redis 的优化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、Linux-操作系统"><span class="toc-text">一、Linux 操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Redis-关键参数"><span class="toc-text">二、Redis 关键参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Redis-性能测试"><span class="toc-text">三、Redis 性能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、查找慢查询语句"><span class="toc-text">四、查找慢查询语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十九、Reids-的主从复制机制原理"><span class="toc-text">十九、Reids 的主从复制机制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、Redis-复制"><span class="toc-text">一、Redis 复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、Redis-主从全量复制"><span class="toc-text">二、Redis 主从全量复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、Redis-主从部分复制"><span class="toc-text">三、Redis 主从部分复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、Redis-主从搭建"><span class="toc-text">四、Redis 主从搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#五、主从复制常用3招"><span class="toc-text">五、主从复制常用3招</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#六、主从复制原理"><span class="toc-text">六、主从复制原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十、Redis-的线程模型是什么"><span class="toc-text">二十、Redis 的线程模型是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、概述"><span class="toc-text">一、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、文件事件处理器的结构"><span class="toc-text">二、文件事件处理器的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、客户端与-redis-的一次通信过程"><span class="toc-text">三、客户端与 redis 的一次通信过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、为啥-redis-单线程模型也能效率这么高"><span class="toc-text">四、为啥 redis 单线程模型也能效率这么高</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点"><span class="toc-text">二十一、如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么要有本地缓存？"><span class="toc-text">为什么要有本地缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么是本地缓存，而不是分布式的集群缓存？"><span class="toc-text">为什么是本地缓存，而不是分布式的集群缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地缓存在那个区域？"><span class="toc-text">本地缓存在那个区域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#本地缓存和分布式缓存的比较："><span class="toc-text">本地缓存和分布式缓存的比较：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二十二、本地缓存在并发使用时的注意事项"><span class="toc-text">二十二、本地缓存在并发使用时的注意事项</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/10/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA/">JVM虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/07/MySql%E6%95%B0%E6%8D%AE%E5%BA%93/">MySql数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/05/%E7%BC%93%E5%AD%98/">缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/hashCode%E5%92%8Cequals/">hashCode和equals</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashSet%E5%86%85%E9%83%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/">HashSet内部是如何工作的</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Java反射机制</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/">Map类</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">数组和链表数据结构描述，各自的时间复杂度</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/">java8的新特性</a></li><li class="post-list-item"><a class="post-list-link" href="/liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/">动态代理与cglib实现的区别</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 15px;">Java基础知识</a> <a href="/liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/" style="font-size: 15px;">IO模型</a> <a href="/liudong-code.github.io/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/" style="font-size: 15px;">Redis相关</a> <a href="/liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/" style="font-size: 15px;">日常随笔</a> <a href="/liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 15px;">设计模式</a> <a href="/liudong-code.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 15px;">数据库</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/liudong-code.github.io/archives/2020/">2020</a><span class="archive-list-count">40</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/liudong-code.github.io/baidusitemap.xml">网站地图</a> |  <a href="/liudong-code.github.io/atom.xml">订阅本站</a> |  <a href="/liudong-code.github.io/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/liudong-code.github.io/." rel="nofollow">Liu Dong.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/liudong-code.github.io/js/search.json.js?v=2.0.5"></script><div id="fullscreen-img" class="hide"><span class="close"></span></div><script type="text/javascript" src="/liudong-code.github.io/js/imgview.js?v=2.0.5" async></script><script type="text/javascript" src="/liudong-code.github.io/js/toctotop.js?v=2.0.5" async></script><link rel="stylesheet" type="text/css" href="/liudong-code.github.io/share/css/share.css"><script type="text/javascript" src="/liudong-code.github.io/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/liudong-code.github.io/share/js/qrcode.js" charset="utf-8"></script></body></html>