{"meta":{"title":"code","subtitle":"码总","description":"JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch","author":"Liu Dong","url":"https://liudong-code.github.io"},"pages":[{"title":"categories","date":"2020-02-20T02:52:59.000Z","updated":"2020-02-20T03:43:51.276Z","comments":true,"path":"categories/index.html","permalink":"https://liudong-code.github.io/categories/index.html","excerpt":"","text":"type: “categories” # 将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类comments: true # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false 这里也有 “—“"}],"posts":[{"title":"final，finally，finalize的区别","slug":"final，finally，finalize的区别","date":"2020-02-27T08:31:46.000Z","updated":"2020-02-27T08:57:27.919Z","comments":true,"path":"2020/02/27/final，finally，finalize的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.简单区别： final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。 2.中等区别： final：java中的关键字，修饰符。 如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。 如果将变量或者方法声明为final，可以保证它们在使用中不被改变. 1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 2)被声明final的方法只能使用，不能重载。 finally：java的一种异常处理机制。 finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。 finalize：Java中的一个方法名。Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 3.详细区别：final定义变量 第一种情况：如果final修饰的是一个基本类型，就表示这个变量被赋予的值是不可变的，即它是个常量；如果final修饰的是一个对象，就表示这个变量被赋予的引用是不可变的这里需要提醒大家注意的是，不可改变的只是这个变量所保存的引用，并不是这个引用所指向的对象。 第二种情况：final的含义与第一种情况相同。实际上对于前两种情况，一种更贴切的表述final的含义的描述，那就是，如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化。初始化的方式以下几种：1.在定义的时候初始化。2.final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。3.静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，不可以在初始化块中初始化。4.final变量还可以在类的构造器中初始化，但是静态final变量不可以。 定义方法当final用来定义一个方法时，它表示这个方法不可以被子类重写，但是并不影响它被子类继承。定义类​ final类不允许被继承，编译器在处理时把它的所方法都当作final的，因此final类比普通类拥更高的效率。而由关键字abstract定义的抽象类含必须由继承自它的子类重载实现的抽象方法，因此无法同时用final和abstract来修饰同一个类。同样的道理，final也不能用来修饰接口。 final的类的所方法都不能被重写，但这并不表示final的类的属性（变量值也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰 finally语句​ finally只能用在try/catch语句中并且附带着一个语句块，表示这段语句最终总是被执行 。 finalize方法​ 它是一个方法，属于java.lang.Object类，它的定义如下： 1protected void finalize()throws Throwable&#123;&#125; ​ 众所周知，finalize()方法是GC （garbagecollector）运行机制的一部分,在此我们只说说finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception），GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"进程和线程的区别","slug":"进程和线程的区别","date":"2020-02-27T08:04:55.000Z","updated":"2020-02-27T08:22:29.252Z","comments":true,"path":"2020/02/27/进程和线程的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"概念《系统架构师》一书中给出的定义是： 进程（process）是资源分配和独立运行的基本单位。研究操作系统的进程，实质是研究系统中诸多进程之间的并发特性以及进程之间的相互制约性。 线程是进程中的一个实体，是被系统独立分配和调度的基本操作单位。具有就绪、运行、阻塞三种状态。 一个进程有若干个线程，线程只拥有一些运行中必不可少的资源，它可与同一个进程的其他线程共享进程所拥有的的全部资源。线程可创建另外一个线程，同一个进程中的多个线程可并发执行。 Linux中的概念 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。 123456789101112131415# -*- coding:utf-8 -*-import osprint('当前进程:%s 启动中 ....' % os.getpid())pid = os.fork()if pid == 0: print('子进程:%s,父进程是:%s' % (os.getpid(), os.getppid()))else: print('进程:%s 创建了子进程:%s' % (os.getpid(),pid )) 输出结果：当前进程:27223 启动中 ....进程:27223 创建了子进程:27224子进程:27224,父进程是:27223 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 区别和优劣 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 参考书籍《Unix网络编程》","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"泛型中extends和super的区别","slug":"泛型中extends和super的区别","date":"2020-02-27T07:35:59.000Z","updated":"2020-02-27T07:58:34.700Z","comments":true,"path":"2020/02/27/泛型中extends和super的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"释义：在非泛型中： extends：让一个类继承另外一个类； super：指向父类对象的引用； 在泛型中： extends也成为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。 super也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。 看如下代码： 123456789101112131415161718192021222324252627public class Food &#123;&#125;public class Fruit extends Food &#123;&#125;public class Apple extends Fruit &#123;&#125;public class Banana extends Fruit&#123;&#125;public class GenericTest &#123;public void testExtends(List&lt;? extends Fruit&gt; list)&#123; //报错,extends为上界通配符,只能取值,不能放. //因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错 //list.add(new Apple()); //可以正常获取 Fruit fruit = list.get(1);&#125;public void testSuper(List&lt;? super Fruit&gt; list)&#123; //super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲， //无法确定Fruit的父类是否只有Food一个(Object是超级父类) //因此放入Food的实例编译不通过 list.add(new Apple()); // list.add(new Food()); Object object = list.get(1); &#125;&#125; 在testExtends方法中，因为泛型中用的是extends，在向list中存放元素的时候，我们并不能确定List中的元素的具体类型，即可能是Apple也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。 理解了extends之后，再看super就很容易理解了，即我们不能确定testSuper方法的参数中的泛型是Fruit的哪个父类，因此在调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。 总结：在使用泛型时，存取元素时用super,获取元素时，用extends。 扩展： 通配符 ? 使用 在泛型中的通配符就是一个问号，标准叫法是无界通配符，它一般使用在参数或变量的声明上 1234567891011121314 // 在参数中使用无界通配符 public static void test(List&lt;?&gt; list) &#123; Object o = list.get(1);&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); // 在变量声明中使用无界通配符 List&lt;?&gt; list2 = list1; test(list1); test(list2);&#125; 泛型中使用无界通配符，表示泛型可以是任意具体的类型，没有限制（基本数据类型除外，基本数据类型不能用作泛型，可以使用基本数据类型的包装类）； 所以无界通配符给人的感觉就和原生的类型没什么区别，比如就上面这段代码，使用List&lt;?&gt;，和直接使用List，好像是一样的；但是实际上还是有一些区别的，比如看下面这段代码: 1234567891011121314151617181920212223 // 在参数中使用无界通配符 public static void test1(List&lt;?&gt; list) &#123; // 均编译错误，因为使用了无界通配符，编译器无法确定具体是什么类型 // list.add(1111); // list.add(\"aaa\"); // list.add(new Object());&#125;// 在参数中使用原生Listpublic static void test2(List list) &#123; // 编译通过，不加泛型时，编译器默认为Object类型 list.add(1111); list.add(\"aaa\"); list.add(new Object());&#125;public static void main(String[] args) &#123; // 声明两个泛型明确的list集合 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 调用使用了&lt;？&gt;的方法 test1(list1); test2(list2);&#125; List：表示可以存储任意Object类型的集合； List：表示一个存储某种特定类型的List集合，但是不知道这种特定类型是什么；","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"String，Stringbuffer，StringBuilder的区别","slug":"String，Stringbuffer，StringBuilder的区别","date":"2020-02-27T07:16:10.000Z","updated":"2020-02-27T07:19:07.092Z","comments":true,"path":"2020/02/27/String，Stringbuffer，StringBuilder的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"String string类是不可变的：创建一个String对象之后，任何对这个对象的改变都会引起一个新的String对象生成。 123String str =\"abc\";str = str +\"def\";//这一步jvm会再次创建一个String对象 第二次其实jvm又生成了一个String类，而不是直接覆盖原来的”abc”，因此我们说String类是不可改变类。这一种特性会带来一个问题，每次拼接都要创建都要创建一次对象，当我们要拼接大量字符串的时候，效率会变得非常非常慢。 StringBuffer StringBuffer 不同于String的是，stringbuffer 是可变的， 123StringBuffer sb =new StringBuffer(\"abc\"); sb.append(\"efg\");//并没有创建一个新的对象 这里第二步并没有产生一个新的对象，而是在原来的基础上追加字符串，这种方式在拼接字符串的时候效率肯定比String要高得多。 StringBuilderStringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 total:1.如果要操作少量的数据用 String 2.单线程操作字符串缓冲区下操作大量数据用StringBuilder 3.多线程操作字符串缓冲区下操作大量数据用StringBuffer","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java中的可变对象与不可变对象","slug":"Java中的可变对象与不可变对象","date":"2020-02-27T06:59:24.000Z","updated":"2020-02-27T07:09:51.291Z","comments":true,"path":"2020/02/27/Java中的可变对象与不可变对象/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"不可变对象 （Immutable Objects）​ 对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。 ​ 不可变对象的类即为不可变类(Immutable Class)。JAVA平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等 . 可变对象(Mutable Objects)​ 相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。 编写不可变类 1.确保类不能被继承：将类声明为final, 或者使用静态工厂并声明构造器为private 使用private和final修饰符来修饰该类的属性 如果成员属性为可变对象属性，不要使这些对象改变： 1）不要提供更改可变对象的方法 2）不要共享对可变对象的引用，不要存储传给构造器的外部可变对象的引用。因为引用可变对象的成员变量和外部可变对象的引用指向同一块内存地址，用户可以在不可变类之外通过修改可变对象的值 为了保证内部的值不被修改，可以采用深度拷贝的方法来复制一个对象并传入副本的引用来确保类的不可变 1234567891011public final class MyImmutableDemo &#123; private final int[] myArray; public MyImmutableDemo(int[] array) &#123; this.myArray = array.clone(); &#125; &#125; C. 不要提供任何可以修改对象状态的方法（不仅仅是set方法, 还有任何其它可以改变状态的方法） 不可变对象的优缺点优点* 构造、测试和使用都很简单 * 不可变对象是线程安全的，在线程之间可以相互共享，不需要利用特殊机制来保证同步问题，因为对象的值无法改变。可以降低并发错误的可能性，因为不需要用一些锁机制等保证内存一致性问题也减少了同步开销。 * 不可变对象可以被重复使用，可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。可以使用静态工厂方法来提供类似于valueOf()这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。 缺点 * 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象,制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，会创造很多的垃圾，给垃圾收集带来很大的麻烦 参考：https://blog.csdn.net/bupa900318/article/details/80696785","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2020-02-27T06:06:01.000Z","updated":"2020-02-27T07:43:41.584Z","comments":true,"path":"2020/02/27/接口和抽象类的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"抽象类1abstract ​ 抽象类必须用abstract 修饰，子类必须实现抽象类中的抽象方法，如果有方法未实现，那么子类的该方法也要用abstract 修饰。 ​ 默认的权限修饰符是：public，也可以是procted.如果是private的话，子类无法继承。 ​ 抽象类无法创建对象。 接口1interface ​ 接口中的变量隐式的使用Public static final 修饰，也要给出初始值 ​ 接口中的方法隐式的使用public abstract 修饰，只能是public 修饰。 ​ 接口中的方法默认的不能有实现（JDK1.8可以有默认实现）。 抽象类和接口的区别 抽象类只能继承一次，但是可以有多个接口。 继承于抽象类或者接口的类，必须实现其中的所有方法，抽象类中的为实现的抽象方法，子类也需要定义为抽象类。 抽象类可以有非抽象方法。 接口的变量必须由public static final 修饰，并给出初始值，所以其实现类不能重新定义，也不能改变其值。 接口的方法默认是public abstract ，不能是static，抽象类中可以有static方法。 接口的方法也不允许子类覆写。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"抽象类的意义","slug":"抽象类的意义","date":"2020-02-27T05:53:43.000Z","updated":"2020-02-27T06:07:43.236Z","comments":true,"path":"2020/02/27/抽象类的意义/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89/","excerpt":"","text":"抽象类的意义最主要的：对代码的维护和重用。 关键字 1abstract 1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护 2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。 ​ 实际写代码的过程中，如果想要对某一个接口进行默认实现，并且不希望在该实现类 上创建实例，那么抽象类是一个不错地选择。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"int与Integer的区别","slug":"int与Integer的区别","date":"2020-02-27T05:13:32.000Z","updated":"2020-02-27T05:34:38.327Z","comments":true,"path":"2020/02/27/int与Integer的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/int%E4%B8%8EInteger%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"int1int 是java的基本数据类型。 Integer1Integer 继承了Object类，是对象类型，是 int 的包装类。 int 与 Integer 的区别1,值的储存​ int储存在栈中 ​ Integer对象的引用储存在栈中，对象的数据储存在堆中。 2,初始化​ int初始值是0 ​ Integer的初始值是null 3,传参​ int是值传递 ​ Integer是引用传递，引用不可改变但是引用指向堆空间地址的值是可以改变的。 4,泛型支持​ 泛型不支持int，但是支持Integer。 5,运算​ int 可以直接做运算，是类的特性。​ Integer 的对象可以调用该类的方法，但是在拆箱之前不能进行运算，需要转化为基本类型int。 相同值下的 int 和 Integer 的比较结果​ 1,两个通过new生成的变量，结果为false。​ 2,int 和 Integer 的值比较，若两者的值相等，则为true。​ （注意：在比较时，Integer会自动拆箱为int类型，然后再做比较。）​ 3,new 生成的Integer变量 和 非new 生成的Integer变量比较，，结果为false。​ （注意：new 生成的Integer变量的值在堆空间中，非new 生成的Integer变量的值在在常量池中。）​ （注意：非new生成的Integer变量，会先判断常量池中是否有该对象，若有则共享，若无则在常量池中放入 该对象；也叫享元模式，后面再说。）​ 4,两个非new 生成的Integer对象比较，则结果为true。​ （注意：此处需要一个前提：值的范围在 -128 ~ 127 之间。​ 涉及到java对 int 与 Integer 的自动装箱和拆箱的一种模式：享元模式—flyweight，为了加强对简单数字的重 复利用。​ 在赋值时，其实是执行了Integer的valueOf()方法。​ 当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在 缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。​ 当值超出此范围，会在堆中new出一个对象来存储。​ PS：自动装箱与拆箱是在JDK1.5中出现的。 12345678910111213141516public static void main(String[] args) &#123; int a =12; Integer b =12; Integer c = new Integer(12); Integer d=128; Integer e=128; System.out.println(a==b); System.out.println(b==c); System.out.println(d==e); &#125;truefalsefalse ​ 5,内部类IntegerCache​ 通过此类可以缓存简单数字。​ 缓存的数大小可以由 -XX：AutoBoxCacheMax = 控制。​ jvm初始化时，java.lang.Integer.Integ","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java==和equals和hashCode的区别","slug":"Java中==和equals和hashCode的区别","date":"2020-02-27T02:00:49.000Z","updated":"2020-02-27T08:54:31.546Z","comments":true,"path":"2020/02/27/Java中==和equals和hashCode的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD==%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Java中==和equals和hashCode的区别1，==1, 基础类型：byte,short,char,int,double,boolean,float ​ 他们之间用“==”，比较的是他们的值 2, 引用类型（类，接口，数组） ​ 使用“==”进行比较的时候，比较的是内存地址 12345678910111213141516public static void main(String[] args) &#123; String str1 = new String(\"str\"); String str2 = new String(\"str\"); System.out.println(\"str1==str2:\" + (str1 == str2)); String str3=\"str\"; String str4=\"str\"; System.out.println(str3 == str4); System.out.println(System.identityHashCode(str1)); System.out.println(System.identityHashCode(str2)); System.out.println(System.identityHashCode(str3)); System.out.println(System.identityHashCode(str4)); &#125; 结果为 str1==str2:falsetrue323247493111501236338603633860 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见’==’是对栈中的值进行比较的。如果要比较堆 中对象的内容是否相同，那么就要重写equals方法了。 但是这行代码，128！=128，a!=b 123456Integer a1 = 127;Integer b1 = 127;Integer a = 128;Integer b = 128;System.out.println(a1==b1);System.out.println(a==b); 结果 true false 去看Integer的源码可以明白，是这段源码 12345678910111213141516171819202122232425262728293031323334private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; Integer对于 对于-128到127之间的数，会进行缓存 。 2，equals() 1,默认没有重新的情况下，都调用的是Objects 的equals（）的方法，源码如下： 1public boolean equals(Object obj) &#123; return (this == obj);&#125; ​ 可以看到是Objects中的equal（）方法和== 是等同的。 2，日常的代码中会覆盖equal() 方法，下面是string 类 重写的equal（）方法 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; ​ 逻辑很明显： ​ 内存地址相同，直接返回true ​ 比较对象是String类型，直接返回false ​ a和b长度不同，直接返回false ​ 逐个字符比较，有不同就返回false equal重写注意的五个原则​ 1 自反性：对任意引用值X，x.equals(x)的返回值一定为true.​ 2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;​ 3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true​ 4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变​ 5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 3，hashCodeObjects给出的hashCode（）的原生代码是： 1public native int hashCode(); 返回时的一个int 类型的数值。 下面是引用摘抄的 ======================================================================================= hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。 散列函数,散列算法,哈希函数。是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。好的散列函数在输入域中很少出现散列冲突。 ====================================================================================== hashCode的作用想要明白，必须要先知道Java中的集合。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。 这样一来，当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 4、eqauls方法和hashCode方法关系Java对于eqauls方法和hashCode方法是这样规定的： (1)同一对象上多次调用hashCode()方法，总是返回相同的整型值。 (2)如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。(3)如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 (4)a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 (5)a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。2、如果两个对象不equals，他们的hashcode有可能相等。3、如果两个对象hashcode相等，他们不一定equals。4、如果两个对象hashcode不相等，他们一定不equals。 关于这两个方法的重要规范：规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 5、为什么覆盖equals时总要覆盖hashCode 一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 2.如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 3.如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 6、总结：1、equals方法用于比较对象的内容是否相等（覆盖以后） 2、hashcode方法只有在集合中用到 3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。 4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 以上从第四点以后转载至博客：https://blog.csdn.net/hla199106/article/details/46907725","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"写于博客之始","slug":"写于博客之始","date":"2020-02-26T10:00:08.000Z","updated":"2020-02-27T07:36:23.335Z","comments":true,"path":"2020/02/26/写于博客之始/","link":"","permalink":"https://liudong-code.github.io/2020/02/26/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%A7%8B/","excerpt":"","text":"​ 重新整理了之前的旧的博客，发现有部分博客有老东家的Code，想起来之前有同事因无意中泄露了公司的淘宝三段码，而受到处罚，索性就新搞了一个新的博客 地址，这几天正好因为疫情在家里面，找工作也不是很好找，就把之前的整理的东西全部搞过来。新的博客只弄了主题，其他的细节都还没整，想的是尽快的把日常干货先给弄上来。嗯，就这些吧！ ​","categories":[],"tags":[{"name":"日常随笔","slug":"日常随笔","permalink":"https://liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"keywords":[]}]}