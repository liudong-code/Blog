{"meta":{"title":"code","subtitle":"码总","description":"JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch","author":"Liu Dong","url":"https://liudong-code.github.io"},"pages":[{"title":"categories","date":"2020-02-20T02:52:59.000Z","updated":"2020-02-20T03:43:51.276Z","comments":true,"path":"categories/index.html","permalink":"https://liudong-code.github.io/categories/index.html","excerpt":"","text":"type: “categories” # 将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类comments: true # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false 这里也有 “—“"}],"posts":[{"title":"Map类","slug":"HashMap类","date":"2020-03-04T06:02:37.000Z","updated":"2020-03-04T07:21:15.247Z","comments":true,"path":"2020/03/04/HashMap类/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/HashMap%E7%B1%BB/","excerpt":"","text":"摘要HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。 简介Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示： 下面针对各个实现类的特点做一些说明： (1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 (2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 (3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。 通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。 内部实现 搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。 存储结构-字段 从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。 这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？ (1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //用来定位数组索引位置 final K key; V value; Node&lt;K,V&gt; next; //链表的下一个node Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125; public final K getKey()&#123; ... &#125; public final V getValue() &#123; ... &#125; public final String toString() &#123; ... &#125; public final int hashCode() &#123; ... &#125; public final V setValue(V newValue) &#123; ... &#125; public final boolean equals(Object o) &#123; ... &#125;&#125; Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。 (2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码： 1map.put(\"美团\",\"小美\"); 系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。 如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。 在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下： 1234int threshold; // 所能容纳的key-value对极限 final float loadFactor; // 负载因子 int modCount; int size; 首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。 size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。 在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。 这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考http://blog.csdn.net/v_july_v/article/details/6105630。 功能实现-方法 HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。 1. 确定哈希桶数组索引位置 不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二): 1234567891011方法一：static final int hash(Object key) &#123; //jdk1.8 &amp; jdk1.7 int h; // h = key.hashCode() 为第一步 取hashCode值 // h ^ (h &gt;&gt;&gt; 16) 为第二步 高位参与运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;方法二：static int indexFor(int h, int length) &#123; //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的 return h &amp; (length-1); //第三步 取模运算&#125; 这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。 对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。 这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。 下面举例说明下，n为table的长度。 2. 分析HashMap的put方法 HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。 ①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容； ②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③； ③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals； ④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤； ⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可； ⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。 JDK1.8HashMap的put方法源码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 步骤①：tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 步骤②：计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 步骤③：节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 步骤④：判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 步骤⑤：该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key,value,null); //链表长度大于8转换为红黑树进行处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 步骤⑥：超过最大容量 就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 3. 扩容机制 扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。 我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。 12345678910111213void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125; 这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。 1234567891011121314151617void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。 下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\"，\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 线程安全性 在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)： 1234567891011121314151617181920public class HashMapInfiniteLoop &#123; private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f); public static void main(String[] args) &#123; map.put(5， \"C\"); new Thread(\"Thread1\") &#123; public void run() &#123; map.put(7, \"B\"); System.out.println(map); &#125;; &#125;.start(); new Thread(\"Thread2\") &#123; public void run() &#123; map.put(3, \"A); System.out.println(map); &#125;; &#125;.start(); &#125; &#125; 其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。 通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。 注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。 线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。 e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。 于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。 JDK1.8与JDK1.7的性能对比 HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。 Hash较均匀的情况为了便于测试，我们先写一个类Key，如下： 123456789101112131415161718192021222324252627class Key implements Comparable&lt;Key&gt; &#123; private final int value; Key(int value) &#123; this.value = value; &#125; @Override public int compareTo(Key o) &#123; return Integer.compare(this.value, o.value); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Key key = (Key) o; return value == key.value; &#125; @Override public int hashCode() &#123; return value; &#125;&#125; 这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下： 123456789101112131415public class Keys &#123; public static final int MAX_KEY = 10_000_000; private static final Key[] KEYS_CACHE = new Key[MAX_KEY]; static &#123; for (int i = 0; i &lt; MAX_KEY; ++i) &#123; KEYS_CACHE[i] = new Key(i); &#125; &#125; public static Key of(int value) &#123; return KEYS_CACHE[value]; &#125;&#125; 现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下： 1234567891011121314151617181920static void test(int mapSize) &#123; HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize); for (int i = 0; i &lt; mapSize; ++i) &#123; map.put(Keys.of(i), i); &#125; long beginTime = System.nanoTime(); //获取纳秒 for (int i = 0; i &lt; mapSize; i++) &#123; map.get(Keys.of(i)); &#125; long endTime = System.nanoTime(); System.out.println(endTime - beginTime); &#125; public static void main(String[] args) &#123; for(int i=10;i&lt;= 1000 0000;i*= 10)&#123; test(i); &#125; &#125; 在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下： 通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。 Hash极不均匀的情况假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下： 123456789class Key implements Comparable&lt;Key&gt; &#123; //... @Override public int hashCode() &#123; return 1; &#125;&#125; 仍然执行main方法，得出的结果如下表所示： 从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。 测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。 小结(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 (2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 (3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 (4) JDK1.8引入红黑树大程度优化了HashMap的性能。 (5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。 原文链接：https://zhuanlan.zhihu.com/p/21673805","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"数组和链表数据结构描述，各自的时间复杂度","slug":"数组和链表数据结构描述，各自的时间复杂度","date":"2020-03-04T05:55:00.000Z","updated":"2020-03-04T05:57:03.450Z","comments":true,"path":"2020/03/04/数组和链表数据结构描述，各自的时间复杂度/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"两种数据结构都是线性表，在排序和查找等算法中都有广泛的应用一、各自的特点：数组：数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中任何元素。但是如果要在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样的道理，如果想删除一个元素，同样需要移动大量元素去填掉被移动的元素。如果应用需要快速访问数据，很少或不插入和删除元素，就应该用数组。 链表：链表恰好相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。比如：上一个元素有个指针指到下一个元素，以此类推，直到最后一个元素。如果要访问链表中一个元素，需要从第一个元素开始，一直找到需要的元素位置。但是增加和删除一个元素对于链表数据结构就非常简单了，只要修改元素中的指针就可以了。如果应用需要经常插入和删除元素你就需要用链表数据结构了。 二、数组和链表的区别：1、从逻辑结构角度来看： 数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。（数组中插入、删除数据项时，需要移动其它数据项）2、数组元素在栈区，链表元素在堆区； 3、从内存存储角度来看： (静态)数组从栈中分配空间, 对于程序员方便快速,但自由度小。链表从堆中分配空间, 自由度大但申请管理比较麻烦。数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"java8的新特性","slug":"java8的新特性","date":"2020-03-04T04:33:02.000Z","updated":"2020-03-04T05:52:32.381Z","comments":true,"path":"2020/03/04/java8的新特性/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/java8%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"一、接口的默认方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 123456interface Formula &#123; default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678910Formula formula = new Formula() &#123; @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;；formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。 译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。 二、Lambda 表达式 首先看看在老版本的Java中是如何排列字符串的： 12345678List&lt;String&gt; names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： 123 Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短： 1Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： 1Collections.sort(names, (a, b) -&gt; b.compareTo(a)); Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来： 三、函数式接口Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。 我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。 1234567 @FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。 译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。 四、方法与构造函数引用 前一节中的代码还可以通过静态方法引用来表示： 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 123converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 123456789101112class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来我们指定一个用来创建Person对象的对象工厂接口： 123 interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(\"Peter\", \"Parker\"); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 五、Lambda 作用域 在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。 六、访问局部变量 我们可以直接在lambda表达式中访问外层的局部变量： 12345final int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： 12345int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： 12345int num = 1;Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);num = 3; 在lambda表达式中试图修改num同样是不允许的。 七、访问对象字段与静态变量 和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的： 1234567891011121314151617class Lambda4 &#123; static int outerStaticNum; int outerNum; void testScopes() &#123; Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123; outerNum = 23; return String.valueOf(from); &#125;; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123; outerStaticNum = 72; return String.valueOf(from); &#125;; &#125;&#125; 八、访问接口的默认方法 还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。Lambda表达式中是无法访问到默认方法的，以下代码将无法编译： 12Formula formula = (a) -&gt; sqrt( a * 100);Built-in Functional Interfaces JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 Predicate接口 Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）： 12345678910Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;predicate.test(\"foo\"); // truepredicate.negate().test(\"foo\"); // falsePredicate&lt;Boolean&gt; nonNull = Objects::nonNull;Predicate&lt;Boolean&gt; isNull = Objects::isNull;Predicate&lt;String&gt; isEmpty = String::isEmpty;Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); Function 接口 Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）： 12345Function&lt;String, Integer&gt; toInteger = Integer::valueOf;Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); backToString.apply(\"123\"); // \"123\" Supplier 接口 Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数 12Supplier&lt;Person&gt; personSupplier = Person::new;personSupplier.get(); // new Person Consumer 接口 Consumer 接口表示执行在单个参数上的操作。 12Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(\"Hello, \" + p.firstName);greeter.accept(new Person(\"Luke\", \"Skywalker\")); Comparator 接口1234567Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);Person p1 = new Person(\"John\", \"Doe\");Person p2 = new Person(\"Alice\", \"Wonderland\");comparator.compare(p1, p2); // &gt; 0comparator.reversed().compare(p1, p2); // &lt; 0 Optional 接口Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么： Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。 1234567Optional&lt;String&gt; optional = Optional.of(\"bam\");optional.isPresent(); // trueoptional.get(); // \"bam\"optional.orElse(\"fallback\"); // \"bam\"optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // \"b\" Stream 接口java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。 首先看看Stream是怎么用，首先创建实例代码的用到的数据List： 123456789List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();stringCollection.add(\"ddd2\");stringCollection.add(\"aaa2\");stringCollection.add(\"bbb1\");stringCollection.add(\"aaa1\");stringCollection.add(\"bbb3\");stringCollection.add(\"ccc\");stringCollection.add(\"bbb2\");stringCollection.add(\"ddd1\"); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： Filter 过滤 过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 123456stringCollection .stream() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa2\", \"aaa1\" Sort 排序 排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。 123456stringCollection .stream() .sorted() .filter((s) -&gt; s.startsWith(\"a\")) .forEach(System.out::println); // \"aaa1\", \"aaa2\" 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： 12 System.out.println(stringCollection);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map 映射 中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 123456stringCollection .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println); // \"DDD2\", \"DDD1\", \"CCC\", \"BBB3\", \"BBB2\", \"AAA2\", \"AAA1\" Match 匹配 Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值 1234567891011121314151617181920boolean anyStartsWithA = stringCollection .stream() .anyMatch((s) -&gt; s.startsWith(\"a\")); System.out.println(anyStartsWithA); // trueboolean allStartsWithA = stringCollection .stream() .allMatch((s) -&gt; s.startsWith(\"a\"));System.out.println(allStartsWithA); // falseboolean noneStartsWithZ = stringCollection .stream() .noneMatch((s) -&gt; s.startsWith(\"z\"));System.out.println(noneStartsWithZ); // true Count 计数 计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。 1234567long startsWithB = stringCollection .stream() .filter((s) -&gt; s.startsWith(\"b\")) .count(); System.out.println(startsWithB); // 3 Reduce 规约 这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的： 123456789Optional&lt;String&gt; reduced = stringCollection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + \"#\" + s2);reduced.ifPresent(System.out::println);// \"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2\" 并行Streams 前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 下面的例子展示了是如何通过并行Stream来提升性能： 首先我们创建一个没有重复元素的大表： 123456 int max = 1000000;List&lt;String&gt; values = new ArrayList&lt;&gt;(max);for (int i = 0; i &lt; max; i++) &#123; UUID uuid = UUID.randomUUID(); values.add(uuid.toString());&#125; 然后我们计算一下排序这个Stream要耗时多久， 串行排序： 123456789long t0 = System.nanoTime();long count = values.stream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"sequential sort took: %d ms\", millis)); // 串行耗时: 899 ms 并行排序： 123456789long t0 = System.nanoTime();long count = values.parallelStream().sorted().count();System.out.println(count);long t1 = System.nanoTime();long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);System.out.println(String.format(\"parallel sort took: %d ms\", millis)); // 并行排序耗时: 472 ms上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。 Map 前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。 1234567Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; 10; i++) &#123; map.putIfAbsent(i, \"val\" + i);&#125;map.forEach((id, val) -&gt; System.out.println(val)); 以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。 下面的例子展示了map上的其他有用的函数： 12345678910map.computeIfPresent(3, (num, val) -&gt; val + num);map.computeIfPresent(9, (num, val) -&gt; null);map.containsKey(9); // falsemap.computeIfAbsent(23, num -&gt; \"val\" + num);map.containsKey(23); // truemap.computeIfAbsent(3, num -&gt; \"bam\");map.get(3); 接下来展示如何在Map里删除一个键值全都匹配的项： 1234map.remove(3, \"val3\");map.get(3); // val33 map.remove(3, \"val33\");map.get(3); // null 另外一个有用的方法： 1map.getOrDefault(42, \"not found\"); // not found 对Map的元素做合并也变得很容易了： 1234map.merge(9, \"val9\", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9 map.merge(9, \"concat\", (value, newValue) -&gt; value.concat(newValue));map.get(9); // val9concat Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 九、Date API java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分： Clock 时钟 Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。 123456Clock clock = Clock.systemDefaultZone();long millis = clock.millis(); Instant instant = clock.instant();Date legacyDate = Date.from(instant); // legacy java.util.Date Timezones 时区 在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。 1234567891011System.out.println(ZoneId.getAvailableZoneIds()); // prints all available timezone ids ZoneId zone1 = ZoneId.of(\"Europe/Berlin\");ZoneId zone2 = ZoneId.of(\"Brazil/East\");System.out.println(zone1.getRules());System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=+01:00]// ZoneRules[currentStandardOffset=-03:00] LocalTime 本地时间 LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： 1234567891011LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // falselong hoursBetween = ChronoUnit.HOURS.between(now1, now2);long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);System.out.println(hoursBetween); // -3System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。 1234567891011LocalTime late = LocalTime.of(23, 59, 59);System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN);LocalTime leetTime = LocalTime.parse(\"13:37\", germanFormatter);System.out.println(leetTime); // 13:37 LocalDate 本地日期 LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 12345678LocalDate today = LocalDate.now();LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);LocalDate yesterday = tomorrow.minusDays(2); LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();System.out.println(dayOfWeek); // FRIDAY 从字符串解析一个LocalDate类型和解析LocalTime一样简单： 12345678DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedDate(FormatStyle.MEDIUM) .withLocale(Locale.GERMAN); LocalDate xmas = LocalDate.parse(\"24.12.2014\", germanFormatter);System.out.println(xmas); // 2014-12-24 LocalDateTime 本地日期时间 LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。 LocalDateTime提供了一些能访问具体字段的方法。 12345678910LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);DayOfWeek dayOfWeek = sylvester.getDayOfWeek();System.out.println(dayOfWeek); // WEDNESDAYMonth month = sylvester.getMonth();System.out.println(month); // DECEMBERlong minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date 123456Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant);System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： 12345DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"MMM dd, yyyy - HH:mm\"); LocalDateTime parsed = LocalDateTime.parse(\"Nov 03, 2014 - 07:13\", formatter);String string = formatter.format(parsed);System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。关于时间日期格式的详细信息：http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html 十、Annotation 注解 在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解： 12345678@interface Hints &#123; Hint[] value();&#125; @Repeatable(Hints.class)@interface Hint &#123; String value();&#125; Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法） 12@Hints(&#123;@Hint(\"hint1\"), @Hint(\"hint2\")&#125;)class Person &#123;&#125; 例 2：使用多重注解（新方法） 123@Hint(\"hint1\")@Hint(\"hint2\")class Person &#123;&#125; 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： 12345678Hint hint = Person.class.getAnnotation(Hint.class);System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class);System.out.println(hints1.value().length); // 2Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);System.out.println(hints2.length); // 2 即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。另外Java 8的注解还增加到两种新的target上了： 12@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)@interface MyAnnotation &#123;&#125; 关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"动态代理与cglib实现的区别","slug":"动态代理与cglib实现的区别","date":"2020-03-04T03:54:58.000Z","updated":"2020-03-04T04:06:13.224Z","comments":true,"path":"2020/03/04/动态代理与cglib实现的区别/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8Ecglib%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"JDK动态代理特点 Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷； Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上； Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来。 InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。 总结： JDK动态代理类实现了InvocationHandler接口，重写的invoke方法。 JDK动态代理的基础是反射机制（method.invoke(对象，参数)）Proxy.newProxyInstance() jdk动态代理代码123456789101112131415161718192021222324252627282930313233343536373839 public class JDKProxyFactory implements InvocationHandler &#123; private Object target; public JDKProxyFactory(Object target) &#123; super(); this.target = target; &#125; // 创建代理对象 public Object createProxy() &#123; // 1.得到目标对象的类加载器 ClassLoader classLoader = target.getClass().getClassLoader(); // 2.得到目标对象的实现接口 Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces(); // 3.第三个参数需要一个实现invocationHandler接口的对象 Object newProxyInstance = Proxy.newProxyInstance(classLoader, interfaces, this); return newProxyInstance; &#125; // 第一个参数:代理对象.一般不使用;第二个参数:需要增强的方法;第三个参数:方法中的参数 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"这是增强方法前......\"); Object invoke = method.invoke(target, args); System.out.println(\"这是增强方法后......\"); return invoke; &#125; public static void main(String[] args) &#123; // 1.创建对象 FoodServiceImpl foodService = new FoodServiceImpl(); // 2.创建代理对象 JDKProxyFactory proxy = new JDKProxyFactory(foodService); // 3.调用代理对象的增强方法,得到增强后的对象 FoodService createProxy = (FoodService) proxy.createProxy(); createProxy.makeChicken(); &#125;&#125; cglib动态代理特点​ 原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。 注意:​ jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理。 cglib动态代理代码1234567891011121314151617181920212223242526272829303132333435363738394041 public class CglibProxyFactory implements MethodInterceptor &#123; //得到目标对象 private Object target; //使用构造方法传递目标对象 public CglibProxyFactory(Object target) &#123; super(); this.target = target; &#125; //创建代理对象 public Object createProxy()&#123; //1.创建Enhancer Enhancer enhancer = new Enhancer(); //2.传递目标对象的class enhancer.setSuperclass(target.getClass()); //3.设置回调操作 enhancer.setCallback(this); return enhancer.create(); &#125; //参数一:代理对象;参数二:需要增强的方法;参数三:需要增强方法的参数;参数四:需要增强的方法的代理 public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"这是增强方法前......\"); Object invoke = methodProxy.invoke(target, args); System.out.println(\"这是增强方法后......\"); return invoke; &#125; public static void main(String[] args) &#123; // 1.创建对象 FoodServiceImpl foodService = new FoodServiceImpl(); // 2.创建代理对象 CglibProxyFactory proxy = new CglibProxyFactory(foodService); // 3.调用代理对象的增强方法,得到增强后的对象 FoodService createProxy = (FoodService) proxy.createProxy(); createProxy.makeChicken(); &#125;&#125;","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"单例设计模式","slug":"单例设计模式","date":"2020-03-04T02:29:37.000Z","updated":"2020-03-04T03:51:24.448Z","comments":true,"path":"2020/03/04/单例设计模式/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1、单例模式：在当前系统中，某个类型的对象，最多只能有一个，就需要使用单例设计模式 2、单例模式的设计原则：1、构造方法私有化2、在类中创建好该类对象3、在类中，给外界提供获取该对象的公有方式 2.1饿汉式在加载类的同时，就要初始化静态成员变量，所以就同时将该类对象创建出来了饿汉式：一有机会，马上就吃，不去等待。（一旦加载类型，马上创建对象） 12345678910111213141516171819202122//单例设计模式之饿汉式//能多早创建对象就多早创建对象public class Demo1_SingtonleHunger &#123; public static void main(String[] args) &#123; SingtonHunger sh1 = SingtonHunger.getInstance(); SingtonHunger sh2 = SingtonHunger.getInstance(); System.out.println(sh1==sh2); &#125;&#125;class SingtonHunger&#123; //1.先私有构造方法 private SingtonHunger()&#123;&#125; //2.私有创建对象的方法 private static SingtonHunger sh = new SingtonHunger(); //3.通过创建对外界可见的方法来调用构造方法 public static SingtonHunger getInstance()&#123; return sh; &#125;&#125; ​ 一上来就把单例对象创建出来了，要用的时候直接返回即可，这种可以说是单例模式中最简单的一种实现方式。但是问题也比较明显。单例在还没有使用到的时候，初始化就已经完成了。也就是说，如果程序从头到位都没用使用这个单例的话，单例的对象还是会创建。这就造成了不必要的资源浪费。所以不推荐这种实现方式。 2.2懒汉式在加载类的时候，不同时创建该类对象，等到需要获取这个对象时，才去创建这个对象懒汉式：不着急、能不创建的时候，就不创建，能拖就拖 注意事项：1、只有在sl == null的时候，才会创建对象2、sl的判断和sl的赋值，不希望分离开，否则在多线程环境下，会出现多个对象的状态，所以sl的判断和sl的赋值，需要放到一个同步代码块中。3、同步代码块的效率非常低，不是每次获取对象的时候，都需要判断锁对象，只有在sl为null的时候， 才应该判断锁对象，因此在外层需要嵌套一个if判断，判断sl是否为null 123456789101112131415161718192021222324252627282930313233//单例模式之懒汉式//能多晚创建对象就多晚创建对象public class Demo2_SingletonLazy &#123; public static void main(String[] args) &#123; SingtonLazy sl1 = SingtonLazy.getInstance(); SingtonLazy sl2 = SingtonLazy.getInstance(); System.out.println(sl1==sl2); &#125;&#125; class SingtonLazy &#123; // 1.私有构造方法 private SingtonLazy() &#123; &#125; // 2.私有创建对象的引用 private static SingtonLazy sl; // 3.提供对外公开的方法创建对象 public static SingtonLazy getInstance() &#123; //最外层判断是否为空用来提高效率 if (sl == null) &#123; synchronized (SingtonLazy.class) &#123; //加上同步锁提高线程安全 if (sl == null) &#123; sl = new SingtonLazy(); &#125; &#125; &#125; return sl; &#125;&#125; 另外一种懒汉式 public class SingletonDemo2 { 1234567891011121314//类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)private static SingletonDemo2 instance; //构造器私有化private SingletonDemo2()&#123;&#125; //方法同步，调用效率低public static synchronized SingletonDemo2 getInstance()&#123; if(instance==null)&#123; instance=new SingletonDemo2(); &#125; return instance; &#125;&#125; 这种如果是多线程的，会有JVM 指令重排的机制，破坏其单例类，所以双重锁判断机制好一些 2.3静态内部类实现123456789101112public class SingletonDemo3 &#123; private static class SingletonClassInstance&#123; private static final SingletonDemo3 instance=new SingletonDemo3(); &#125; private SingletonDemo3()&#123;&#125; public static SingletonDemo3 getInstance()&#123; return SingletonClassInstance.instance; &#125; &#125; 2.4枚举类​ 1234567public enum SingletonDemo4 &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void singletonOperation()&#123; &#125;&#125; ​","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://liudong-code.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"keywords":[]},{"title":"深拷贝和浅拷贝","slug":"深拷贝和浅拷贝","date":"2020-03-04T02:01:02.000Z","updated":"2020-03-04T02:20:23.508Z","comments":true,"path":"2020/03/04/深拷贝和浅拷贝/","link":"","permalink":"https://liudong-code.github.io/2020/03/04/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"介绍开发过程中，有时会遇到把现有的一个对象的所有成员属性拷贝给另一个对象的需求。 比如说对象 A 和对象 B，二者都是 ClassC 的对象，具有成员变量 a 和 b，现在对对象 A 进行拷贝赋值给 B，也就是 B.a = A.a; B.b = A.b; 这时再去改变 B 的属性 a 或者 b 时，可能会遇到问题：假设 a 是基础数据类型，b 是引用类型。 当改变 B.a 的值时，没有问题； 当改变 B.b 的值时，同时也会改变 A.b 的值，因为其实上面的例子中只是把 A.b 赋值给了 B.b，因为是 b 引用类型的，所以它们是指向同一个地址的。这可能就会给我们使用埋下隐患。 1Java 中的数据类型分为基本数据类型和引用数据类型。对于这两种数据类型，在进行赋值操作、用作方法参数或返回值时，会有值传递和引用（地址）传递的差别。 拷贝分类上面的问题，其实就是因为对拷贝的不熟悉导致的。 根据对对象属性的拷贝程度（基本数据类和引用类型），会分为两种： 浅拷贝 (Shallow Copy) 深拷贝 (Deep Copy) 浅拷贝1. 浅拷贝介绍浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 2. 浅拷贝特点(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。 (2) 对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。 3. 浅拷贝的实现实现对象拷贝的类，需要实现 Cloneable 接口，并覆写 clone() 方法。 123456789101112131415161718192021public class Subject &#123; private String name; public Subject(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"[Subject: \" + this.hashCode() + \",name:\" + name + \"]\"; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Student implements Cloneable &#123; //引用类型 private Subject subject; //基础数据类型 private String name; private int age; public Subject getSubject() &#123; return subject; &#125; public void setSubject(Subject subject) &#123; this.subject = subject; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * 重写clone()方法 * @return */ @Override public Object clone() &#123; //浅拷贝 try &#123; // 直接调用父类的clone()方法 return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; return null; &#125; &#125; @Override public String toString() &#123; return \"[Student: \" + this.hashCode() + \",subject:\" + subject + \",name:\" + name + \",age:\" + age + \"]\"; &#125;&#125; 1234567891011121314public class ShallowCopy &#123; public static void main(String[] args) &#123; Subject subject = new Subject(\"yuwen\"); Student studentA = new Student(); studentA.setSubject(subject); studentA.setName(\"Lynn\"); studentA.setAge(20); Student studentB = (Student) studentA.clone(); studentB.setName(\"Lily\"); studentB.setAge(18); Subject subjectB = studentB.getSubject(); subjectB.setName(\"lishi\"); System.out.println(\"studentA:\" + studentA.toString()); System.out.println(\"studentB:\" + studentB.toString()); 输出的结果 12studentA:[Student: 460141958,subject:[Subject:1163157884,name:lishi],name:Lynn,age:20]studentB:[Student: 1956725890,subject[Subject:1163157884,name:lishi],name:Lily,age:18] 深拷贝1. 深拷贝介绍通过上面的例子可以看到，浅拷贝会带来数据安全方面的隐患，例如我们只是想修改了 studentB 的 subject，但是 studentA 的 subject 也被修改了，因为它们都是指向的同一个地址。所以，此种情况下，我们需要用到深拷贝 1深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。 2. 深拷贝特点(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。 (2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。 (3) 对于有多层对象的，每个对象都需要实现 Cloneable 并重写 clone() 方法，进而实现了对象的串行层层拷贝。 (4) 深拷贝相比于浅拷贝速度较慢并且花销较大。 3. 深拷贝的实现对于 Student 的引用类型的成员变量 Subject ，需要实现 Cloneable 并重写 clone() 方法。 123456789101112131415161718192021222324252627public class Subject implements Cloneable &#123; private String name; public Subject(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; //Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现 return super.clone(); &#125; @Override public String toString() &#123; return \"[Subject: \" + this.hashCode() + \",name:\" + name + \"]\"; &#125;&#125; 在 Student 的 clone() 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Student implements Cloneable &#123; //引用类型 private Subject subject; //基础数据类型 private String name; private int age; public Subject getSubject() &#123; return subject; &#125; public void setSubject(Subject subject) &#123; this.subject = subject; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; /** * 重写clone()方法 * @return */ @Override public Object clone() &#123; //深拷贝 try &#123; // 直接调用父类的clone()方法 Student student = (Student) super.clone(); student.subject = (Subject) subject.clone(); return student; &#125; catch (CloneNotSupportedException e) &#123; return null; &#125; &#125; @Override public String toString() &#123; return \"[Student: \" + this.hashCode() + \",subject:\" + subject + \",name:\" + name + \",age:\" + age + \"]\"; &#125;&#125; 一样的使用方式 12345678910111213141516public class ShallowCopy &#123; public static void main(String[] args) &#123; Subject subject = new Subject(\"yuwen\"); Student studentA = new Student(); studentA.setSubject(subject); studentA.setName(\"Lynn\"); studentA.setAge(20); Student studentB = (Student) studentA.clone(); studentB.setName(\"Lily\"); studentB.setAge(18); Subject subjectB = studentB.getSubject(); subjectB.setName(\"lishi\"); System.out.println(\"studentA:\" + studentA.toString()); System.out.println(\"studentB:\" + studentB.toString()); &#125;&#125; 输出结果： 12studentA:[Student: 460141958,subject:[Subject:1163157884,name:yuwen],name:Lynn,age:20]studentB:[Student: 1956725890,subject:[Subject:356573597,name:lishi],name:Lily,age:18] 由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"java内存溢出","slug":"java内存溢出","date":"2020-03-02T02:16:07.000Z","updated":"2020-03-02T02:56:53.160Z","comments":true,"path":"2020/03/02/java内存溢出/","link":"","permalink":"https://liudong-code.github.io/2020/03/02/java%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/","excerpt":"","text":"–本文源自于《深入理解Java虚拟机》 概述​ 在Java虚拟机规范描述中，除了程序计数器以外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能。 Java堆溢出​ Java堆用于储存对象实例，只要不断的创建对象，并且保证GCRoots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象到达最大堆的容量之后，就会产生内存溢出异常。 java.lang.OutOfMem0ryError:Java heap space 123456789101112131415161718/**Vm Args:-Xms20m XMx20m -XX:+HeapDumpOnOUtOFMemoryError*/public class JvmTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; aList = new ArrayList&lt;String&gt;(); try&#123; while(true)&#123; aList.add(\"asdasdasdas\"); &#125; &#125;catch(Throwable e)&#123; System.out.println(aList.size()); e.printStackTrace(); &#125; &#125;&#125; 解决手段：​ 先通过内存映像分析工具（如：Eclipse Memory Analyzer）堆Dump出来的堆转储快照进行分析，重点确认内存中的对象是否是必要的，也就是药神分清楚到底是出现了内存泄漏还是内存溢出。 ​ 如果是内存泄漏，可以进一步通过工具查看泄露对象到GC Roots的引用链，于是就能找到泄漏对象是通过怎样的路径与GC Roots 相关联并导致垃圾回收器无法自动回收他们的。掌握了泄漏对象的类型信息，及GCRoots引用链的信息，就可以比较准确的定位出泄漏代码的 位置。 ​ 如果不是泄漏，就是在内存中对象还活着，应当检查虚拟机的堆参数（-Xmx与Xms） 虚拟机栈和本地方法栈溢出​ Java虚拟机规范中描述了两种异常 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 123456789101112public class JvmTest &#123; private int i = 0; public void a()&#123; System.out.println(i++); a(); &#125; public static void main(String[] args) &#123; JvmTest j = new JvmTest(); j.a(); &#125;｝ 方法区和运行时常量池溢出–待补 本机直接内存溢出–待补","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://liudong-code.github.io/tags/JVM/"}],"keywords":[]},{"title":"throw和throws的区别","slug":"throw和throws的区别","date":"2020-02-29T11:12:48.000Z","updated":"2020-02-29T11:18:05.497Z","comments":true,"path":"2020/02/29/throw和throws的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"抛出异常有三种形式 throw throws 系统自动抛异常 一、系统自动抛异常 当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常：（举个栗子） 12345public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); // 此处系统会自动抛出ArithmeticException异常 //function(); &#125; 二、throw throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 123456789public static void main(String[] args) &#123; String s = \"abc\"; if(s.equals(\"abc\")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; //function(); &#125; 运行时，系统会抛出如下异常： 1Exception in thread \"main\" java.lang.NumberFormatException at...... 三、throws 12345678910111213141516当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理public class testThrows()&#123;public static void function() throws NumberFormatException &#123; String s = \"abc\"; System.out.println(Double.parseDouble(s)); &#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println(\"非数据类型不能强制类型转换。\"); //e.printStackTrace(); &#125; &#125; 四、throw与throws的比较 throws出现在方法函数头；而throw出现在函数体。throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 五、编程习惯： 在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理 原文链接：https://blog.csdn.net/xsj_blog/article/details/83030450 原文链接：https://blog.csdn.net/xsj_blog/article/details/83030450","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"java中的异常链","slug":"java中的异常链","date":"2020-02-29T11:07:08.000Z","updated":"2020-02-29T11:11:28.590Z","comments":true,"path":"2020/02/29/java中的异常链/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/","excerpt":"","text":"概念​ 把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args)&#123; ChainTest ct=new ChainTest();//创建chainTest实例 try&#123; ct.test2(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;public void test1()throws DrunkException&#123; throw new DrunkException(\"喝车别开酒\");&#125;public void test2()&#123; try&#123; test1();&#125;catch (DrunkException e)&#123; RuntimeException newExc=new RuntimeException(\"司机一滴酒亲人两行泪\")；//含参构造器 newExc.initCause(e);//调用newExc的init方法，把捕获的DrunkException传进去 throw newExc;//抛出新异常 &#125;&#125;","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java的异常体系","slug":"Java的异常体系","date":"2020-02-29T10:54:18.000Z","updated":"2020-02-29T11:20:57.893Z","comments":true,"path":"2020/02/29/Java的异常体系/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"java中异常的体系结构图解： ​ java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。 java异常体系结构​ Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系： 1、Error与Exception Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。2、运行时异常和非运行时异常 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 异常的捕获和处理try、catch、finally 第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。 第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。 第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。 第四：先Catch子类异常再Catch父类异常。 throw、throws关键字throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取 的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： 123public static void test() throws Exception &#123; throw new Exception(\"方法test中的Exception\"); &#125;","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"如何格式化日期","slug":"如何格式化日期","date":"2020-02-29T10:42:07.000Z","updated":"2020-02-29T11:24:29.516Z","comments":true,"path":"2020/02/29/如何格式化日期/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/","excerpt":"","text":"1234DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate localDate = LocalDate.now(); String date = localDate.format(dateTimeFormatter); System.out.println(\"date:\"+date)； 补充:java的时间日期API一直以来都是被诟病的东西,为了解决这一问题,java8中引入了新的时间日期API,其中包括LocalDate,LocalTime,LocalDate,LocalDateTime,Clock,Instant等类,这些的类的设计都使用了不变模式,因此是线程安全的设计. 原文链接：https://blog.csdn.net/riju4713/article/details/88220120","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？","slug":"静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？","date":"2020-02-29T10:35:58.000Z","updated":"2020-02-29T10:38:33.433Z","comments":true,"path":"2020/02/29/静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/","excerpt":"","text":"可以被继承，代码如下123456789101112131415161718192021222324252627public class One &#123; //静态属性和静态方法是否可以被继承？ public static String one_1 = \"one\"; public static void oneFn() &#123; System.out.println(\"oneFn\"); &#125;&#125;public class Two extends One&#123; //空&#125;public class MyTest &#123; //静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ public static void main(String[] args) &#123; One one = new Two(); one.oneFn(); String one_1 = One.one_1; System.out.println(\"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_1); String one_12 = one.one_1; System.out.println(\"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_12); &#125;&#125;//打印结果如下oneFnOne.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;oneone.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one 不能被重写，代码如下123456789101112131415161718192021222324252627282930313233public class One &#123; //静态属性和静态方法是否可以被重写？以及原因？ public static String one_1 = \"one\"; public static void oneFn() &#123; System.out.println(\"oneFn\"); &#125;&#125;public class Two extends One &#123; public static String one_1 = \"two\"; public static void oneFn() &#123; System.out.println(\"TwoFn\"); &#125;&#125;public class MyTest &#123; //静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ public static void main(String[] args) &#123; One one = new Two(); one.oneFn(); String one_1 = One.one_1; System.out.println(\"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_1); String one_12 = one.one_1; System.out.println(\"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_12); &#125;&#125;//打印结果如下//oneFn//One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one//one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one 原因static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。 注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"string转换成integer的方式及原理","slug":"string转换成integer的方式及原理","date":"2020-02-29T10:04:02.000Z","updated":"2020-02-29T10:23:45.563Z","comments":true,"path":"2020/02/29/string转换成integer的方式及原理/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/","excerpt":"","text":"string转换成integer的方式及原理1. Integer.parseInt（String str）方法​ 源码如下 123public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125; 2. Integer.parseInt（String s, int radix）方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public static int parseInt(String s, int radix) throws NumberFormatException&#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException(\"null\"); &#125; //基数是否小于最小基数 if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException(\"radix \" + radix + \" less than Character.MIN_RADIX\"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException(\"radix \" + radix + \" greater than Character.MAX_RADIX\"); &#125; int result = 0; //是否是负数 boolean negative = false; int i = 0, len = s.length(); //最大值限制 int limit = -Integer.MAX_VALUE; int multmin; int digit; //判断字符长度是否大于0，否则抛出异常 if (len &gt; 0) &#123; //第一个字符是否是符号 char firstChar = s.charAt(0); //根据ascii码表看出加号(43)和负号(45)对应的 //十进制数小于‘0’(48)的 if (firstChar &lt; '0') &#123; // Possible leading \"+\" or \"-\" //是负号 if (firstChar == '-') &#123; //负号属性设置为true negative = true; limit = Integer.MIN_VALUE; //不是负号也不是加号则抛出异常 &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); //如果有符号（加号或者减号）且字符串长度为1，则抛出异常 if (len == 1) // Cannot have lone \"+\" or \"-\" throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE //此方法为确定数字的的十进制值 digit = Character.digit(s.charAt(i++),radix); //小于0，则为非数值字符串 if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; //result第一次为0，第一次肯定为true if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; //result乘以基数（10）为得到位置 //例如第一次的result为-1，第二次乘以10后为-10 //下面再-=digit（例如：1）则得到-11 //以此类推 result *= radix; if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; //第一次result为0 -=digit则为负值的该digit result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; //根据上面得到的是否负数，返回相应的值 return negative ? result : -result; &#125; 3.Character.digit(char ch, int radix)方法12345678910111213141516171819202122232425262728public static int digit(int codePoint, int radix) &#123; //基数必须再最大和最小基数之间 if (radix &lt; MIN_RADIX || radix &gt; MAX_RADIX) &#123; return -1; &#125; if (codePoint &lt; 128) &#123; // Optimized for ASCII int result = -1; //字符在0-9字符之间 if ('0' &lt;= codePoint &amp;&amp; codePoint &lt;= '9') &#123; result = codePoint - '0'; &#125; //字符在a-z之间 else if ('a' &lt;= codePoint &amp;&amp; codePoint &lt;= 'z') &#123; result = 10 + (codePoint - 'a'); &#125; //字符在A-Z之间 else if ('A' &lt;= codePoint &amp;&amp; codePoint &lt;= 'Z') &#123; result = 10 + (codePoint - 'A'); &#125; //通过判断result和基数大小，输出对应值 //通过我们parseInt对应的基数值为10， //所以，只能在第一个判断（字符在0-9字符之间） //中得到result值 否则后续程序会抛出异常 return result &lt; radix ? result : -1; &#125; return digitImpl(codePoint, radix); &#125; 总结：integer.parseInt(string str)方法调用Integer内部的 parseInt(string str,10)方法,默认基数为10，parseInt内部首先 判断字符串是否包含符号（-或者+），则对相应的negative和limit进行 赋值，然后再循环字符串，对单个char进行数值计算Character.digit(char ch, int radix) 在这个方法中，函数肯定进入到0-9字符的判断（相对于string转换到int）， 否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"序列化的方式","slug":"序列化的方式","date":"2020-02-29T03:23:06.000Z","updated":"2020-02-29T09:53:38.621Z","comments":true,"path":"2020/02/29/序列化的方式/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"概念序列化：将对象转化成一个字节序列，便于储存。 反序列化：将字节化的字节序列还原。 优点：可以实现对象的”持久性”， 所谓持久性就是指对象的生命周期不取决于程序。 序列化的几种方式Java原生的序列化**序列化需要：** 所需类：ObjectInputStream和ObjectOutputStream 方法： readObject()和writeObject(); 隐式序列化​ 实现Serializabie接口，通过实现Serializable接口，这种是隐式序列化(不需要手动)，这种是最简单的序列化方式，会自动序列化所有非static和 transient关键字修饰的成员变量。 ​ 12345678910111213141516171819202122232425262728public class IpConfig &#123; private String name; private int age; public static int virualAge = 123; private transient String ipAdress =\"127.0.0.1\"; public IpConfig(String name, int i) &#123; this.name=name; this.age=i; &#125; public String toString() &#123; return \"name: \" + name + \"\\n\" +\"age: \" + age + \"\\n\" +\"virualAge: \" + virualAge + \"\\n\" + \"ipAdress: \" + ipAdress; &#125; public void SetAge(int age) &#123; this.age = age; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public class test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //创建可序列化对象 System.out.println(\"原来的对象：\"); IpConfig ipConfig = new IpConfig(\"Ming\", 16); System.out.println(ipConfig); //创建序列化输出流 ByteArrayOutputStream outputStream=new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream); //将序列化对象存入缓冲区 objectOutputStream.writeObject(ipConfig); //改值 ipConfig.SetAge(11); IpConfig.virualAge=5555; //从缓冲区取回被序列化的对象 ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())); IpConfig newIpconfig = (IpConfig) in.readObject(); System.out.println(\"序列化后取出的对象：\"); System.out.println(newIpconfig); &#125;&#125;原来的对象：name: Mingage: 16virualAge: 123address: 127.0.0.1序列化后取出的对象：name: Mingage: 16virualAge: 5555address: null ​ 发现ipAddress(被transient)和virualAge(被static)也没有被序列化，中途修改virualAge的值是为了以防读者误会virualAge被序列化了。因为序列化可以保存对象的状态，但是virualAge的值被改变了，说明没有被序列化。static成员不属于对象实例，可能被别的对象修改没办法序列化,序列化是序列对象。对于address被反序列化后由于没有对应的引用，所以为null。而且Serializable不会调用构造方法。 显式序列化​ 实现Externalizable接口 ​ Externalizable接口继承自Serializable, 我们在实现该接口时，必须实现writeExternal()和readExternal()方法，而且只能通过手动进行序列化，并且两个方法是自动调用的，因此，这个序列化过程是可控的，可以自己选择哪些部分序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Blip implements Externalizable&#123; private int i ; private String s; public Blip() &#123;&#125; public Blip(String x, int a) &#123; System.out.println(\"Blip (String x, int a)\"); s = x; i = a; &#125; public String toString() &#123; return s+i; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; // TODO Auto-generated method stub System.out.println(\"Blip.writeExternal\"); out.writeObject(s); out.writeInt(i); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; // TODO Auto-generated method stub System.out.println(\"Blip.readExternal\"); s = (String)in.readObject(); i = in.readInt(); &#125; public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123; System.out.println(\"Constructing objects\"); Blip b = new Blip(\"A Stirng\", 47); System.out.println(b); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"F://Demo//file1.txt\")); System.out.println(\"保存对象\"); o.writeObject(b); o.close(); //获得对象 System.out.println(\"获取对象\"); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"F://Demo//file1.txt\")); System.out.println(\"Recovering b\"); b = (Blip)in.readObject(); System.out.println(b); &#125;&#125;打印结果为：Constructing objectsBlip (String x, int a)A Stirng47保存对象Blip.writeExternal获取对象Recovering bBlip.readExternalA Stirng47当注释掉writeExternal和readExternal方法后打印结果为:Constructing objectsBlip (String x, int a)A Stirng47保存对象Blip.writeExternal获取对象Recovering bBlip.readExternalnull0 说明：Externalizable类会调用public的构造函数先初始化对象，在调用所保存的内容将对象还原。假如构造方法不是public则会出现运行时错误。 显式+隐式的实现​ 如果想将方式一和方式二的优点都用到的话，可以采用方式三， 先实现Serializable接口，并且添加writeObject()和readObject()方法。注意这里是添加，不是重写或者覆盖。但是添加的这两个方法必须有相应的格式。 1，方法必须要被private修饰 —–&gt;才能被调用2，第一行调用默认的defaultRead/WriteObject(); —–&gt;隐式序列化非static和transient3，调用read/writeObject()将获得的值赋给相应的值 —&gt;显式序列化 123456789101112131415161718192021222324252627282930313233343536373839public class SerDemo implements Serializable&#123; public transient int age = 23; public String name ; public SerDemo()&#123; System.out.println(\"默认构造器。。。\"); &#125; public SerDemo(String name) &#123; this.name = name; &#125; private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.defaultWriteObject(); stream.writeInt(age); &#125; private void readObject(ObjectInputStream stream) throws ClassNotFoundException, IOException &#123; stream.defaultReadObject(); age = stream.readInt(); &#125; public String toString() &#123; return \"年龄\" + age + \" \" + name; &#125;public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerDemo stu = new SerDemo(\"Ming\"); ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bout); out.writeObject(stu); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bout.toByteArray())); SerDemo stu1 = (SerDemo) in.readObject(); System.out.println(stu1); &#125;&#125;打印结果为：年龄23 Ming注释掉stream.writeInt(age)和age= stream.readInt()后：年龄0 Ming方式三结合了显式和隐式序列化，Ming被正常序列化，由于age被trancient修饰，所以需要显式序列化。 Json序列化​ Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package serialize;import java.io.IOException;import java.util.ArrayList;import java.util.List;import com.fasterxml.jackson.databind.ObjectMapper;public class JsonSerialize &#123; public static void main(String[] args) throws IOException &#123; new JsonSerialize().start(); &#125; public void start() throws IOException &#123; User u = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u.setUserName(\"张三\"); u.setPassWord(\"123456\"); u.setUserInfo(\"张三是一个很牛逼的人\"); u.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); ObjectMapper mapper = new ObjectMapper(); Long t1 = System.currentTimeMillis(); byte[] writeValueAsBytes = null; for (int i = 0; i &lt; 10; i++) &#123; writeValueAsBytes = mapper.writeValueAsBytes(u); &#125; System.out.println(\"json serialize: \" + (System.currentTimeMillis() - t1) + \"ms; 总大小：\" + writeValueAsBytes.length); Long t2 = System.currentTimeMillis(); User user = mapper.readValue(writeValueAsBytes, User.class); System.out.println(\"json deserialize: \" + (System.currentTimeMillis() - t2) + \"ms; User: \" + user); &#125;&#125; 12json serialize: 55ms; 总大小：341json deserialize: 35ms; User: User [userId=null, userName=张三, passWord=123456, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=123456, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=123456, userInfo=王五是一个很牛逼的人, friends=null]]] FastJson序列化​ fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本支持Android。使用时候需引入FastJson第三方jar包。FastJson序列化代码示例如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package serialize;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSON;/** * * @author liqqc * */public class FastJsonSerialize &#123; public static void main(String[] args) &#123; new FastJsonSerialize().start(); &#125; public void start()&#123; User u = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u.setUserName(\"张三\"); u.setPassWord(\"123456\"); u.setUserInfo(\"张三是一个很牛逼的人\"); u.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); //序列化 Long t1 = System.currentTimeMillis(); String text = null; for(int i = 0; i&lt;10; i++) &#123; text = JSON.toJSONString(u); &#125; System.out.println(\"fastJson serialize: \" +(System.currentTimeMillis() - t1) + \"ms; 总大小：\" + text.getBytes().length); //反序列化 Long t2 = System.currentTimeMillis(); User user = JSON.parseObject(text, User.class); System.out.println(\"fastJson serialize: \" + (System.currentTimeMillis() -t2) + \"ms; User: \" + user); &#125;&#125; ProtoBuff序列化1234567ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。 参考地址： https://github.com/google/protobuf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package serialize;import java.io.Serializable;import java.util.List;import com.baidu.bjf.remoting.protobuf.FieldType;import com.baidu.bjf.remoting.protobuf.annotation.Protobuf;public class User implements Serializable &#123; private static final long serialVersionUID = -7890663945232864573L; @Protobuf(fieldType = FieldType.INT32, required = false, order = 1) private Integer userId; @Protobuf(fieldType = FieldType.STRING, required = false, order = 2) private String userName; @Protobuf(fieldType = FieldType.STRING, required = false, order = 3) private String passWord; @Protobuf(fieldType = FieldType.STRING, required = false, order = 4) private String userInfo; @Protobuf(fieldType = FieldType.OBJECT, required = false, order = 5) private List&lt;User&gt; friends; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public String getUserInfo() &#123; return userInfo; &#125; public void setUserInfo(String userInfo) &#123; this.userInfo = userInfo; &#125; public List&lt;User&gt; getFriends() &#123; return friends; &#125; public void setFriends(List&lt;User&gt; friends) &#123; this.friends = friends; &#125; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", passWord=\" + passWord + \", userInfo=\" + userInfo + \", friends=\" + friends + \"]\"; &#125;&#125; jprotobuf序列化代码示例如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package serialize;import java.io.IOException;import java.util.ArrayList;import java.util.List;import com.baidu.bjf.remoting.protobuf.Codec;import com.baidu.bjf.remoting.protobuf.ProtobufProxy;/** * * @author liqqc * */public class ProtoBuffSerialize &#123; public static void main(String[] args) throws IOException &#123; new ProtoBuffSerialize().start(); &#125; public void start() throws IOException &#123; Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User.class, false); User u2 = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u2.setUserName(\"张三\"); u2.setPassWord(\"123456\"); u2.setUserInfo(\"张三是一个很牛逼的人\"); u2.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); Long stime_jpb_encode = System.currentTimeMillis(); byte[] bytes = null; for(int i = 0; i&lt;10; i++) &#123; bytes = studentClassCodec.encode(u2); &#125; System.out.println(\"jprotobuf序列化耗时：\" + (System.currentTimeMillis() - stime_jpb_encode) + \"ms; 总大小：\" + bytes.length); Long stime_jpb_decode = System.currentTimeMillis(); User user = studentClassCodec.decode(bytes); Long etime_jpb_decode = System.currentTimeMillis(); System.out.println(\"jprotobuf反序列化耗时：\"+ (etime_jpb_decode-stime_jpb_decode) + \"ms; User: \" + user); &#125;&#125; 运行结果 12jprotobuf序列化耗时：9ms; 总大小：148jprotobuf反序列化耗时：0ms; User: User [userId=null, userName=张三, passWord=123456, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=123456, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=123456, userInfo=王五是一个很牛逼的人, friends=null]]]","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"IO多路复用技术以及epoll实现原理","slug":"IO多路复用技术以及epoll实现原理","date":"2020-02-28T10:57:13.000Z","updated":"2020-02-28T11:36:18.863Z","comments":true,"path":"2020/02/28/IO多路复用技术以及epoll实现原理/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"为什么Redis中要使用I/O多路复用呢？​ redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。 ​ redis 采用网络IO多路复用技来保证在多连接的时候， 系统的高吞吐量。 ​ Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的. ​ select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。​ redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。 epoll实现机制123设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ ​ select/poll是，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 ​ 如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。 总结：select和poll的缺点如下： 每次调用select/poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 同时每次调用select/poll都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 针对select支持的文件描述符数量太小了，默认是1024 select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件； select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。 相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。 ​ epoll的设计和实现与select完全不同。epoll是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。 ​ epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先select/poll调用分成了3个部分： 1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源) 2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字 3）调用epoll_wait收集发生的事件的连接 ​ 如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。 总结：epoll的优点 epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大 ，具体数目可以 cat /proc/sys/fs/file-max 察看。 效率提升， epoll 最大的优点就在于它只管你“活跃”的连接 ，而跟连接总数无关，因此在实际的网络环境中， epoll 的效率就会远远高于 select 和 poll 。 内存拷贝， epoll 在这点上使用了“共享内存”，这个内存拷贝也省略了 redis epoll底层实现​ 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关 eventpoll结构体如下所示 12345678910struct eventpoll｛ ..... /*红黑树节点的根，存储着所有添加到epoll中的需要监控的事件*/ struct rb_root rbt; /*双链表中储存着将要通过epoll_wait返回给用户满足条件的事件*/ struct list_head rdlist; .....｝ ​ 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。 ​ 而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。 ​ 在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示： 1234567struct epitem&#123; struct rb_node rbn;//红黑树节点 struct list_head rdllink;//双向链表节点 struct epoll_filedfd ffd;//句柄事件信息 struct eventpoll *ep ;// 指向其所属的eventpoll对象 struct epoll_event;//期待发生的事件类型&#125; ​ 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户 优势： 不用重复传递。我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。 在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。 极其高效的原因：这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。 这个准备就绪list链表是怎么维护的呢？​ 当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。（注：好好理解这句话！） ​ 从上面这句可以看出，epoll的基础就是回调呀！ ​ 如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。 ​ 最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。关于LT，ET，有一端描述，LT和ET都是电子里面的术语，ET是边缘触发，LT是水平触发，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。 ​ LT, ET这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"},{"name":"Redis相关","slug":"Redis相关","permalink":"https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"}],"keywords":[]},{"title":"常见的IO模型","slug":"常见的IO模型","date":"2020-02-28T09:35:29.000Z","updated":"2020-02-29T11:22:38.590Z","comments":true,"path":"2020/02/28/常见的IO模型/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"高性能IO模型，常见的有四种：（1）同步阻塞IO（Blocking IO）：即传统的IO模型。 （2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。 （3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。 （4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。 IO模型举例理解1 阻塞IO, 给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不 会做其他事情, 属于备胎做法. 非阻塞IO, 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会 做其他事情, 属于专一做法. IO多路复用, 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么? 3.1 select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子 3.2 poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神 3.3 epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于同步等待状态 接下来是异步IO的情况 你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了,女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口. 此时属于逆袭做法 IO模型举例理解21.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。 3.I/O复用模型 select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次 epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话 4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话 5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话 同步阻塞IO​ 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。 等待数据就绪（读就绪、写就绪）； 将数据从内核中拷贝到JVM进程中； 处理数据。 ​ 整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够 同步非阻塞IO ​ 由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。 伪代码： 1234&#123; while(read(socket, buffer) != SUCCESS); process(buffer);&#125; ​ 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。 IO多路复用​ IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。 ​ 用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。 ​ 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。 ​ 但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。 ​ 用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 用户线程使用IO多路复用模型的伪代码描述为： 123456789void UserEventHandler::handle_event() &#123; if(can_read(socket)) &#123; read(socket, buffer); process(buffer); &#125; &#125;&#123; Reactor.register(new UserEventHandler(socket));&#125; ​ 用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下： 12345678Reactor::handle_events() &#123; while(1) &#123; sockets = select(); for(socket in sockets) &#123; get_event_handler(socket).handle_event(); &#125; &#125;&#125; ​ 事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。​ IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。 异步IO​ “真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。 异步IO模型使用了Proactor设计模式实现了这一机制。 异步IO模型中， 用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核， 然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。 最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。 用户线程使用异步IO模型的伪代码描述为： 1234567void UserCompletionHandler::handle_event(buffer) &#123; process(buffer);&#125;&#123; aio_read(socket, new UserCompletionHandler);&#125; 用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。 相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"IO设计模式之Reactor和Proactor","slug":"IO设计模式之Reactor和Proactor","date":"2020-02-28T08:49:31.000Z","updated":"2020-02-28T09:45:04.562Z","comments":true,"path":"2020/02/28/IO设计模式之Reactor和Proactor/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/","excerpt":"","text":"反应器Reactor概述​ 反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的 事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求， 然后派发这些请求至相关的工作线程进行处理。 Reactor模式主要包含下面几部分内容： 初始事件分发器(Initialization Dispatcher)：用于管理Event Handler，定义注册、移除EventHandler等。它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中handle_event(方法 同步（多路）事件分离器(Synchronous Event Demultiplexer)：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知初始事件分发器去调取特定的事件处理器。 系统处理程序(Handles)：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指SocketHandle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到SynchronousEvent Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。 事件处理器(Event Handler)： 定义事件处理方法，以供Initialization Dispatcher回调使用。 为什么使用Reactor模式​ 并发系统常使用reactor模式代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量。 例如：在高并发的情况下，既可以使用多处理处理方式，也可以使用Reactor处理方式。 多线程的处理：​ 为每个单独到来的请求，专门启动一条线程，这样的话造成系统的开销很大，并且在单核的机上，多线程并不能提高系统的性能，除非在有一些阻塞的情况发生。否则线程切换的开销会使处理的速度变慢。 Reactor模式的处理：​ 服务器端启动一条单线程，用于轮询IO操作是否就绪，当有就绪的才进行相应的读写操作，这样的话就减少了服务器产生大量的线程，也不会出现线程之间的切换产生的性能消耗。(目前JAVA的NIO就采用的此种模式，这里引申出一个问题：在多核情况下NIO的扩展问题) ​ 以上两种处理方式都是基于同步的，多线程的处理是我们传统模式下对高并发的处理方式，Reactor模式的处理是现今面对高并发和高性能一种主流的处理方式。 Reactor模式结构 Reactor包含如下角色： Handle 句柄；用来标识socket连接或是打开文件； Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；） Event Handler：事件处理接口 Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑； Reactor：反应器，定义一个接口，实现以下功能： 1）供应用程序注册和删除关注的事件句柄； 2）运行事件循环； 3）有就绪事件到来时，分发事件到之前注册的回调函数上处理； Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法 应用启动，将关注的事件handle注册到Reactor中； 调用Reactor，进入无限事件循环，等待注册的事件到来； 事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理； Proactor模式​ 运用于异步I/O操作，Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.​ Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。 Proactor模式结构 Proactor主动器模式包含如下角色 Handle 句柄；用来标识socket连接或是打开文件； Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现； Asynchronous Operation：异步操作 Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用 Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑； Completion Handler：完成事件接口；一般是由回调函数组成的接口； Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑； 业务流程及时序图 应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行； 应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来； 异步操作处理器执行异步操作，完成后将结果放入到完成事件队列； 主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中； 对比两者的区别主动和被动以主动写为例： Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑； Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑； 可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；Proactor直接调用异步读写操作，调用完后立刻返回； 实现Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应； Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响） 优点Reactor实现相对简单，对于耗时短的处理场景处理高效；操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来， Proactor性能更高，能够处理耗时长的并发场景； 缺点Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理； Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现； 适用场景Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；Proactor：异步接收和同时处理多个服务请求的事件驱动程序； 开源产品如Redis、ACE，事件模型都使用的Reactor模式","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"同步IO、异步IO、阻塞IO、非阻塞IO","slug":"同步IO、异步IO、阻塞IO、非阻塞IO","date":"2020-02-28T08:43:03.000Z","updated":"2020-02-28T08:47:20.869Z","comments":true,"path":"2020/02/28/同步IO、异步IO、阻塞IO、非阻塞IO/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/","excerpt":"","text":"同步IO和异步IO同步和异步是针对应用程序和内核的交互而言的， 同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪， 异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。 指的是用户空间和内核空间数据交互的方式 ​ 同步：用户空间要的数据，必须等到内核空间给它才做其他事情 ​ 异步：用户空间要的数据，不需要等到内核空间给它，才做其他事情。内核空间会异步通知用户进程，并把 数据直接给到用户空间 阻塞IO和非阻塞IO 阻塞方式下读取或者写入函数将一直等待， 非阻塞方式下，读取或者写入函数会立即返回一个状态值。 指的是用户就和内核空间IO操作的方式 ​ 堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是堵塞的 ​ 非堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是不堵塞的，直接返回的， 只是返回时，可能没有数据而已","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"Socket网络编程","slug":"Socket网络编程","date":"2020-02-28T08:29:54.000Z","updated":"2020-02-28T08:37:52.983Z","comments":true,"path":"2020/02/28/Socket网络编程/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"客户端123456789101112131415public class SocketClient &#123; public static void main(String args[]) throws Exception &#123; // 要连接的服务端IP地址和端口 String host = \"127.0.0.1\"; int port = 55533; // 与服务端建立连接 Socket socket = new Socket(host, port); // 建立连接后获得输出流 OutputStream outputStream = socket.getOutputStream(); String message=\"你好 yiwangzhibujian\"; socket.getOutputStream().write(message.getBytes(\"UTF-8\")); outputStream.close(); socket.close(); &#125;&#125; 服务端123456789101112131415161718192021222324public class SocketServer &#123; public static void main(String[] args) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len,\"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); server.close(); &#125;&#125; 123456789101112131415161718192021222324public class SocketServer &#123; public static void main(String args[]) throws IOException &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); while(true)&#123; Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, \"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); &#125; &#125;&#125; 线程池的方式： 1234567891011121314151617181920212223242526272829303132public class SocketServer &#123; public static void main(String args[]) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); //如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源 ExecutorService threadPool = Executors.newFixedThreadPool(100); while (true) &#123;Socket socket = server.accept(); Runnable runnable=()-&gt;&#123; try &#123; // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, \"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; threadPool.submit(runnable); &#125; &#125;&#125;","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"IO访问方式","slug":"IO访问方式","date":"2020-02-28T03:50:23.000Z","updated":"2020-02-28T08:27:25.684Z","comments":true,"path":"2020/02/28/IO访问方式/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"磁盘IO​ 当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从 缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。​ 当应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已 经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令。 网络IO​ 1）操作系统将数据从磁盘复制到操作系统内核的页缓存中 ​ 2）应用将数据从内核缓存复制到应用的缓存中 ​ 3）应用 将数据写回内核的Socket缓存中 ​ 4）操作系统将数据从Socket缓存区复制到网卡缓存，然后将其通过网络发出 1我是图，图待补... 1、当调用read系统调用时，通过DMA（Direct Memory Access）将数据copy到内核模式 2、然后由CPU控制将内 核模式数据copy到用户模式下的 buffer中 3、read调用完成后，write调用首先将用户模式下 buffer中的数据copy到内核模式下的socket buffer中 4、最后通过DMA copy将内核模式下的socket buffer中的数据copy到网卡设备中传送。 比较 磁盘IO主要的延时是由（以15000rpm硬盘为例）： 机械转动延时（机械磁盘的主要性能瓶颈，平均为2ms） + 寻址延时（2~3ms） + 块传输延时（一般4k每块，40m/s的传输速度，延时一般为0.1ms) 决定。（平均为5ms） 网络IO主要延是由： 服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时 决定。（一般为几十到几千毫秒，受环境干扰极大）所以两者一般来说网络IO延时要大于磁盘IO的延时。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"缓存IO和直接IO","slug":"缓存IO和直接IO","date":"2020-02-28T02:21:56.000Z","updated":"2020-02-28T03:23:17.351Z","comments":true,"path":"2020/02/28/缓存IO和直接IO/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E7%BC%93%E5%AD%98IO%E5%92%8C%E7%9B%B4%E6%8E%A5IO/","excerpt":"","text":"定义 缓存IO：数据从磁盘通过DMA copy到内核空间，再从内核空间通过CPU copy到用户空间。 直接IO：数据从磁盘通过DMA copy到用户空间。 缓存IO​ 缓存I/O又被称作标准IO，大多数文件系统的默认操作都是缓存IO。在Linux的缓存IO机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。 读操作： 操作系统检查内核的缓冲区有没有西药的数据，如果已经缓存，那么直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。 写操作： 数据从用户空间复制到内核空间的缓存中，这时对用户程序来说写操作就已经完后才能，至于什么时候在写到磁盘中由操作系统决定，除非显示的调用了sync同步命令。–《【珍藏】linux 同步IO: sync、fsync与fdatasync》。 缓存I/O的优点： 1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全； 2）可以减少读盘的次数，从而提高性能。 缓存I/O的缺点： 在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘 上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址 空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存 开销是非常大的。 直接IO​ 直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区，自己管理IO缓冲区，这样做的目的是减少一次从内核缓冲区带用户程序缓存的数据复制。 直接IO的优点 ​ 应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序 缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。 ​ 引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓 冲区中，那么就不需要再次访问磁盘；而当进程需要向文件中写入数据时，实际上只是写到了内核缓冲区便告诉进程 已经写成功，而真正写入磁盘是通过一定的策略进行延迟的。 ​ 然而，对于一些较复杂的应用，比如数据库服务器，它们为了充分提高性能，希望绕过内核缓冲区，由自己在用户 态空间实现并管理I/O缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据更加 合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就 在使用系统内存。 直接IO的缺点 ​ 如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载 会非常缓慢。通常直接I/O跟异步I/O结合使用会得到较好的性能。 ​","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"PIO和DMA","slug":"PIO和DMA","date":"2020-02-28T02:09:06.000Z","updated":"2020-02-28T02:20:04.626Z","comments":true,"path":"2020/02/28/PIO和DMA/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/PIO%E5%92%8CDMA/","excerpt":"","text":"慢速IO设备和内存之间的数据传输方式有下面两种： PIO：磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU储存转发，这种方式成为PIO。这种方式是不合理的，需要大量的CPU时间来读取文件，照成文件访问时系统几乎停止响应。 DMA：DMA（直接内存访问，Direct Memory Access），不经过CPU而直接进行磁盘和内存（内核空间）的数据交换。在DMA的模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据和传达即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异并不是十分明显，因为这主要取决于慢速设备的速度。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"用户空间和内核空间","slug":"用户空间和内核空间","date":"2020-02-27T15:14:39.000Z","updated":"2020-02-27T15:56:55.859Z","comments":true,"path":"2020/02/27/用户空间和内核空间/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/","excerpt":"","text":"定义虚拟内存被操作系统划分成两块：内核空间和用户空间， 内核空间是内核代码运行的地方， 用户空间是用户程序代码运行的地方 当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。 简单说， Kernel space 是 Linux 内核的运行空间， User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 1234str = \"my string\" // 用户空间x = x + 2file.write(str) // 切换到内核空间y = x + 4 // 切换回用户空间 第一行和第二行都是简单的赋值运算，在 User space 执行。 第三行需要写入文件，就要切换到Kernel space，因为用户不能直接写文件，必须通过内核安排。 第四行又是赋值运算，就切换回 User space。 查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况，可以使用top命令。它的第三行输出就是 CPU 时间分配统计。 其中，第一项24.8 us（user 的缩写）就是 CPU 消耗在 User space 的时间百分比，第二项0.5 sy（system 的缩写）是消耗在 Kernel space 的时间百分比。随便也说一下其他 6 个指标的含义。ni：niceness 的缩写，CPU 消耗在 nice 进程（低优先级）的时间百分比id：idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙wa：wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个值太高就说明外部设备有问题hi：hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比si：software interrupt 的缩写，CPU 响应软件中断请求的时间百分比st：stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"ArrayList和LinkedList有什么区别","slug":"ArrayList和LinkedList有什么区别","date":"2020-02-27T09:00:12.000Z","updated":"2020-02-27T09:03:51.250Z","comments":true,"path":"2020/02/27/ArrayList和LinkedList有什么区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"区别 LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列，栈（可以参见Deque提供的接口方法）和List集合使用，功能强大。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 使用场景 如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象； 如果应用程序有更多的插入或者删除操作，较少的数据读取，LinkedList对象要优于ArrayList对象； 不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"final，finally，finalize的区别","slug":"final，finally，finalize的区别","date":"2020-02-27T08:31:46.000Z","updated":"2020-02-27T08:57:27.919Z","comments":true,"path":"2020/02/27/final，finally，finalize的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.简单区别： final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。 2.中等区别： final：java中的关键字，修饰符。 如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。 如果将变量或者方法声明为final，可以保证它们在使用中不被改变. 1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 2)被声明final的方法只能使用，不能重载。 finally：java的一种异常处理机制。 finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。 finalize：Java中的一个方法名。Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 3.详细区别：final定义变量 第一种情况：如果final修饰的是一个基本类型，就表示这个变量被赋予的值是不可变的，即它是个常量；如果final修饰的是一个对象，就表示这个变量被赋予的引用是不可变的这里需要提醒大家注意的是，不可改变的只是这个变量所保存的引用，并不是这个引用所指向的对象。 第二种情况：final的含义与第一种情况相同。实际上对于前两种情况，一种更贴切的表述final的含义的描述，那就是，如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化。初始化的方式以下几种：1.在定义的时候初始化。2.final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。3.静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，不可以在初始化块中初始化。4.final变量还可以在类的构造器中初始化，但是静态final变量不可以。 定义方法当final用来定义一个方法时，它表示这个方法不可以被子类重写，但是并不影响它被子类继承。定义类​ final类不允许被继承，编译器在处理时把它的所方法都当作final的，因此final类比普通类拥更高的效率。而由关键字abstract定义的抽象类含必须由继承自它的子类重载实现的抽象方法，因此无法同时用final和abstract来修饰同一个类。同样的道理，final也不能用来修饰接口。 final的类的所方法都不能被重写，但这并不表示final的类的属性（变量值也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰 finally语句​ finally只能用在try/catch语句中并且附带着一个语句块，表示这段语句最终总是被执行 。 finalize方法​ 它是一个方法，属于java.lang.Object类，它的定义如下： 1protected void finalize()throws Throwable&#123;&#125; ​ 众所周知，finalize()方法是GC （garbagecollector）运行机制的一部分,在此我们只说说finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception），GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"进程和线程的区别","slug":"进程和线程的区别","date":"2020-02-27T08:04:55.000Z","updated":"2020-02-27T08:22:29.252Z","comments":true,"path":"2020/02/27/进程和线程的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"概念《系统架构师》一书中给出的定义是： 进程（process）是资源分配和独立运行的基本单位。研究操作系统的进程，实质是研究系统中诸多进程之间的并发特性以及进程之间的相互制约性。 线程是进程中的一个实体，是被系统独立分配和调度的基本操作单位。具有就绪、运行、阻塞三种状态。 一个进程有若干个线程，线程只拥有一些运行中必不可少的资源，它可与同一个进程的其他线程共享进程所拥有的的全部资源。线程可创建另外一个线程，同一个进程中的多个线程可并发执行。 Linux中的概念 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。 123456789101112131415# -*- coding:utf-8 -*-import osprint('当前进程:%s 启动中 ....' % os.getpid())pid = os.fork()if pid == 0: print('子进程:%s,父进程是:%s' % (os.getpid(), os.getppid()))else: print('进程:%s 创建了子进程:%s' % (os.getpid(),pid )) 输出结果：当前进程:27223 启动中 ....进程:27223 创建了子进程:27224子进程:27224,父进程是:27223 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 区别和优劣 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 参考书籍《Unix网络编程》","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"泛型中extends和super的区别","slug":"泛型中extends和super的区别","date":"2020-02-27T07:35:59.000Z","updated":"2020-02-27T07:58:34.700Z","comments":true,"path":"2020/02/27/泛型中extends和super的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"释义：在非泛型中： extends：让一个类继承另外一个类； super：指向父类对象的引用； 在泛型中： extends也成为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。 super也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。 看如下代码： 123456789101112131415161718192021222324252627public class Food &#123;&#125;public class Fruit extends Food &#123;&#125;public class Apple extends Fruit &#123;&#125;public class Banana extends Fruit&#123;&#125;public class GenericTest &#123;public void testExtends(List&lt;? extends Fruit&gt; list)&#123; //报错,extends为上界通配符,只能取值,不能放. //因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错 //list.add(new Apple()); //可以正常获取 Fruit fruit = list.get(1);&#125;public void testSuper(List&lt;? super Fruit&gt; list)&#123; //super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲， //无法确定Fruit的父类是否只有Food一个(Object是超级父类) //因此放入Food的实例编译不通过 list.add(new Apple()); // list.add(new Food()); Object object = list.get(1); &#125;&#125; 在testExtends方法中，因为泛型中用的是extends，在向list中存放元素的时候，我们并不能确定List中的元素的具体类型，即可能是Apple也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。 理解了extends之后，再看super就很容易理解了，即我们不能确定testSuper方法的参数中的泛型是Fruit的哪个父类，因此在调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。 总结：在使用泛型时，存取元素时用super,获取元素时，用extends。 扩展： 通配符 ? 使用 在泛型中的通配符就是一个问号，标准叫法是无界通配符，它一般使用在参数或变量的声明上 1234567891011121314 // 在参数中使用无界通配符 public static void test(List&lt;?&gt; list) &#123; Object o = list.get(1);&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); // 在变量声明中使用无界通配符 List&lt;?&gt; list2 = list1; test(list1); test(list2);&#125; 泛型中使用无界通配符，表示泛型可以是任意具体的类型，没有限制（基本数据类型除外，基本数据类型不能用作泛型，可以使用基本数据类型的包装类）； 所以无界通配符给人的感觉就和原生的类型没什么区别，比如就上面这段代码，使用List&lt;?&gt;，和直接使用List，好像是一样的；但是实际上还是有一些区别的，比如看下面这段代码: 1234567891011121314151617181920212223 // 在参数中使用无界通配符 public static void test1(List&lt;?&gt; list) &#123; // 均编译错误，因为使用了无界通配符，编译器无法确定具体是什么类型 // list.add(1111); // list.add(\"aaa\"); // list.add(new Object());&#125;// 在参数中使用原生Listpublic static void test2(List list) &#123; // 编译通过，不加泛型时，编译器默认为Object类型 list.add(1111); list.add(\"aaa\"); list.add(new Object());&#125;public static void main(String[] args) &#123; // 声明两个泛型明确的list集合 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 调用使用了&lt;？&gt;的方法 test1(list1); test2(list2);&#125; List：表示可以存储任意Object类型的集合； List：表示一个存储某种特定类型的List集合，但是不知道这种特定类型是什么；","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"String，Stringbuffer，StringBuilder的区别","slug":"String，Stringbuffer，StringBuilder的区别","date":"2020-02-27T07:16:10.000Z","updated":"2020-02-27T07:19:07.092Z","comments":true,"path":"2020/02/27/String，Stringbuffer，StringBuilder的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"String string类是不可变的：创建一个String对象之后，任何对这个对象的改变都会引起一个新的String对象生成。 123String str =\"abc\";str = str +\"def\";//这一步jvm会再次创建一个String对象 第二次其实jvm又生成了一个String类，而不是直接覆盖原来的”abc”，因此我们说String类是不可改变类。这一种特性会带来一个问题，每次拼接都要创建都要创建一次对象，当我们要拼接大量字符串的时候，效率会变得非常非常慢。 StringBuffer StringBuffer 不同于String的是，stringbuffer 是可变的， 123StringBuffer sb =new StringBuffer(\"abc\"); sb.append(\"efg\");//并没有创建一个新的对象 这里第二步并没有产生一个新的对象，而是在原来的基础上追加字符串，这种方式在拼接字符串的时候效率肯定比String要高得多。 StringBuilderStringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 total:1.如果要操作少量的数据用 String 2.单线程操作字符串缓冲区下操作大量数据用StringBuilder 3.多线程操作字符串缓冲区下操作大量数据用StringBuffer","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java中的可变对象与不可变对象","slug":"Java中的可变对象与不可变对象","date":"2020-02-27T06:59:24.000Z","updated":"2020-02-27T07:09:51.291Z","comments":true,"path":"2020/02/27/Java中的可变对象与不可变对象/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"不可变对象 （Immutable Objects）​ 对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。 ​ 不可变对象的类即为不可变类(Immutable Class)。JAVA平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等 . 可变对象(Mutable Objects)​ 相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。 编写不可变类 1.确保类不能被继承：将类声明为final, 或者使用静态工厂并声明构造器为private 使用private和final修饰符来修饰该类的属性 如果成员属性为可变对象属性，不要使这些对象改变： 1）不要提供更改可变对象的方法 2）不要共享对可变对象的引用，不要存储传给构造器的外部可变对象的引用。因为引用可变对象的成员变量和外部可变对象的引用指向同一块内存地址，用户可以在不可变类之外通过修改可变对象的值 为了保证内部的值不被修改，可以采用深度拷贝的方法来复制一个对象并传入副本的引用来确保类的不可变 1234567891011public final class MyImmutableDemo &#123; private final int[] myArray; public MyImmutableDemo(int[] array) &#123; this.myArray = array.clone(); &#125; &#125; C. 不要提供任何可以修改对象状态的方法（不仅仅是set方法, 还有任何其它可以改变状态的方法） 不可变对象的优缺点优点* 构造、测试和使用都很简单 * 不可变对象是线程安全的，在线程之间可以相互共享，不需要利用特殊机制来保证同步问题，因为对象的值无法改变。可以降低并发错误的可能性，因为不需要用一些锁机制等保证内存一致性问题也减少了同步开销。 * 不可变对象可以被重复使用，可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。可以使用静态工厂方法来提供类似于valueOf()这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。 缺点 * 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象,制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，会创造很多的垃圾，给垃圾收集带来很大的麻烦 参考：https://blog.csdn.net/bupa900318/article/details/80696785","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2020-02-27T06:06:01.000Z","updated":"2020-02-27T07:43:41.584Z","comments":true,"path":"2020/02/27/接口和抽象类的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"抽象类1abstract ​ 抽象类必须用abstract 修饰，子类必须实现抽象类中的抽象方法，如果有方法未实现，那么子类的该方法也要用abstract 修饰。 ​ 默认的权限修饰符是：public，也可以是procted.如果是private的话，子类无法继承。 ​ 抽象类无法创建对象。 接口1interface ​ 接口中的变量隐式的使用Public static final 修饰，也要给出初始值 ​ 接口中的方法隐式的使用public abstract 修饰，只能是public 修饰。 ​ 接口中的方法默认的不能有实现（JDK1.8可以有默认实现）。 抽象类和接口的区别 抽象类只能继承一次，但是可以有多个接口。 继承于抽象类或者接口的类，必须实现其中的所有方法，抽象类中的为实现的抽象方法，子类也需要定义为抽象类。 抽象类可以有非抽象方法。 接口的变量必须由public static final 修饰，并给出初始值，所以其实现类不能重新定义，也不能改变其值。 接口的方法默认是public abstract ，不能是static，抽象类中可以有static方法。 接口的方法也不允许子类覆写。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"抽象类的意义","slug":"抽象类的意义","date":"2020-02-27T05:53:43.000Z","updated":"2020-02-27T06:07:43.236Z","comments":true,"path":"2020/02/27/抽象类的意义/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89/","excerpt":"","text":"抽象类的意义最主要的：对代码的维护和重用。 关键字 1abstract 1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护 2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。 ​ 实际写代码的过程中，如果想要对某一个接口进行默认实现，并且不希望在该实现类 上创建实例，那么抽象类是一个不错地选择。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"int与Integer的区别","slug":"int与Integer的区别","date":"2020-02-27T05:13:32.000Z","updated":"2020-02-27T05:34:38.327Z","comments":true,"path":"2020/02/27/int与Integer的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/int%E4%B8%8EInteger%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"int1int 是java的基本数据类型。 Integer1Integer 继承了Object类，是对象类型，是 int 的包装类。 int 与 Integer 的区别1,值的储存​ int储存在栈中 ​ Integer对象的引用储存在栈中，对象的数据储存在堆中。 2,初始化​ int初始值是0 ​ Integer的初始值是null 3,传参​ int是值传递 ​ Integer是引用传递，引用不可改变但是引用指向堆空间地址的值是可以改变的。 4,泛型支持​ 泛型不支持int，但是支持Integer。 5,运算​ int 可以直接做运算，是类的特性。​ Integer 的对象可以调用该类的方法，但是在拆箱之前不能进行运算，需要转化为基本类型int。 相同值下的 int 和 Integer 的比较结果​ 1,两个通过new生成的变量，结果为false。​ 2,int 和 Integer 的值比较，若两者的值相等，则为true。​ （注意：在比较时，Integer会自动拆箱为int类型，然后再做比较。）​ 3,new 生成的Integer变量 和 非new 生成的Integer变量比较，，结果为false。​ （注意：new 生成的Integer变量的值在堆空间中，非new 生成的Integer变量的值在在常量池中。）​ （注意：非new生成的Integer变量，会先判断常量池中是否有该对象，若有则共享，若无则在常量池中放入 该对象；也叫享元模式，后面再说。）​ 4,两个非new 生成的Integer对象比较，则结果为true。​ （注意：此处需要一个前提：值的范围在 -128 ~ 127 之间。​ 涉及到java对 int 与 Integer 的自动装箱和拆箱的一种模式：享元模式—flyweight，为了加强对简单数字的重 复利用。​ 在赋值时，其实是执行了Integer的valueOf()方法。​ 当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在 缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。​ 当值超出此范围，会在堆中new出一个对象来存储。​ PS：自动装箱与拆箱是在JDK1.5中出现的。 12345678910111213141516public static void main(String[] args) &#123; int a =12; Integer b =12; Integer c = new Integer(12); Integer d=128; Integer e=128; System.out.println(a==b); System.out.println(b==c); System.out.println(d==e); &#125;truefalsefalse ​ 5,内部类IntegerCache​ 通过此类可以缓存简单数字。​ 缓存的数大小可以由 -XX：AutoBoxCacheMax = 控制。​ jvm初始化时，java.lang.Integer.Integ","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java==和equals和hashCode的区别","slug":"Java中==和equals和hashCode的区别","date":"2020-02-27T02:00:49.000Z","updated":"2020-02-27T08:54:31.546Z","comments":true,"path":"2020/02/27/Java中==和equals和hashCode的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD==%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Java中==和equals和hashCode的区别1，==1, 基础类型：byte,short,char,int,double,boolean,float ​ 他们之间用“==”，比较的是他们的值 2, 引用类型（类，接口，数组） ​ 使用“==”进行比较的时候，比较的是内存地址 12345678910111213141516public static void main(String[] args) &#123; String str1 = new String(\"str\"); String str2 = new String(\"str\"); System.out.println(\"str1==str2:\" + (str1 == str2)); String str3=\"str\"; String str4=\"str\"; System.out.println(str3 == str4); System.out.println(System.identityHashCode(str1)); System.out.println(System.identityHashCode(str2)); System.out.println(System.identityHashCode(str3)); System.out.println(System.identityHashCode(str4)); &#125; 结果为 str1==str2:falsetrue323247493111501236338603633860 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见’==’是对栈中的值进行比较的。如果要比较堆 中对象的内容是否相同，那么就要重写equals方法了。 但是这行代码，128！=128，a!=b 123456Integer a1 = 127;Integer b1 = 127;Integer a = 128;Integer b = 128;System.out.println(a1==b1);System.out.println(a==b); 结果 true false 去看Integer的源码可以明白，是这段源码 12345678910111213141516171819202122232425262728293031323334private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; Integer对于 对于-128到127之间的数，会进行缓存 。 2，equals() 1,默认没有重新的情况下，都调用的是Objects 的equals（）的方法，源码如下： 1public boolean equals(Object obj) &#123; return (this == obj);&#125; ​ 可以看到是Objects中的equal（）方法和== 是等同的。 2，日常的代码中会覆盖equal() 方法，下面是string 类 重写的equal（）方法 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; ​ 逻辑很明显： ​ 内存地址相同，直接返回true ​ 比较对象是String类型，直接返回false ​ a和b长度不同，直接返回false ​ 逐个字符比较，有不同就返回false equal重写注意的五个原则​ 1 自反性：对任意引用值X，x.equals(x)的返回值一定为true.​ 2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;​ 3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true​ 4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变​ 5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 3，hashCodeObjects给出的hashCode（）的原生代码是： 1public native int hashCode(); 返回时的一个int 类型的数值。 下面是引用摘抄的 ======================================================================================= hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。 散列函数,散列算法,哈希函数。是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。好的散列函数在输入域中很少出现散列冲突。 ====================================================================================== hashCode的作用想要明白，必须要先知道Java中的集合。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。 这样一来，当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 4、eqauls方法和hashCode方法关系Java对于eqauls方法和hashCode方法是这样规定的： (1)同一对象上多次调用hashCode()方法，总是返回相同的整型值。 (2)如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。(3)如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 (4)a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 (5)a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。2、如果两个对象不equals，他们的hashcode有可能相等。3、如果两个对象hashcode相等，他们不一定equals。4、如果两个对象hashcode不相等，他们一定不equals。 关于这两个方法的重要规范：规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 5、为什么覆盖equals时总要覆盖hashCode 一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 2.如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 3.如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 6、总结：1、equals方法用于比较对象的内容是否相等（覆盖以后） 2、hashcode方法只有在集合中用到 3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。 4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 以上从第四点以后转载至博客：https://blog.csdn.net/hla199106/article/details/46907725","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"写于博客之始","slug":"写于博客之始","date":"2020-02-26T10:00:08.000Z","updated":"2020-02-27T07:36:23.335Z","comments":true,"path":"2020/02/26/写于博客之始/","link":"","permalink":"https://liudong-code.github.io/2020/02/26/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%A7%8B/","excerpt":"","text":"​ 重新整理了之前的旧的博客，发现有部分博客有老东家的Code，想起来之前有同事因无意中泄露了公司的淘宝三段码，而受到处罚，索性就新搞了一个新的博客 地址，这几天正好因为疫情在家里面，找工作也不是很好找，就把之前的整理的东西全部搞过来。新的博客只弄了主题，其他的细节都还没整，想的是尽快的把日常干货先给弄上来。嗯，就这些吧！ ​","categories":[],"tags":[{"name":"日常随笔","slug":"日常随笔","permalink":"https://liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"keywords":[]}]}