{"meta":{"title":"code","subtitle":"码总","description":"JVM相关，Spring，SpringBoot,SpringCloud,SpringMvc,Redis,Kafka,RabbitMQ,EleasticSearch","author":"Liu Dong","url":"https://liudong-code.github.io"},"pages":[{"title":"categories","date":"2020-02-20T02:52:59.000Z","updated":"2020-02-20T03:43:51.276Z","comments":true,"path":"categories/index.html","permalink":"https://liudong-code.github.io/categories/index.html","excerpt":"","text":"type: “categories” # 将页面的类型设置为 categories ，主题将自动为这个页面显示所有分类comments: true # 如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，设置为 false 这里也有 “—“"}],"posts":[{"title":"throw和throws的区别","slug":"throw和throws的区别","date":"2020-02-29T11:12:48.000Z","updated":"2020-02-29T11:18:05.497Z","comments":true,"path":"2020/02/29/throw和throws的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"抛出异常有三种形式 throw throws 系统自动抛异常 一、系统自动抛异常 当程序语句出现一些逻辑错误、主义错误或类型转换错误时，系统会自动抛出异常：（举个栗子） 12345public static void main(String[] args) &#123; int a = 5, b =0; System.out.println(5/b); // 此处系统会自动抛出ArithmeticException异常 //function(); &#125; 二、throw throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常 123456789public static void main(String[] args) &#123; String s = \"abc\"; if(s.equals(\"abc\")) &#123; throw new NumberFormatException(); &#125; else &#123; System.out.println(s); &#125; //function(); &#125; 运行时，系统会抛出如下异常： 1Exception in thread \"main\" java.lang.NumberFormatException at...... 三、throws 12345678910111213141516当某个方法可能会抛出某种异常时用于throws 声明可能抛出的异常，然后交给上层调用它的方法程序处理public class testThrows()&#123;public static void function() throws NumberFormatException &#123; String s = \"abc\"; System.out.println(Double.parseDouble(s)); &#125; public static void main(String[] args) &#123; try &#123; function(); &#125; catch (NumberFormatException e) &#123; System.err.println(\"非数据类型不能强制类型转换。\"); //e.printStackTrace(); &#125; &#125; 四、throw与throws的比较 throws出现在方法函数头；而throw出现在函数体。throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 五、编程习惯： 在写程序时，对可能会出现异常的部分通常要用try{…}catch{…}去捕捉它并对它进行处理；用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();用try{…}catch{…}捕捉了异常之后一定要对在catch{…}中对其进行处理，那怕是最简单的一句输出语句，或栈输入e.printStackTrace();如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果是捕捉IO输入输出流中的异常，一定要在try{…}catch{…}后加finally{…}把输入输出流关闭；如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理。如果在函数体内用throw抛出了某种异常，最好要在函数名中加throws抛异常声明，然后交给调用它的上层函数进行处理 原文链接：https://blog.csdn.net/xsj_blog/article/details/83030450 原文链接：https://blog.csdn.net/xsj_blog/article/details/83030450","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"java中的异常链","slug":"java中的异常链","date":"2020-02-29T11:07:08.000Z","updated":"2020-02-29T11:11:28.590Z","comments":true,"path":"2020/02/29/java中的异常链/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/java%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E9%93%BE/","excerpt":"","text":"概念​ 把捕获的异常包装成一个新的异常，在新的异常中添加对新的异常的引用，再把新异常抛出，就像是链式反应一样，这种就叫异常链。 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args)&#123; ChainTest ct=new ChainTest();//创建chainTest实例 try&#123; ct.test2(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125;public void test1()throws DrunkException&#123; throw new DrunkException(\"喝车别开酒\");&#125;public void test2()&#123; try&#123; test1();&#125;catch (DrunkException e)&#123; RuntimeException newExc=new RuntimeException(\"司机一滴酒亲人两行泪\")；//含参构造器 newExc.initCause(e);//调用newExc的init方法，把捕获的DrunkException传进去 throw newExc;//抛出新异常 &#125;&#125;","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java的异常体系","slug":"Java的异常体系","date":"2020-02-29T10:54:18.000Z","updated":"2020-02-29T11:05:32.069Z","comments":true,"path":"2020/02/29/Java的异常体系/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/Java%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB/","excerpt":"","text":"java中异常的体系结构图解： ​ java中的Exception类的子类不仅仅只是像上图所示只包含IOException和RuntimeException这两大类，事实上Exception的子类很多很多，主要可概括为：运行时异常与非运行时异常。 java异常体系结构​ Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系： 1、Error与Exception Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。2、运行时异常和非运行时异常 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 异常的捕获和处理try、catch、finally 第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。 第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。 第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。 第四：先Catch子类异常再Catch父类异常。 throw、throws关键字throw关键字是用于方法体内部，用来抛出一个Throwable类型的异常。如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。throw关键字用法如下： 123public static void test() throws Exception &#123; throw new Exception(\"方法test中的Exception\"); &#125;","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"如何格式化日期","slug":"如何格式化日期","date":"2020-02-29T10:42:07.000Z","updated":"2020-02-29T10:45:36.276Z","comments":true,"path":"2020/02/29/如何格式化日期/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F/","excerpt":"","text":"1234DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate localDate = LocalDate.now(); String date = localDate.format(dateTimeFormatter); System.out.println(\"date:\"+date)； 补充:java的时间日期API一直以来都是被诟病的东西,为了解决这一问题,java8中引入了新的时间日期API,其中包括LocalDate,LocalTime,LocalDate,LocalDateTime,Clock,Instant等类,这些的类的设计都使用了不变模式,因此是线程安全的设计. 原文链接：https://blog.csdn.net/riju4713/article/details/88220120","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://liudong-code.github.io/tags/Java/"}],"keywords":[]},{"title":"静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？","slug":"静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？","date":"2020-02-29T10:35:58.000Z","updated":"2020-02-29T10:38:33.433Z","comments":true,"path":"2020/02/29/静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E5%86%99%EF%BC%9F%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F/","excerpt":"","text":"可以被继承，代码如下123456789101112131415161718192021222324252627public class One &#123; //静态属性和静态方法是否可以被继承？ public static String one_1 = \"one\"; public static void oneFn() &#123; System.out.println(\"oneFn\"); &#125;&#125;public class Two extends One&#123; //空&#125;public class MyTest &#123; //静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ public static void main(String[] args) &#123; One one = new Two(); one.oneFn(); String one_1 = One.one_1; System.out.println(\"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_1); String one_12 = one.one_1; System.out.println(\"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_12); &#125;&#125;//打印结果如下oneFnOne.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;oneone.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one 不能被重写，代码如下123456789101112131415161718192021222324252627282930313233public class One &#123; //静态属性和静态方法是否可以被重写？以及原因？ public static String one_1 = \"one\"; public static void oneFn() &#123; System.out.println(\"oneFn\"); &#125;&#125;public class Two extends One &#123; public static String one_1 = \"two\"; public static void oneFn() &#123; System.out.println(\"TwoFn\"); &#125;&#125;public class MyTest &#123; //静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？ public static void main(String[] args) &#123; One one = new Two(); one.oneFn(); String one_1 = One.one_1; System.out.println(\"One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_1); String one_12 = one.one_1; System.out.println(\"one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+one_12); &#125;&#125;//打印结果如下//oneFn//One.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one//one.one_1&gt;&gt;&gt;&gt;&gt;&gt;&gt;one 原因static修饰函数/变量时，其实是全局函数/变量，它只是因为java强调对象的要挂，它与任何类都没有关系。靠这个类的好处就是这个类的成员函数调用static方法不用带类名。 注意：static关键字可以用修饰代码块.static代码块可以置于类中的任何一个位置，并可以有多个static代码块。在类初次被加载时，会按照静态代码块的顺序来执行，并且只会执行一次。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"string转换成integer的方式及原理","slug":"string转换成integer的方式及原理","date":"2020-02-29T10:04:02.000Z","updated":"2020-02-29T10:23:45.563Z","comments":true,"path":"2020/02/29/string转换成integer的方式及原理/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/string%E8%BD%AC%E6%8D%A2%E6%88%90integer%E7%9A%84%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/","excerpt":"","text":"string转换成integer的方式及原理1. Integer.parseInt（String str）方法​ 源码如下 123public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125; 2. Integer.parseInt（String s, int radix）方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public static int parseInt(String s, int radix) throws NumberFormatException&#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException(\"null\"); &#125; //基数是否小于最小基数 if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException(\"radix \" + radix + \" less than Character.MIN_RADIX\"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException(\"radix \" + radix + \" greater than Character.MAX_RADIX\"); &#125; int result = 0; //是否是负数 boolean negative = false; int i = 0, len = s.length(); //最大值限制 int limit = -Integer.MAX_VALUE; int multmin; int digit; //判断字符长度是否大于0，否则抛出异常 if (len &gt; 0) &#123; //第一个字符是否是符号 char firstChar = s.charAt(0); //根据ascii码表看出加号(43)和负号(45)对应的 //十进制数小于‘0’(48)的 if (firstChar &lt; '0') &#123; // Possible leading \"+\" or \"-\" //是负号 if (firstChar == '-') &#123; //负号属性设置为true negative = true; limit = Integer.MIN_VALUE; //不是负号也不是加号则抛出异常 &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); //如果有符号（加号或者减号）且字符串长度为1，则抛出异常 if (len == 1) // Cannot have lone \"+\" or \"-\" throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE //此方法为确定数字的的十进制值 digit = Character.digit(s.charAt(i++),radix); //小于0，则为非数值字符串 if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; //result第一次为0，第一次肯定为true if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; //result乘以基数（10）为得到位置 //例如第一次的result为-1，第二次乘以10后为-10 //下面再-=digit（例如：1）则得到-11 //以此类推 result *= radix; if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; //第一次result为0 -=digit则为负值的该digit result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; //根据上面得到的是否负数，返回相应的值 return negative ? result : -result; &#125; 3.Character.digit(char ch, int radix)方法12345678910111213141516171819202122232425262728public static int digit(int codePoint, int radix) &#123; //基数必须再最大和最小基数之间 if (radix &lt; MIN_RADIX || radix &gt; MAX_RADIX) &#123; return -1; &#125; if (codePoint &lt; 128) &#123; // Optimized for ASCII int result = -1; //字符在0-9字符之间 if ('0' &lt;= codePoint &amp;&amp; codePoint &lt;= '9') &#123; result = codePoint - '0'; &#125; //字符在a-z之间 else if ('a' &lt;= codePoint &amp;&amp; codePoint &lt;= 'z') &#123; result = 10 + (codePoint - 'a'); &#125; //字符在A-Z之间 else if ('A' &lt;= codePoint &amp;&amp; codePoint &lt;= 'Z') &#123; result = 10 + (codePoint - 'A'); &#125; //通过判断result和基数大小，输出对应值 //通过我们parseInt对应的基数值为10， //所以，只能在第一个判断（字符在0-9字符之间） //中得到result值 否则后续程序会抛出异常 return result &lt; radix ? result : -1; &#125; return digitImpl(codePoint, radix); &#125; 总结：integer.parseInt(string str)方法调用Integer内部的 parseInt(string str,10)方法,默认基数为10，parseInt内部首先 判断字符串是否包含符号（-或者+），则对相应的negative和limit进行 赋值，然后再循环字符串，对单个char进行数值计算Character.digit(char ch, int radix) 在这个方法中，函数肯定进入到0-9字符的判断（相对于string转换到int）， 否则会抛出异常，数字就是如上面进行拼接然后生成的int类型数值。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"序列化的方式","slug":"序列化的方式","date":"2020-02-29T03:23:06.000Z","updated":"2020-02-29T09:53:38.621Z","comments":true,"path":"2020/02/29/序列化的方式/","link":"","permalink":"https://liudong-code.github.io/2020/02/29/%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"","text":"概念序列化：将对象转化成一个字节序列，便于储存。 反序列化：将字节化的字节序列还原。 优点：可以实现对象的”持久性”， 所谓持久性就是指对象的生命周期不取决于程序。 序列化的几种方式Java原生的序列化**序列化需要：** 所需类：ObjectInputStream和ObjectOutputStream 方法： readObject()和writeObject(); 隐式序列化​ 实现Serializabie接口，通过实现Serializable接口，这种是隐式序列化(不需要手动)，这种是最简单的序列化方式，会自动序列化所有非static和 transient关键字修饰的成员变量。 ​ 12345678910111213141516171819202122232425262728public class IpConfig &#123; private String name; private int age; public static int virualAge = 123; private transient String ipAdress =\"127.0.0.1\"; public IpConfig(String name, int i) &#123; this.name=name; this.age=i; &#125; public String toString() &#123; return \"name: \" + name + \"\\n\" +\"age: \" + age + \"\\n\" +\"virualAge: \" + virualAge + \"\\n\" + \"ipAdress: \" + ipAdress; &#125; public void SetAge(int age) &#123; this.age = age; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public class test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //创建可序列化对象 System.out.println(\"原来的对象：\"); IpConfig ipConfig = new IpConfig(\"Ming\", 16); System.out.println(ipConfig); //创建序列化输出流 ByteArrayOutputStream outputStream=new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream=new ObjectOutputStream(outputStream); //将序列化对象存入缓冲区 objectOutputStream.writeObject(ipConfig); //改值 ipConfig.SetAge(11); IpConfig.virualAge=5555; //从缓冲区取回被序列化的对象 ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(outputStream.toByteArray())); IpConfig newIpconfig = (IpConfig) in.readObject(); System.out.println(\"序列化后取出的对象：\"); System.out.println(newIpconfig); &#125;&#125;原来的对象：name: Mingage: 16virualAge: 123address: 127.0.0.1序列化后取出的对象：name: Mingage: 16virualAge: 5555address: null ​ 发现ipAddress(被transient)和virualAge(被static)也没有被序列化，中途修改virualAge的值是为了以防读者误会virualAge被序列化了。因为序列化可以保存对象的状态，但是virualAge的值被改变了，说明没有被序列化。static成员不属于对象实例，可能被别的对象修改没办法序列化,序列化是序列对象。对于address被反序列化后由于没有对应的引用，所以为null。而且Serializable不会调用构造方法。 显式序列化​ 实现Externalizable接口 ​ Externalizable接口继承自Serializable, 我们在实现该接口时，必须实现writeExternal()和readExternal()方法，而且只能通过手动进行序列化，并且两个方法是自动调用的，因此，这个序列化过程是可控的，可以自己选择哪些部分序列化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Blip implements Externalizable&#123; private int i ; private String s; public Blip() &#123;&#125; public Blip(String x, int a) &#123; System.out.println(\"Blip (String x, int a)\"); s = x; i = a; &#125; public String toString() &#123; return s+i; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; // TODO Auto-generated method stub System.out.println(\"Blip.writeExternal\"); out.writeObject(s); out.writeInt(i); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; // TODO Auto-generated method stub System.out.println(\"Blip.readExternal\"); s = (String)in.readObject(); i = in.readInt(); &#125; public static void main(String[] args) throws FileNotFoundException, IOException, ClassNotFoundException &#123; System.out.println(\"Constructing objects\"); Blip b = new Blip(\"A Stirng\", 47); System.out.println(b); ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(\"F://Demo//file1.txt\")); System.out.println(\"保存对象\"); o.writeObject(b); o.close(); //获得对象 System.out.println(\"获取对象\"); ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"F://Demo//file1.txt\")); System.out.println(\"Recovering b\"); b = (Blip)in.readObject(); System.out.println(b); &#125;&#125;打印结果为：Constructing objectsBlip (String x, int a)A Stirng47保存对象Blip.writeExternal获取对象Recovering bBlip.readExternalA Stirng47当注释掉writeExternal和readExternal方法后打印结果为:Constructing objectsBlip (String x, int a)A Stirng47保存对象Blip.writeExternal获取对象Recovering bBlip.readExternalnull0 说明：Externalizable类会调用public的构造函数先初始化对象，在调用所保存的内容将对象还原。假如构造方法不是public则会出现运行时错误。 显式+隐式的实现​ 如果想将方式一和方式二的优点都用到的话，可以采用方式三， 先实现Serializable接口，并且添加writeObject()和readObject()方法。注意这里是添加，不是重写或者覆盖。但是添加的这两个方法必须有相应的格式。 1，方法必须要被private修饰 —–&gt;才能被调用2，第一行调用默认的defaultRead/WriteObject(); —–&gt;隐式序列化非static和transient3，调用read/writeObject()将获得的值赋给相应的值 —&gt;显式序列化 123456789101112131415161718192021222324252627282930313233343536373839public class SerDemo implements Serializable&#123; public transient int age = 23; public String name ; public SerDemo()&#123; System.out.println(\"默认构造器。。。\"); &#125; public SerDemo(String name) &#123; this.name = name; &#125; private void writeObject(ObjectOutputStream stream) throws IOException &#123; stream.defaultWriteObject(); stream.writeInt(age); &#125; private void readObject(ObjectInputStream stream) throws ClassNotFoundException, IOException &#123; stream.defaultReadObject(); age = stream.readInt(); &#125; public String toString() &#123; return \"年龄\" + age + \" \" + name; &#125;public static void main(String[] args) throws IOException, ClassNotFoundException &#123; SerDemo stu = new SerDemo(\"Ming\"); ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bout); out.writeObject(stu); ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bout.toByteArray())); SerDemo stu1 = (SerDemo) in.readObject(); System.out.println(stu1); &#125;&#125;打印结果为：年龄23 Ming注释掉stream.writeInt(age)和age= stream.readInt()后：年龄0 Ming方式三结合了显式和隐式序列化，Ming被正常序列化，由于age被trancient修饰，所以需要显式序列化。 Json序列化​ Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。现在的大多数公司都将json作为服务器端返回的数据格式。比如调用一个服务器接口，通常的请求为xxx.json?a=xxx&amp;b=xxx的形式。Json序列化示例代码如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package serialize;import java.io.IOException;import java.util.ArrayList;import java.util.List;import com.fasterxml.jackson.databind.ObjectMapper;public class JsonSerialize &#123; public static void main(String[] args) throws IOException &#123; new JsonSerialize().start(); &#125; public void start() throws IOException &#123; User u = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u.setUserName(\"张三\"); u.setPassWord(\"123456\"); u.setUserInfo(\"张三是一个很牛逼的人\"); u.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); ObjectMapper mapper = new ObjectMapper(); Long t1 = System.currentTimeMillis(); byte[] writeValueAsBytes = null; for (int i = 0; i &lt; 10; i++) &#123; writeValueAsBytes = mapper.writeValueAsBytes(u); &#125; System.out.println(\"json serialize: \" + (System.currentTimeMillis() - t1) + \"ms; 总大小：\" + writeValueAsBytes.length); Long t2 = System.currentTimeMillis(); User user = mapper.readValue(writeValueAsBytes, User.class); System.out.println(\"json deserialize: \" + (System.currentTimeMillis() - t2) + \"ms; User: \" + user); &#125;&#125; 12json serialize: 55ms; 总大小：341json deserialize: 35ms; User: User [userId=null, userName=张三, passWord=123456, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=123456, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=123456, userInfo=王五是一个很牛逼的人, friends=null]]] FastJson序列化​ fastjson 是由阿里巴巴开发的一个性能很好的Java 语言实现的 Json解析器和生成器。特点：速度快，测试表明fastjson具有极快的性能，超越任其他的java json parser。功能强大，完全支持java bean、集合、Map、日期、Enum，支持范型和自省。无依赖，能够直接运行在Java SE 5.0以上版本支持Android。使用时候需引入FastJson第三方jar包。FastJson序列化代码示例如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package serialize;import java.util.ArrayList;import java.util.List;import com.alibaba.fastjson.JSON;/** * * @author liqqc * */public class FastJsonSerialize &#123; public static void main(String[] args) &#123; new FastJsonSerialize().start(); &#125; public void start()&#123; User u = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u.setUserName(\"张三\"); u.setPassWord(\"123456\"); u.setUserInfo(\"张三是一个很牛逼的人\"); u.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); //序列化 Long t1 = System.currentTimeMillis(); String text = null; for(int i = 0; i&lt;10; i++) &#123; text = JSON.toJSONString(u); &#125; System.out.println(\"fastJson serialize: \" +(System.currentTimeMillis() - t1) + \"ms; 总大小：\" + text.getBytes().length); //反序列化 Long t2 = System.currentTimeMillis(); User user = JSON.parseObject(text, User.class); System.out.println(\"fastJson serialize: \" + (System.currentTimeMillis() -t2) + \"ms; User: \" + user); &#125;&#125; ProtoBuff序列化1234567ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。 参考地址： https://github.com/google/protobuf。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package serialize;import java.io.Serializable;import java.util.List;import com.baidu.bjf.remoting.protobuf.FieldType;import com.baidu.bjf.remoting.protobuf.annotation.Protobuf;public class User implements Serializable &#123; private static final long serialVersionUID = -7890663945232864573L; @Protobuf(fieldType = FieldType.INT32, required = false, order = 1) private Integer userId; @Protobuf(fieldType = FieldType.STRING, required = false, order = 2) private String userName; @Protobuf(fieldType = FieldType.STRING, required = false, order = 3) private String passWord; @Protobuf(fieldType = FieldType.STRING, required = false, order = 4) private String userInfo; @Protobuf(fieldType = FieldType.OBJECT, required = false, order = 5) private List&lt;User&gt; friends; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassWord() &#123; return passWord; &#125; public void setPassWord(String passWord) &#123; this.passWord = passWord; &#125; public String getUserInfo() &#123; return userInfo; &#125; public void setUserInfo(String userInfo) &#123; this.userInfo = userInfo; &#125; public List&lt;User&gt; getFriends() &#123; return friends; &#125; public void setFriends(List&lt;User&gt; friends) &#123; this.friends = friends; &#125; @Override public String toString() &#123; return \"User [userId=\" + userId + \", userName=\" + userName + \", passWord=\" + passWord + \", userInfo=\" + userInfo + \", friends=\" + friends + \"]\"; &#125;&#125; jprotobuf序列化代码示例如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package serialize;import java.io.IOException;import java.util.ArrayList;import java.util.List;import com.baidu.bjf.remoting.protobuf.Codec;import com.baidu.bjf.remoting.protobuf.ProtobufProxy;/** * * @author liqqc * */public class ProtoBuffSerialize &#123; public static void main(String[] args) throws IOException &#123; new ProtoBuffSerialize().start(); &#125; public void start() throws IOException &#123; Codec&lt;User&gt; studentClassCodec = ProtobufProxy.create(User.class, false); User u2 = new User(); List&lt;User&gt; friends = new ArrayList&lt;&gt;(); u2.setUserName(\"张三\"); u2.setPassWord(\"123456\"); u2.setUserInfo(\"张三是一个很牛逼的人\"); u2.setFriends(friends); User f1 = new User(); f1.setUserName(\"李四\"); f1.setPassWord(\"123456\"); f1.setUserInfo(\"李四是一个很牛逼的人\"); User f2 = new User(); f2.setUserName(\"王五\"); f2.setPassWord(\"123456\"); f2.setUserInfo(\"王五是一个很牛逼的人\"); friends.add(f1); friends.add(f2); Long stime_jpb_encode = System.currentTimeMillis(); byte[] bytes = null; for(int i = 0; i&lt;10; i++) &#123; bytes = studentClassCodec.encode(u2); &#125; System.out.println(\"jprotobuf序列化耗时：\" + (System.currentTimeMillis() - stime_jpb_encode) + \"ms; 总大小：\" + bytes.length); Long stime_jpb_decode = System.currentTimeMillis(); User user = studentClassCodec.decode(bytes); Long etime_jpb_decode = System.currentTimeMillis(); System.out.println(\"jprotobuf反序列化耗时：\"+ (etime_jpb_decode-stime_jpb_decode) + \"ms; User: \" + user); &#125;&#125; 运行结果 12jprotobuf序列化耗时：9ms; 总大小：148jprotobuf反序列化耗时：0ms; User: User [userId=null, userName=张三, passWord=123456, userInfo=张三是一个很牛逼的人, friends=[User [userId=null, userName=李四, passWord=123456, userInfo=李四是一个很牛逼的人, friends=null], User [userId=null, userName=王五, passWord=123456, userInfo=王五是一个很牛逼的人, friends=null]]]","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"IO多路复用技术以及epoll实现原理","slug":"IO多路复用技术以及epoll实现原理","date":"2020-02-28T10:57:13.000Z","updated":"2020-02-28T11:36:18.863Z","comments":true,"path":"2020/02/28/IO多路复用技术以及epoll实现原理/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E4%BB%A5%E5%8F%8Aepoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"为什么Redis中要使用I/O多路复用呢？​ redis 是一个单线程却性能非常好的内存数据库， 主要用来作为缓存系统。 ​ redis 采用网络IO多路复用技来保证在多连接的时候， 系统的高吞吐量。 ​ Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的. ​ select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。​ redis的io模型主要是基于epoll实现的，不过它也提供了 select和kqueue的实现，默认采用epoll。 epoll实现机制123设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？ ​ select/poll是，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。 ​ 如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。 总结：select和poll的缺点如下： 每次调用select/poll，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大 同时每次调用select/poll都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大 针对select支持的文件描述符数量太小了，默认是1024 select返回的是含有整个句柄的数组，应用程序需要遍历整个数组才能发现哪些句柄发生了事件； select的触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，那么之后每次select调用还是会将这些文件描述符通知进程。 相比select模型，poll使用链表保存文件描述符，因此没有了监视文件数量的限制，但其他三个缺点依然存在。 ​ epoll的设计和实现与select完全不同。epoll是poll的一种优化，返回后不需要对所有的fd进行遍历，在内核中维持了fd的列表。select和poll是将这个内核列表维持在用户态，然后传递到内核中。与poll/select不同，epoll不再是一个单独的系统调用，而是由epoll_create/epoll_ctl/epoll_wait三个系统调用组成，后面将会看到这样做的好处。epoll在2.6以后的内核才支持。 ​ epoll通过在Linux内核中申请一个简易的文件系统(文件系统一般用什么数据结构实现？B+树)。把原先select/poll调用分成了3个部分： 1）调用epoll_create()建立一个epoll对象(在epoll文件系统中为这个句柄对象分配资源) 2）调用epoll_ctl向epoll对象中添加这100万个连接的套接字 3）调用epoll_wait收集发生的事件的连接 ​ 如此一来，要实现上面说是的场景，只需要在进程启动时建立一个epoll对象，然后在需要的时候向这个epoll对象中添加或者删除连接。同时，epoll_wait的效率也非常高，因为调用epoll_wait时，并没有一股脑的向操作系统复制这100万个连接的句柄数据，内核也不需要去遍历全部的连接。 总结：epoll的优点 epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大 ，具体数目可以 cat /proc/sys/fs/file-max 察看。 效率提升， epoll 最大的优点就在于它只管你“活跃”的连接 ，而跟连接总数无关，因此在实际的网络环境中， epoll 的效率就会远远高于 select 和 poll 。 内存拷贝， epoll 在这点上使用了“共享内存”，这个内存拷贝也省略了 redis epoll底层实现​ 当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关 eventpoll结构体如下所示 12345678910struct eventpoll｛ ..... /*红黑树节点的根，存储着所有添加到epoll中的需要监控的事件*/ struct rb_root rbt; /*双链表中储存着将要通过epoll_wait返回给用户满足条件的事件*/ struct list_head rdlist; .....｝ ​ 每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是lgn，其中n为树的高度)。 ​ 而所有添加到epoll中的事件都会与设备(网卡)驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。 ​ 在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示： 1234567struct epitem&#123; struct rb_node rbn;//红黑树节点 struct list_head rdllink;//双向链表节点 struct epoll_filedfd ffd;//句柄事件信息 struct eventpoll *ep ;// 指向其所属的eventpoll对象 struct epoll_event;//期待发生的事件类型&#125; ​ 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户 优势： 不用重复传递。我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。 在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。 极其高效的原因：这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。 这个准备就绪list链表是怎么维护的呢？​ 当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。（注：好好理解这句话！） ​ 从上面这句可以看出，epoll的基础就是回调呀！ ​ 如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。 ​ 最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。关于LT，ET，有一端描述，LT和ET都是电子里面的术语，ET是边缘触发，LT是水平触发，一个表示只有在变化的边际触发，一个表示在某个阶段都会触发。 ​ LT, ET这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。（从上面这段，可以看出，LT还有个回放的过程，低效了）","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"},{"name":"Redis相关","slug":"Redis相关","permalink":"https://liudong-code.github.io/tags/Redis%E7%9B%B8%E5%85%B3/"}],"keywords":[]},{"title":"常见的IO模型","slug":"常见的IO模型","date":"2020-02-28T09:35:29.000Z","updated":"2020-02-28T10:51:20.103Z","comments":true,"path":"2020/02/28/常见的IO模型/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"高性能IO模型，常见的有四种：（1）同步阻塞IO（Blocking IO）：即传统的IO模型。 （2）同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为 NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。 （3）IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和 Linux中的epoll都是这种模型。 （4）异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。 IO模型举例理解1 阻塞IO, 给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不 会做其他事情, 属于备胎做法. 非阻塞IO, 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会 做其他事情, 属于专一做法. IO多路复用, 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么? 3.1 select大妈 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子 3.2 poll大妈不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神 3.3 epoll大妈不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你.上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于同步等待状态 接下来是异步IO的情况 你告诉女神我来了, 然后你就去王者荣耀了, 一直到女神下楼了, 发现找不见你了,女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口. 此时属于逆袭做法 IO模型举例理解21.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。 3.I/O复用模型 select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次 epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话 4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话 5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话 同步阻塞IO​ 同步阻塞IO模型是最简单的IO模型，用户线程在内核进行IO操作时被阻塞。 等待数据就绪（读就绪、写就绪）； 将数据从内核中拷贝到JVM进程中； 处理数据。 ​ 整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够 同步非阻塞IO ​ 由于socket是非阻塞的方式，因此用户线程发起IO请求时立即返回。但并未读取到任何数据，用户线程需要不断地发起IO请求，直到数据到达后，才真正读取到数据，继续执行。 伪代码： 1234&#123; while(read(socket, buffer) != SUCCESS); process(buffer);&#125; ​ 即用户需要不断地调用read，尝试读取socket中的数据，直到读取成功后，才继续处理接收的数据。整个IO请的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。 IO多路复用​ IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。 ​ 用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回。用户线程正式发起read请求，读取数据并继续执行。 ​ 从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。 ​ 但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。 ​ 用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 用户线程使用IO多路复用模型的伪代码描述为： 123456789void UserEventHandler::handle_event() &#123; if(can_read(socket)) &#123; read(socket, buffer); process(buffer); &#125; &#125;&#123; Reactor.register(new UserEventHandler(socket));&#125; ​ 用户需要重写EventHandler的handle_event函数进行读取数据、处理数据的工作，用户线程只需要将自己的EventHandler注册到Reactor即可。Reactor中handle_events事件循环的伪代码大致如下： 12345678Reactor::handle_events() &#123; while(1) &#123; sockets = select(); for(socket in sockets) &#123; get_event_handler(socket).handle_event(); &#125; &#125;&#125; ​ 事件循环不断地调用select获取被激活的socket，然后根据获取socket对应的EventHandler，执行器handle_event函数即可。​ IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。 异步IO​ “真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。 异步IO模型使用了Proactor设计模式实现了这一机制。 异步IO模型中， 用户线程直接使用内核提供的异步IO API发起read请求，且发起后立即返回，继续执行用户线程代码。不过此时用户线程已经将调用的AsynchronousOperation和CompletionHandler注册到内核， 然后操作系统开启独立的内核线程去处理IO操作。当read请求的数据到达时，由内核负责读取socket中的数据，并写入用户指定的缓冲区中。 最后内核将read的数据和用户线程注册的CompletionHandler分发给内部Proactor，Proactor将IO完成的信息通知给用户线程（一般通过调用用户线程注册的完成事件处理函数），完成异步IO。 用户线程使用异步IO模型的伪代码描述为： 1234567void UserCompletionHandler::handle_event(buffer) &#123; process(buffer);&#125;&#123; aio_read(socket, new UserCompletionHandler);&#125; 用户需要重写CompletionHandler的handle_event函数进行处理数据的工作，参数buffer表示Proactor已经准备好的数据，用户线程直接调用内核提供的异步IO API，并将重写的CompletionHandler注册即可。 相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。Java7之后已经支持了异步IO，感兴趣的读者可以尝试使用。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"IO设计模式之Reactor和Proactor","slug":"IO设计模式之Reactor和Proactor","date":"2020-02-28T08:49:31.000Z","updated":"2020-02-28T09:45:04.562Z","comments":true,"path":"2020/02/28/IO设计模式之Reactor和Proactor/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8BReactor%E5%92%8CProactor/","excerpt":"","text":"反应器Reactor概述​ 反应器设计模式(Reactor pattern)是一种为处理并发服务请求，并将请求提交到一个或者多个服务处理程序的 事件设计模式。当客户端请求抵达后，服务处理程序使用多路分配策略，由一个非阻塞的线程来接收所有的请求， 然后派发这些请求至相关的工作线程进行处理。 Reactor模式主要包含下面几部分内容： 初始事件分发器(Initialization Dispatcher)：用于管理Event Handler，定义注册、移除EventHandler等。它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中handle_event(方法 同步（多路）事件分离器(Synchronous Event Demultiplexer)：无限循环等待新事件的到来，一旦发现有新的事件到来，就会通知初始事件分发器去调取特定的事件处理器。 系统处理程序(Handles)：操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。由于Reactor模式一般使用在网络编程中，因而这里一般指SocketHandle，即一个网络连接（Connection，在Java NIO中的Channel）。这个Channel注册到SynchronousEvent Demultiplexer中，以监听Handle中发生的事件，对ServerSocketChannnel可以是CONNECT事件，对SocketChannel可以是READ、WRITE、CLOSE事件等。 事件处理器(Event Handler)： 定义事件处理方法，以供Initialization Dispatcher回调使用。 为什么使用Reactor模式​ 并发系统常使用reactor模式代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量。 例如：在高并发的情况下，既可以使用多处理处理方式，也可以使用Reactor处理方式。 多线程的处理：​ 为每个单独到来的请求，专门启动一条线程，这样的话造成系统的开销很大，并且在单核的机上，多线程并不能提高系统的性能，除非在有一些阻塞的情况发生。否则线程切换的开销会使处理的速度变慢。 Reactor模式的处理：​ 服务器端启动一条单线程，用于轮询IO操作是否就绪，当有就绪的才进行相应的读写操作，这样的话就减少了服务器产生大量的线程，也不会出现线程之间的切换产生的性能消耗。(目前JAVA的NIO就采用的此种模式，这里引申出一个问题：在多核情况下NIO的扩展问题) ​ 以上两种处理方式都是基于同步的，多线程的处理是我们传统模式下对高并发的处理方式，Reactor模式的处理是现今面对高并发和高性能一种主流的处理方式。 Reactor模式结构 Reactor包含如下角色： Handle 句柄；用来标识socket连接或是打开文件； Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；） Event Handler：事件处理接口 Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑； Reactor：反应器，定义一个接口，实现以下功能： 1）供应用程序注册和删除关注的事件句柄； 2）运行事件循环； 3）有就绪事件到来时，分发事件到之前注册的回调函数上处理； Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法 应用启动，将关注的事件handle注册到Reactor中； 调用Reactor，进入无限事件循环，等待注册的事件到来； 事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理； Proactor模式​ 运用于异步I/O操作，Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.​ Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。 Proactor模式结构 Proactor主动器模式包含如下角色 Handle 句柄；用来标识socket连接或是打开文件； Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现； Asynchronous Operation：异步操作 Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用 Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑； Completion Handler：完成事件接口；一般是由回调函数组成的接口； Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑； 业务流程及时序图 应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行； 应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来； 异步操作处理器执行异步操作，完成后将结果放入到完成事件队列； 主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中； 对比两者的区别主动和被动以主动写为例： Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完处理后续逻辑； Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑； 可以看出，Reactor被动的等待指示事件的到来并做出反应；它有一个等待的过程，做什么都要先放入到监听事件集合中等待handler可用时再进行操作；Proactor直接调用异步读写操作，调用完后立刻返回； 实现Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应； Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发的执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响） 优点Reactor实现相对简单，对于耗时短的处理场景处理高效；操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来， Proactor性能更高，能够处理耗时长的并发场景； 缺点Reactor处理耗时长的操作会造成事件分发的阻塞，影响到后续事件的处理； Proactor实现逻辑复杂；依赖操作系统对异步的支持，目前实现了纯异步操作的操作系统少，实现优秀的如windows IOCP，但由于其windows系统用于服务器的局限性，目前应用范围较小；而Unix/Linux系统对纯异步的支持有限，应用事件驱动的主流还是通过select/epoll来实现； 适用场景Reactor：同时接收多个服务请求，并且依次同步的处理它们的事件驱动程序；Proactor：异步接收和同时处理多个服务请求的事件驱动程序； 开源产品如Redis、ACE，事件模型都使用的Reactor模式","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"同步IO、异步IO、阻塞IO、非阻塞IO","slug":"同步IO、异步IO、阻塞IO、非阻塞IO","date":"2020-02-28T08:43:03.000Z","updated":"2020-02-28T08:47:20.869Z","comments":true,"path":"2020/02/28/同步IO、异步IO、阻塞IO、非阻塞IO/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E5%90%8C%E6%AD%A5IO%E3%80%81%E5%BC%82%E6%AD%A5IO%E3%80%81%E9%98%BB%E5%A1%9EIO%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO/","excerpt":"","text":"同步IO和异步IO同步和异步是针对应用程序和内核的交互而言的， 同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪， 异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。 指的是用户空间和内核空间数据交互的方式 ​ 同步：用户空间要的数据，必须等到内核空间给它才做其他事情 ​ 异步：用户空间要的数据，不需要等到内核空间给它，才做其他事情。内核空间会异步通知用户进程，并把 数据直接给到用户空间 阻塞IO和非阻塞IO 阻塞方式下读取或者写入函数将一直等待， 非阻塞方式下，读取或者写入函数会立即返回一个状态值。 指的是用户就和内核空间IO操作的方式 ​ 堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是堵塞的 ​ 非堵塞：用户空间通过系统调用（systemcall）和内核空间发送IO操作时，该调用是不堵塞的，直接返回的， 只是返回时，可能没有数据而已","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"Socket网络编程","slug":"Socket网络编程","date":"2020-02-28T08:29:54.000Z","updated":"2020-02-28T08:37:52.983Z","comments":true,"path":"2020/02/28/Socket网络编程/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"客户端123456789101112131415public class SocketClient &#123; public static void main(String args[]) throws Exception &#123; // 要连接的服务端IP地址和端口 String host = \"127.0.0.1\"; int port = 55533; // 与服务端建立连接 Socket socket = new Socket(host, port); // 建立连接后获得输出流 OutputStream outputStream = socket.getOutputStream(); String message=\"你好 yiwangzhibujian\"; socket.getOutputStream().write(message.getBytes(\"UTF-8\")); outputStream.close(); socket.close(); &#125;&#125; 服务端123456789101112131415161718192021222324public class SocketServer &#123; public static void main(String[] args) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; //注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len,\"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); server.close(); &#125;&#125; 123456789101112131415161718192021222324public class SocketServer &#123; public static void main(String args[]) throws IOException &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); while(true)&#123; Socket socket = server.accept(); // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, \"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); &#125; &#125;&#125; 线程池的方式： 1234567891011121314151617181920212223242526272829303132public class SocketServer &#123; public static void main(String args[]) throws Exception &#123; // 监听指定的端口 int port = 55533; ServerSocket server = new ServerSocket(port); // server将一直等待连接的到来 System.out.println(\"server将一直等待连接的到来\"); //如果使用多线程，那就需要线程池，防止并发过高时创建过多线程耗尽资源 ExecutorService threadPool = Executors.newFixedThreadPool(100); while (true) &#123;Socket socket = server.accept(); Runnable runnable=()-&gt;&#123; try &#123; // 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取 InputStream inputStream = socket.getInputStream(); byte[] bytes = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = inputStream.read(bytes)) != -1) &#123; // 注意指定编码格式，发送方和接收方一定要统一，建议使用UTF-8 sb.append(new String(bytes, 0, len, \"UTF-8\")); &#125; System.out.println(\"get message from client: \" + sb); inputStream.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;; threadPool.submit(runnable); &#125; &#125;&#125;","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"IO访问方式","slug":"IO访问方式","date":"2020-02-28T03:50:23.000Z","updated":"2020-02-28T08:27:25.684Z","comments":true,"path":"2020/02/28/IO访问方式/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/IO%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F/","excerpt":"","text":"磁盘IO​ 当应用程序调用read接口时，操作系统检查在内核的高速缓存有没有需要的数据，如果已经缓存了，那么就直接从 缓存中返回，如果没有，则从磁盘中读取，然后缓存在操作系统的缓存中。​ 当应用程序调用write接口时，将数据从用户地址空间复制到内核地址空间的缓存中，这时对用户程序来说，写操作已 经完成，至于什么时候再写到磁盘中，由操作系统决定，除非显示调用了sync同步命令。 网络IO​ 1）操作系统将数据从磁盘复制到操作系统内核的页缓存中 ​ 2）应用将数据从内核缓存复制到应用的缓存中 ​ 3）应用 将数据写回内核的Socket缓存中 ​ 4）操作系统将数据从Socket缓存区复制到网卡缓存，然后将其通过网络发出 1我是图，图待补... 1、当调用read系统调用时，通过DMA（Direct Memory Access）将数据copy到内核模式 2、然后由CPU控制将内 核模式数据copy到用户模式下的 buffer中 3、read调用完成后，write调用首先将用户模式下 buffer中的数据copy到内核模式下的socket buffer中 4、最后通过DMA copy将内核模式下的socket buffer中的数据copy到网卡设备中传送。 比较 磁盘IO主要的延时是由（以15000rpm硬盘为例）： 机械转动延时（机械磁盘的主要性能瓶颈，平均为2ms） + 寻址延时（2~3ms） + 块传输延时（一般4k每块，40m/s的传输速度，延时一般为0.1ms) 决定。（平均为5ms） 网络IO主要延是由： 服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时 决定。（一般为几十到几千毫秒，受环境干扰极大）所以两者一般来说网络IO延时要大于磁盘IO的延时。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"缓存IO和直接IO","slug":"缓存IO和直接IO","date":"2020-02-28T02:21:56.000Z","updated":"2020-02-28T03:23:17.351Z","comments":true,"path":"2020/02/28/缓存IO和直接IO/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/%E7%BC%93%E5%AD%98IO%E5%92%8C%E7%9B%B4%E6%8E%A5IO/","excerpt":"","text":"定义 缓存IO：数据从磁盘通过DMA copy到内核空间，再从内核空间通过CPU copy到用户空间。 直接IO：数据从磁盘通过DMA copy到用户空间。 缓存IO​ 缓存I/O又被称作标准IO，大多数文件系统的默认操作都是缓存IO。在Linux的缓存IO机制中，数据先从磁盘复制到内核空间的缓冲区，然后从内核空间缓冲区复制到应用程序的地址空间。 读操作： 操作系统检查内核的缓冲区有没有西药的数据，如果已经缓存，那么直接从缓存中返回；否则从磁盘中读取，然后缓存在操作系统的缓存中。 写操作： 数据从用户空间复制到内核空间的缓存中，这时对用户程序来说写操作就已经完后才能，至于什么时候在写到磁盘中由操作系统决定，除非显示的调用了sync同步命令。–《【珍藏】linux 同步IO: sync、fsync与fdatasync》。 缓存I/O的优点： 1）在一定程度上分离了内核空间和用户空间，保护系统本身的运行安全； 2）可以减少读盘的次数，从而提高性能。 缓存I/O的缺点： 在缓存 I/O 机制中，DMA 方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存直接写回到磁盘 上，而不能直接在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址 空间（用户空间）和缓存（内核空间）之间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存 开销是非常大的。 直接IO​ 直接IO就是应用程序直接访问磁盘数据，而不经过内核缓冲区，也就是绕过内核缓冲区，自己管理IO缓冲区，这样做的目的是减少一次从内核缓冲区带用户程序缓存的数据复制。 直接IO的优点 ​ 应用程序直接访问磁盘数据，不经过操作系统内核数据缓冲区，这样做的目的是减少一次从内核缓冲区到用户程序 缓存的数据复制。这种方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。 ​ 引入内核缓冲区的目的在于提高磁盘文件的访问性能，因为当进程需要读取磁盘文件时，如果文件内容已经在内核缓 冲区中，那么就不需要再次访问磁盘；而当进程需要向文件中写入数据时，实际上只是写到了内核缓冲区便告诉进程 已经写成功，而真正写入磁盘是通过一定的策略进行延迟的。 ​ 然而，对于一些较复杂的应用，比如数据库服务器，它们为了充分提高性能，希望绕过内核缓冲区，由自己在用户 态空间实现并管理I/O缓冲区，包括缓存机制和写延迟机制等，以支持独特的查询机制，比如数据库可以根据更加 合理的策略来提高查询缓存命中率。另一方面，绕过内核缓冲区也可以减少系统内存的开销，因为内核缓冲区本身就 在使用系统内存。 直接IO的缺点 ​ 如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘进行加载，这种直接加载 会非常缓慢。通常直接I/O跟异步I/O结合使用会得到较好的性能。 ​","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"PIO和DMA","slug":"PIO和DMA","date":"2020-02-28T02:09:06.000Z","updated":"2020-02-28T02:20:04.626Z","comments":true,"path":"2020/02/28/PIO和DMA/","link":"","permalink":"https://liudong-code.github.io/2020/02/28/PIO%E5%92%8CDMA/","excerpt":"","text":"慢速IO设备和内存之间的数据传输方式有下面两种： PIO：磁盘和内存之间的数据传输是需要CPU控制的，也就是说如果我们读取磁盘文件到内存中，数据要经过CPU储存转发，这种方式成为PIO。这种方式是不合理的，需要大量的CPU时间来读取文件，照成文件访问时系统几乎停止响应。 DMA：DMA（直接内存访问，Direct Memory Access），不经过CPU而直接进行磁盘和内存（内核空间）的数据交换。在DMA的模式下，CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据和传达即可，DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占有率，大大节省了系统资源，而它的传输速度与PIO的差异并不是十分明显，因为这主要取决于慢速设备的速度。","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"用户空间和内核空间","slug":"用户空间和内核空间","date":"2020-02-27T15:14:39.000Z","updated":"2020-02-27T15:56:55.859Z","comments":true,"path":"2020/02/27/用户空间和内核空间/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/","excerpt":"","text":"定义虚拟内存被操作系统划分成两块：内核空间和用户空间， 内核空间是内核代码运行的地方， 用户空间是用户程序代码运行的地方 当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。 简单说， Kernel space 是 Linux 内核的运行空间， User space 是用户程序的运行空间。 为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。 Kernel space 可以执行任意命令，调用系统的一切资源； User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。 1234str = \"my string\" // 用户空间x = x + 2file.write(str) // 切换到内核空间y = x + 4 // 切换回用户空间 第一行和第二行都是简单的赋值运算，在 User space 执行。 第三行需要写入文件，就要切换到Kernel space，因为用户不能直接写文件，必须通过内核安排。 第四行又是赋值运算，就切换回 User space。 查看 CPU 时间在 User space 与 Kernel Space 之间的分配情况，可以使用top命令。它的第三行输出就是 CPU 时间分配统计。 其中，第一项24.8 us（user 的缩写）就是 CPU 消耗在 User space 的时间百分比，第二项0.5 sy（system 的缩写）是消耗在 Kernel space 的时间百分比。随便也说一下其他 6 个指标的含义。ni：niceness 的缩写，CPU 消耗在 nice 进程（低优先级）的时间百分比id：idle 的缩写，CPU 消耗在闲置进程的时间百分比，这个值越低，表示 CPU 越忙wa：wait 的缩写，CPU 等待外部 I/O 的时间百分比，这段时间 CPU 不能干其他事，但是也没有执行运算，这个值太高就说明外部设备有问题hi：hardware interrupt 的缩写，CPU 响应硬件中断请求的时间百分比si：software interrupt 的缩写，CPU 响应软件中断请求的时间百分比st：stole time 的缩写，该项指标只对虚拟机有效，表示分配给当前虚拟机的 CPU 时间之中，被同一台物理机上的其他虚拟机偷走的时间百分比","categories":[],"tags":[{"name":"IO模型","slug":"IO模型","permalink":"https://liudong-code.github.io/tags/IO%E6%A8%A1%E5%9E%8B/"}],"keywords":[]},{"title":"ArrayList和LinkedList有什么区别","slug":"ArrayList和LinkedList有什么区别","date":"2020-02-27T09:00:12.000Z","updated":"2020-02-27T09:03:51.250Z","comments":true,"path":"2020/02/27/ArrayList和LinkedList有什么区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/ArrayList%E5%92%8CLinkedList%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"区别 LinkedList和ArrayList的差别主要来自于Array和LinkedList数据结构的不同。ArrayList是基于数组实现的，LinkedList是基于双链表实现的。另外LinkedList类不仅是List接口的实现类，可以根据索引来随机访问集合中的元素，除此之外，LinkedList还实现了Deque接口，Deque接口是Queue接口的子接口，它代表一个双向队列，因此LinkedList可以作为双向对列，栈（可以参见Deque提供的接口方法）和List集合使用，功能强大。 因为Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的，可以直接返回数组中index位置的元素，因此在随机访问集合元素上有较好的性能。Array获取数据的时间复杂度是O(1),但是要插入、删除数据却是开销很大的，因为这需要移动数组中插入位置之后的的所有元素。 相对于ArrayList，LinkedList的随机访问集合元素时性能较差，因为需要在双向列表中找到要index的位置，再返回；但在插入，删除操作是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。 LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。 使用场景 如果应用程序对数据有较多的随机访问，ArrayList对象要优于LinkedList对象； 如果应用程序有更多的插入或者删除操作，较少的数据读取，LinkedList对象要优于ArrayList对象； 不过ArrayList的插入，删除操作也不一定比LinkedList慢，如果在List靠近末尾的地方插入，那么ArrayList只需要移动较少的数据，而LinkedList则需要一直查找到列表尾部，反而耗费较多时间，这时ArrayList就比LinkedList要快","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"final，finally，finalize的区别","slug":"final，finally，finalize的区别","date":"2020-02-27T08:31:46.000Z","updated":"2020-02-27T08:57:27.919Z","comments":true,"path":"2020/02/27/final，finally，finalize的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/final%EF%BC%8Cfinally%EF%BC%8Cfinalize%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1.简单区别： final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。 finally是异常处理语句结构的一部分，表示总是执行。 finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。 2.中等区别： final：java中的关键字，修饰符。 如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为abstract抽象类的和final的类。 如果将变量或者方法声明为final，可以保证它们在使用中不被改变. 1)被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。 2)被声明final的方法只能使用，不能重载。 finally：java的一种异常处理机制。 finally是对Java异常处理模型的最佳补充。finally结构使代码总会执行，而不管无异常发生。使用finally可以维护对象的内部状态，并可以清理非内存资源。特别是在关闭数据库连接这方面，如果程序员把数据库连接的close()方法放到finally中，就会大大降低程序出错的几率。 finalize：Java中的一个方法名。Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没被引用时对这个对象调用的。它是在Object类中定义的，因此所的类都继承了它。子类覆盖finalize()方法以整理系统资源或者执行其他清理工作。finalize()方法是在垃圾收集器删除对象之前对这个对象调用的。 3.详细区别：final定义变量 第一种情况：如果final修饰的是一个基本类型，就表示这个变量被赋予的值是不可变的，即它是个常量；如果final修饰的是一个对象，就表示这个变量被赋予的引用是不可变的这里需要提醒大家注意的是，不可改变的只是这个变量所保存的引用，并不是这个引用所指向的对象。 第二种情况：final的含义与第一种情况相同。实际上对于前两种情况，一种更贴切的表述final的含义的描述，那就是，如果一个变量或方法参数被final修饰，就表示它只能被赋值一次，但是JAVA虚拟机为变量设定的默认值不记作一次赋值。被final修饰的变量必须被初始化。初始化的方式以下几种：1.在定义的时候初始化。2.final变量可以在初始化块中初始化，不可以在静态初始化块中初始化。3.静态final变量可以在定义时初始化，也可以在静态初始化块中初始化，不可以在初始化块中初始化。4.final变量还可以在类的构造器中初始化，但是静态final变量不可以。 定义方法当final用来定义一个方法时，它表示这个方法不可以被子类重写，但是并不影响它被子类继承。定义类​ final类不允许被继承，编译器在处理时把它的所方法都当作final的，因此final类比普通类拥更高的效率。而由关键字abstract定义的抽象类含必须由继承自它的子类重载实现的抽象方法，因此无法同时用final和abstract来修饰同一个类。同样的道理，final也不能用来修饰接口。 final的类的所方法都不能被重写，但这并不表示final的类的属性（变量值也是不可改变的，要想做到final类的属性值不可改变，必须给它增加final修饰 finally语句​ finally只能用在try/catch语句中并且附带着一个语句块，表示这段语句最终总是被执行 。 finalize方法​ 它是一个方法，属于java.lang.Object类，它的定义如下： 1protected void finalize()throws Throwable&#123;&#125; ​ 众所周知，finalize()方法是GC （garbagecollector）运行机制的一部分,在此我们只说说finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception），GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"进程和线程的区别","slug":"进程和线程的区别","date":"2020-02-27T08:04:55.000Z","updated":"2020-02-27T08:22:29.252Z","comments":true,"path":"2020/02/27/进程和线程的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"概念《系统架构师》一书中给出的定义是： 进程（process）是资源分配和独立运行的基本单位。研究操作系统的进程，实质是研究系统中诸多进程之间的并发特性以及进程之间的相互制约性。 线程是进程中的一个实体，是被系统独立分配和调度的基本操作单位。具有就绪、运行、阻塞三种状态。 一个进程有若干个线程，线程只拥有一些运行中必不可少的资源，它可与同一个进程的其他线程共享进程所拥有的的全部资源。线程可创建另外一个线程，同一个进程中的多个线程可并发执行。 Linux中的概念 进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。程序运行时系统就会创建一个进程，并为它分配资源，然后把该进程放入进程就绪队列，进程调度器选中它的时候就会为它分配CPU时间，程序开始真正运行。 Linux系统函数fork()可以在父进程中创建一个子进程，这样的话，在一个进程接到来自客户端新的请求时就可以复制出一个子进程让其来处理，父进程只需负责监控请求的到来，然后创建子进程让其去处理，这样就能做到并发处理。 123456789101112131415# -*- coding:utf-8 -*-import osprint('当前进程:%s 启动中 ....' % os.getpid())pid = os.fork()if pid == 0: print('子进程:%s,父进程是:%s' % (os.getpid(), os.getppid()))else: print('进程:%s 创建了子进程:%s' % (os.getpid(),pid )) 输出结果：当前进程:27223 启动中 ....进程:27223 创建了子进程:27224子进程:27224,父进程是:27223 线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位，一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。 区别和优劣 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 参考书籍《Unix网络编程》","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"泛型中extends和super的区别","slug":"泛型中extends和super的区别","date":"2020-02-27T07:35:59.000Z","updated":"2020-02-27T07:58:34.700Z","comments":true,"path":"2020/02/27/泛型中extends和super的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%B3%9B%E5%9E%8B%E4%B8%ADextends%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"释义：在非泛型中： extends：让一个类继承另外一个类； super：指向父类对象的引用； 在泛型中： extends也成为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。 super也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。 看如下代码： 123456789101112131415161718192021222324252627public class Food &#123;&#125;public class Fruit extends Food &#123;&#125;public class Apple extends Fruit &#123;&#125;public class Banana extends Fruit&#123;&#125;public class GenericTest &#123;public void testExtends(List&lt;? extends Fruit&gt; list)&#123; //报错,extends为上界通配符,只能取值,不能放. //因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错 //list.add(new Apple()); //可以正常获取 Fruit fruit = list.get(1);&#125;public void testSuper(List&lt;? super Fruit&gt; list)&#123; //super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲， //无法确定Fruit的父类是否只有Food一个(Object是超级父类) //因此放入Food的实例编译不通过 list.add(new Apple()); // list.add(new Food()); Object object = list.get(1); &#125;&#125; 在testExtends方法中，因为泛型中用的是extends，在向list中存放元素的时候，我们并不能确定List中的元素的具体类型，即可能是Apple也可能是Banana。因此调用add方法时，不论传入new Apple()还是new Banana()，都会出现编译错误。 理解了extends之后，再看super就很容易理解了，即我们不能确定testSuper方法的参数中的泛型是Fruit的哪个父类，因此在调用get方法时只能返回Object类型。结合extends可见，在获取泛型元素时，使用extends获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。 总结：在使用泛型时，存取元素时用super,获取元素时，用extends。 扩展： 通配符 ? 使用 在泛型中的通配符就是一个问号，标准叫法是无界通配符，它一般使用在参数或变量的声明上 1234567891011121314 // 在参数中使用无界通配符 public static void test(List&lt;?&gt; list) &#123; Object o = list.get(1);&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;(); // 在变量声明中使用无界通配符 List&lt;?&gt; list2 = list1; test(list1); test(list2);&#125; 泛型中使用无界通配符，表示泛型可以是任意具体的类型，没有限制（基本数据类型除外，基本数据类型不能用作泛型，可以使用基本数据类型的包装类）； 所以无界通配符给人的感觉就和原生的类型没什么区别，比如就上面这段代码，使用List&lt;?&gt;，和直接使用List，好像是一样的；但是实际上还是有一些区别的，比如看下面这段代码: 1234567891011121314151617181920212223 // 在参数中使用无界通配符 public static void test1(List&lt;?&gt; list) &#123; // 均编译错误，因为使用了无界通配符，编译器无法确定具体是什么类型 // list.add(1111); // list.add(\"aaa\"); // list.add(new Object());&#125;// 在参数中使用原生Listpublic static void test2(List list) &#123; // 编译通过，不加泛型时，编译器默认为Object类型 list.add(1111); list.add(\"aaa\"); list.add(new Object());&#125;public static void main(String[] args) &#123; // 声明两个泛型明确的list集合 List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 调用使用了&lt;？&gt;的方法 test1(list1); test2(list2);&#125; List：表示可以存储任意Object类型的集合； List：表示一个存储某种特定类型的List集合，但是不知道这种特定类型是什么；","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"String，Stringbuffer，StringBuilder的区别","slug":"String，Stringbuffer，StringBuilder的区别","date":"2020-02-27T07:16:10.000Z","updated":"2020-02-27T07:19:07.092Z","comments":true,"path":"2020/02/27/String，Stringbuffer，StringBuilder的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/String%EF%BC%8CStringbuffer%EF%BC%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"String string类是不可变的：创建一个String对象之后，任何对这个对象的改变都会引起一个新的String对象生成。 123String str =\"abc\";str = str +\"def\";//这一步jvm会再次创建一个String对象 第二次其实jvm又生成了一个String类，而不是直接覆盖原来的”abc”，因此我们说String类是不可改变类。这一种特性会带来一个问题，每次拼接都要创建都要创建一次对象，当我们要拼接大量字符串的时候，效率会变得非常非常慢。 StringBuffer StringBuffer 不同于String的是，stringbuffer 是可变的， 123StringBuffer sb =new StringBuffer(\"abc\"); sb.append(\"efg\");//并没有创建一个新的对象 这里第二步并没有产生一个新的对象，而是在原来的基础上追加字符串，这种方式在拼接字符串的时候效率肯定比String要高得多。 StringBuilderStringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBuffer支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。 total:1.如果要操作少量的数据用 String 2.单线程操作字符串缓冲区下操作大量数据用StringBuilder 3.多线程操作字符串缓冲区下操作大量数据用StringBuffer","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java中的可变对象与不可变对象","slug":"Java中的可变对象与不可变对象","date":"2020-02-27T06:59:24.000Z","updated":"2020-02-27T07:09:51.291Z","comments":true,"path":"2020/02/27/Java中的可变对象与不可变对象/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"不可变对象 （Immutable Objects）​ 对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。 ​ 不可变对象的类即为不可变类(Immutable Class)。JAVA平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等 . 可变对象(Mutable Objects)​ 相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。 编写不可变类 1.确保类不能被继承：将类声明为final, 或者使用静态工厂并声明构造器为private 使用private和final修饰符来修饰该类的属性 如果成员属性为可变对象属性，不要使这些对象改变： 1）不要提供更改可变对象的方法 2）不要共享对可变对象的引用，不要存储传给构造器的外部可变对象的引用。因为引用可变对象的成员变量和外部可变对象的引用指向同一块内存地址，用户可以在不可变类之外通过修改可变对象的值 为了保证内部的值不被修改，可以采用深度拷贝的方法来复制一个对象并传入副本的引用来确保类的不可变 1234567891011public final class MyImmutableDemo &#123; private final int[] myArray; public MyImmutableDemo(int[] array) &#123; this.myArray = array.clone(); &#125; &#125; C. 不要提供任何可以修改对象状态的方法（不仅仅是set方法, 还有任何其它可以改变状态的方法） 不可变对象的优缺点优点* 构造、测试和使用都很简单 * 不可变对象是线程安全的，在线程之间可以相互共享，不需要利用特殊机制来保证同步问题，因为对象的值无法改变。可以降低并发错误的可能性，因为不需要用一些锁机制等保证内存一致性问题也减少了同步开销。 * 不可变对象可以被重复使用，可以将它们缓存起来重复使用，就像字符串字面量和整型数字一样。可以使用静态工厂方法来提供类似于valueOf()这样的方法，它可以从缓存中返回一个已经存在的Immutable对象，而不是重新创建一个。 缺点 * 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象,制造大量垃圾，由于他们不能被重用而且对于它们的使用就是”用“然后”扔“，会创造很多的垃圾，给垃圾收集带来很大的麻烦 参考：https://blog.csdn.net/bupa900318/article/details/80696785","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"接口和抽象类的区别","slug":"接口和抽象类的区别","date":"2020-02-27T06:06:01.000Z","updated":"2020-02-27T07:43:41.584Z","comments":true,"path":"2020/02/27/接口和抽象类的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"抽象类1abstract ​ 抽象类必须用abstract 修饰，子类必须实现抽象类中的抽象方法，如果有方法未实现，那么子类的该方法也要用abstract 修饰。 ​ 默认的权限修饰符是：public，也可以是procted.如果是private的话，子类无法继承。 ​ 抽象类无法创建对象。 接口1interface ​ 接口中的变量隐式的使用Public static final 修饰，也要给出初始值 ​ 接口中的方法隐式的使用public abstract 修饰，只能是public 修饰。 ​ 接口中的方法默认的不能有实现（JDK1.8可以有默认实现）。 抽象类和接口的区别 抽象类只能继承一次，但是可以有多个接口。 继承于抽象类或者接口的类，必须实现其中的所有方法，抽象类中的为实现的抽象方法，子类也需要定义为抽象类。 抽象类可以有非抽象方法。 接口的变量必须由public static final 修饰，并给出初始值，所以其实现类不能重新定义，也不能改变其值。 接口的方法默认是public abstract ，不能是static，抽象类中可以有static方法。 接口的方法也不允许子类覆写。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"抽象类的意义","slug":"抽象类的意义","date":"2020-02-27T05:53:43.000Z","updated":"2020-02-27T06:07:43.236Z","comments":true,"path":"2020/02/27/抽象类的意义/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%84%8F%E4%B9%89/","excerpt":"","text":"抽象类的意义最主要的：对代码的维护和重用。 关键字 1abstract 1.因为抽象类不能实例化对象，所以必须要有子类来实现它之后才能使用。这样就可以把一些具有相同属性和方法的组件进行抽象，这样更有利于代码和程序的维护 2.当又有一个具有相似的组件产生时，只需要实现该抽象类就可以获得该抽象类的那些属性和方法。 ​ 实际写代码的过程中，如果想要对某一个接口进行默认实现，并且不希望在该实现类 上创建实例，那么抽象类是一个不错地选择。","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"int与Integer的区别","slug":"int与Integer的区别","date":"2020-02-27T05:13:32.000Z","updated":"2020-02-27T05:34:38.327Z","comments":true,"path":"2020/02/27/int与Integer的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/int%E4%B8%8EInteger%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"int1int 是java的基本数据类型。 Integer1Integer 继承了Object类，是对象类型，是 int 的包装类。 int 与 Integer 的区别1,值的储存​ int储存在栈中 ​ Integer对象的引用储存在栈中，对象的数据储存在堆中。 2,初始化​ int初始值是0 ​ Integer的初始值是null 3,传参​ int是值传递 ​ Integer是引用传递，引用不可改变但是引用指向堆空间地址的值是可以改变的。 4,泛型支持​ 泛型不支持int，但是支持Integer。 5,运算​ int 可以直接做运算，是类的特性。​ Integer 的对象可以调用该类的方法，但是在拆箱之前不能进行运算，需要转化为基本类型int。 相同值下的 int 和 Integer 的比较结果​ 1,两个通过new生成的变量，结果为false。​ 2,int 和 Integer 的值比较，若两者的值相等，则为true。​ （注意：在比较时，Integer会自动拆箱为int类型，然后再做比较。）​ 3,new 生成的Integer变量 和 非new 生成的Integer变量比较，，结果为false。​ （注意：new 生成的Integer变量的值在堆空间中，非new 生成的Integer变量的值在在常量池中。）​ （注意：非new生成的Integer变量，会先判断常量池中是否有该对象，若有则共享，若无则在常量池中放入 该对象；也叫享元模式，后面再说。）​ 4,两个非new 生成的Integer对象比较，则结果为true。​ （注意：此处需要一个前提：值的范围在 -128 ~ 127 之间。​ 涉及到java对 int 与 Integer 的自动装箱和拆箱的一种模式：享元模式—flyweight，为了加强对简单数字的重 复利用。​ 在赋值时，其实是执行了Integer的valueOf()方法。​ 当值在 -128 ~ 127之间时，java会进行自动装箱，然后会对值进行缓存，如果下次再有相同的值，会直接在 缓存中取出使用。缓存是通过Integer的内部类IntegerCache来完成的。​ 当值超出此范围，会在堆中new出一个对象来存储。​ PS：自动装箱与拆箱是在JDK1.5中出现的。 12345678910111213141516public static void main(String[] args) &#123; int a =12; Integer b =12; Integer c = new Integer(12); Integer d=128; Integer e=128; System.out.println(a==b); System.out.println(b==c); System.out.println(d==e); &#125;truefalsefalse ​ 5,内部类IntegerCache​ 通过此类可以缓存简单数字。​ 缓存的数大小可以由 -XX：AutoBoxCacheMax = 控制。​ jvm初始化时，java.lang.Integer.Integ","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"Java==和equals和hashCode的区别","slug":"Java中==和equals和hashCode的区别","date":"2020-02-27T02:00:49.000Z","updated":"2020-02-27T08:54:31.546Z","comments":true,"path":"2020/02/27/Java中==和equals和hashCode的区别/","link":"","permalink":"https://liudong-code.github.io/2020/02/27/Java%E4%B8%AD==%E5%92%8Cequals%E5%92%8ChashCode%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"Java中==和equals和hashCode的区别1，==1, 基础类型：byte,short,char,int,double,boolean,float ​ 他们之间用“==”，比较的是他们的值 2, 引用类型（类，接口，数组） ​ 使用“==”进行比较的时候，比较的是内存地址 12345678910111213141516public static void main(String[] args) &#123; String str1 = new String(\"str\"); String str2 = new String(\"str\"); System.out.println(\"str1==str2:\" + (str1 == str2)); String str3=\"str\"; String str4=\"str\"; System.out.println(str3 == str4); System.out.println(System.identityHashCode(str1)); System.out.println(System.identityHashCode(str2)); System.out.println(System.identityHashCode(str3)); System.out.println(System.identityHashCode(str4)); &#125; 结果为 str1==str2:falsetrue323247493111501236338603633860 对象是放在堆中的，栈中存放的是对象的引用（地址）。由此可见’==’是对栈中的值进行比较的。如果要比较堆 中对象的内容是否相同，那么就要重写equals方法了。 但是这行代码，128！=128，a!=b 123456Integer a1 = 127;Integer b1 = 127;Integer a = 128;Integer b = 128;System.out.println(a1==b1);System.out.println(a==b); 结果 true false 去看Integer的源码可以明白，是这段源码 12345678910111213141516171819202122232425262728293031323334private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; Integer对于 对于-128到127之间的数，会进行缓存 。 2，equals() 1,默认没有重新的情况下，都调用的是Objects 的equals（）的方法，源码如下： 1public boolean equals(Object obj) &#123; return (this == obj);&#125; ​ 可以看到是Objects中的equal（）方法和== 是等同的。 2，日常的代码中会覆盖equal() 方法，下面是string 类 重写的equal（）方法 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; ​ 逻辑很明显： ​ 内存地址相同，直接返回true ​ 比较对象是String类型，直接返回false ​ a和b长度不同，直接返回false ​ 逐个字符比较，有不同就返回false equal重写注意的五个原则​ 1 自反性：对任意引用值X，x.equals(x)的返回值一定为true.​ 2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;​ 3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true​ 4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变​ 5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 3，hashCodeObjects给出的hashCode（）的原生代码是： 1public native int hashCode(); 返回时的一个int 类型的数值。 下面是引用摘抄的 ======================================================================================= hashCode()方法返回的就是一个数值，从方法的名称上就可以看出，其目的是生成一个hash码。hash码的主要用途就是在对对象进行散列的时候作为key输入，据此很容易推断出，我们需要每个对象的hash码尽可能不同，这样才能保证散列的存取性能。事实上，Object类提供的默认实现确实保证每个对象的hash码不同（在对象的内存地址基础上经过特定算法返回一个hash码）。Java采用了哈希表的原理。哈希（Hash）实际上是个人名，由于他提出一哈希算法的概念，所以就以他的名字命名了。 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。 散列函数,散列算法,哈希函数。是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。好的散列函数在输入域中很少出现散列冲突。 ====================================================================================== hashCode的作用想要明白，必须要先知道Java中的集合。 总的来说，Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？ 这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。 这样一来，当集合要添加新的元素时， 先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 4、eqauls方法和hashCode方法关系Java对于eqauls方法和hashCode方法是这样规定的： (1)同一对象上多次调用hashCode()方法，总是返回相同的整型值。 (2)如果a.equals(b)，则一定有a.hashCode() 一定等于 b.hashCode()。(3)如果!a.equals(b)，则a.hashCode() 不一定等于 b.hashCode()。此时如果a.hashCode() 总是不等于 b.hashCode()，会提高hashtables的性能。 (4)a.hashCode()==b.hashCode() 则 a.equals(b)可真可假 (5)a.hashCode()！= b.hashCode() 则 a.equals(b)为假。 上面结论简记： 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。2、如果两个对象不equals，他们的hashcode有可能相等。3、如果两个对象hashcode相等，他们不一定equals。4、如果两个对象hashcode不相等，他们一定不equals。 关于这两个方法的重要规范：规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该相等”。不过请注意：这个只是规范，如果你非要写一个类让equals(Object obj)返回true而hashcode()返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了Java规范，程序也就埋下了BUG。 规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 5、为什么覆盖equals时总要覆盖hashCode 一个很常见的错误根源在于没有覆盖hashCode方法。在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。 1.在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。 2.如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。 3.如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。 6、总结：1、equals方法用于比较对象的内容是否相等（覆盖以后） 2、hashcode方法只有在集合中用到 3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。 4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。 以上从第四点以后转载至博客：https://blog.csdn.net/hla199106/article/details/46907725","categories":[],"tags":[{"name":"Java基础知识","slug":"Java基础知识","permalink":"https://liudong-code.github.io/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"keywords":[]},{"title":"写于博客之始","slug":"写于博客之始","date":"2020-02-26T10:00:08.000Z","updated":"2020-02-27T07:36:23.335Z","comments":true,"path":"2020/02/26/写于博客之始/","link":"","permalink":"https://liudong-code.github.io/2020/02/26/%E5%86%99%E4%BA%8E%E5%8D%9A%E5%AE%A2%E4%B9%8B%E5%A7%8B/","excerpt":"","text":"​ 重新整理了之前的旧的博客，发现有部分博客有老东家的Code，想起来之前有同事因无意中泄露了公司的淘宝三段码，而受到处罚，索性就新搞了一个新的博客 地址，这几天正好因为疫情在家里面，找工作也不是很好找，就把之前的整理的东西全部搞过来。新的博客只弄了主题，其他的细节都还没整，想的是尽快的把日常干货先给弄上来。嗯，就这些吧！ ​","categories":[],"tags":[{"name":"日常随笔","slug":"日常随笔","permalink":"https://liudong-code.github.io/tags/%E6%97%A5%E5%B8%B8%E9%9A%8F%E7%AC%94/"}],"keywords":[]}]}